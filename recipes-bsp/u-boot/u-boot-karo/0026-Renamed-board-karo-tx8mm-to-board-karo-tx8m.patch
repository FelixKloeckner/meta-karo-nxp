From db3d8a1f272d8a99bf0a571a70dd7de9e4f23a27 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lothar=20Wa=C3=9Fmann?= <LW@KARO-electronics.de>
Date: Fri, 8 Nov 2019 11:01:42 +0100
Subject: [PATCH 26/39] Renamed board/karo/tx8mm to board/karo/tx8m

---
 arch/arm/mach-imx/imx8m/Kconfig                    |    5 +-
 board/karo/tx8m/Kconfig                            |   55 +
 board/karo/tx8m/Makefile                           |   21 +
 board/karo/tx8m/config.mk                          |    5 +
 board/karo/tx8m/ddr/Makefile                       |   10 +
 board/karo/tx8m/ddr/ddr.h                          |   70 +
 board/karo/tx8m/ddr/ddr3l/Makefile                 |   13 +
 board/karo/tx8m/ddr/ddr3l/anamix_common.h          |   88 ++
 board/karo/tx8m/ddr/ddr3l/ddr3_define.h            |   43 +
 board/karo/tx8m/ddr/ddr3l/ddr3_phyinit_task.c      |   73 ++
 .../ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c     | 1156 ++++++++++++++++
 .../tx8m/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c    |  277 ++++
 .../ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c |  969 ++++++++++++++
 .../ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c    |  971 ++++++++++++++
 board/karo/tx8m/ddr/ddr_init.c                     |  197 +++
 board/karo/tx8m/ddr/ddrphy_train.c                 |  355 +++++
 board/karo/tx8m/ddr/helper.c                       |  102 ++
 .../karo/tx8m/ddr/wait_ddrphy_training_complete.c  |  101 ++
 board/karo/tx8m/ddr3l_timing.c                     | 1385 ++++++++++++++++++++
 board/karo/tx8m/qs8m.c                             |  872 ++++++++++++
 board/karo/tx8m/spl.c                              |  430 ++++++
 board/karo/tx8m/tx8m.c                             |  887 +++++++++++++
 board/karo/tx8mm/Kconfig                           |   38 -
 board/karo/tx8mm/Makefile                          |   12 -
 board/karo/tx8mm/ddr/Makefile                      |   10 -
 board/karo/tx8mm/ddr/ddr.h                         |   59 -
 board/karo/tx8mm/ddr/ddr3l/Makefile                |   13 -
 board/karo/tx8mm/ddr/ddr3l/anamix_common.h         |   88 --
 board/karo/tx8mm/ddr/ddr3l/ddr3_define.h           |   43 -
 board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c     |   73 --
 .../ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c     | 1156 ----------------
 .../tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c   |  277 ----
 .../ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c |  969 --------------
 .../ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c    |  971 --------------
 board/karo/tx8mm/ddr/ddr_init.c                    |  173 ---
 board/karo/tx8mm/ddr/ddrphy_train.c                |  351 -----
 board/karo/tx8mm/ddr/helper.c                      |  102 --
 .../karo/tx8mm/ddr/wait_ddrphy_training_complete.c |  101 --
 board/karo/tx8mm/spl.c                             |  306 -----
 board/karo/tx8mm/tx8mm.c                           |  833 ------------
 include/configs/tx8m.h                             |  208 +++
 include/configs/tx8mm.h                            |  189 ---
 42 files changed, 8290 insertions(+), 5767 deletions(-)
 create mode 100644 board/karo/tx8m/Kconfig
 create mode 100644 board/karo/tx8m/Makefile
 create mode 100644 board/karo/tx8m/config.mk
 create mode 100644 board/karo/tx8m/ddr/Makefile
 create mode 100644 board/karo/tx8m/ddr/ddr.h
 create mode 100644 board/karo/tx8m/ddr/ddr3l/Makefile
 create mode 100644 board/karo/tx8m/ddr/ddr3l/anamix_common.h
 create mode 100644 board/karo/tx8m/ddr/ddr3l/ddr3_define.h
 create mode 100644 board/karo/tx8m/ddr/ddr3l/ddr3_phyinit_task.c
 create mode 100644 board/karo/tx8m/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c
 create mode 100644 board/karo/tx8m/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c
 create mode 100644 board/karo/tx8m/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c
 create mode 100644 board/karo/tx8m/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c
 create mode 100644 board/karo/tx8m/ddr/ddr_init.c
 create mode 100644 board/karo/tx8m/ddr/ddrphy_train.c
 create mode 100644 board/karo/tx8m/ddr/helper.c
 create mode 100644 board/karo/tx8m/ddr/wait_ddrphy_training_complete.c
 create mode 100644 board/karo/tx8m/ddr3l_timing.c
 create mode 100644 board/karo/tx8m/qs8m.c
 create mode 100644 board/karo/tx8m/spl.c
 create mode 100644 board/karo/tx8m/tx8m.c
 delete mode 100644 board/karo/tx8mm/Kconfig
 delete mode 100644 board/karo/tx8mm/Makefile
 delete mode 100644 board/karo/tx8mm/ddr/Makefile
 delete mode 100644 board/karo/tx8mm/ddr/ddr.h
 delete mode 100644 board/karo/tx8mm/ddr/ddr3l/Makefile
 delete mode 100644 board/karo/tx8mm/ddr/ddr3l/anamix_common.h
 delete mode 100644 board/karo/tx8mm/ddr/ddr3l/ddr3_define.h
 delete mode 100644 board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c
 delete mode 100644 board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c
 delete mode 100644 board/karo/tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c
 delete mode 100644 board/karo/tx8mm/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c
 delete mode 100644 board/karo/tx8mm/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c
 delete mode 100644 board/karo/tx8mm/ddr/ddr_init.c
 delete mode 100644 board/karo/tx8mm/ddr/ddrphy_train.c
 delete mode 100644 board/karo/tx8mm/ddr/helper.c
 delete mode 100644 board/karo/tx8mm/ddr/wait_ddrphy_training_complete.c
 delete mode 100644 board/karo/tx8mm/spl.c
 delete mode 100644 board/karo/tx8mm/tx8mm.c
 create mode 100644 include/configs/tx8m.h
 delete mode 100644 include/configs/tx8mm.h

diff --git a/arch/arm/mach-imx/imx8m/Kconfig b/arch/arm/mach-imx/imx8m/Kconfig
index 9b58030..5989843 100644
--- a/arch/arm/mach-imx/imx8m/Kconfig
+++ b/arch/arm/mach-imx/imx8m/Kconfig
@@ -79,8 +79,7 @@ config TARGET_IMX8MN_EVK
 	select IMX8M_DDR4
 
 config TARGET_TX8M
-	bool "Ka-Ro electronics imx8mm boards"
-	select IMX8MM
+	bool "Ka-Ro electronics imx8m boards"
 	select SUPPORT_SPL
 
 endchoice
@@ -95,6 +94,6 @@ source "board/freescale/imx8mq_aiy/Kconfig"
 source "board/freescale/imx8mm_evk/Kconfig"
 source "board/freescale/imx8mm_val/Kconfig"
 source "board/freescale/imx8mn_evk/Kconfig"
-source "board/karo/tx8mm/Kconfig"
+source "board/karo/tx8m/Kconfig"
 
 endif
diff --git a/board/karo/tx8m/Kconfig b/board/karo/tx8m/Kconfig
new file mode 100644
index 0000000..0dc30ed
--- /dev/null
+++ b/board/karo/tx8m/Kconfig
@@ -0,0 +1,55 @@
+if TARGET_TX8M
+
+config SYS_BOARD
+	default "tx8m"
+
+config SYS_CONFIG_NAME
+	default "tx8m"
+
+config SYS_VENDOR
+	default "karo"
+
+config KARO_TX8MM
+	bool "Ka-Ro TX8M-1610 module"
+	select IMX8MM
+	select BOARD_LATE_INIT
+	imply FEC_MXC
+	select MII
+	select PHYLIB
+	select MXC_UART
+
+config KARO_QS8M
+	bool "Ka-Ro TX8M-1610 compatible solder-in module"
+	select IMX8MM
+	select BOARD_LATE_INIT
+	imply FEC_MXC
+	select MII
+	select PHYLIB
+	select MXC_UART
+
+config KARO_TX8MN
+	bool "Ka-Ro TX8M-ND00 module"
+	select IMX8MN
+	select BOARD_LATE_INIT
+	imply FEC_MXC
+	select MII
+	select PHYLIB
+	select MXC_UART
+
+choice
+        prompt "U-Boot image variant"
+	default TX8M_UBOOT
+
+config TX8M_UBOOT
+        bool "Standard U-Boot image"
+
+config TX8M_UBOOT_MFG
+        bool "U-Boot image for use with Freescale's MfGTool"
+
+config TX8M_UBOOT_NOENV
+        bool "U-Boot using only built-in environment"
+        select UBOOT_IGNORE_ENV
+
+endchoice
+
+endif
diff --git a/board/karo/tx8m/Makefile b/board/karo/tx8m/Makefile
new file mode 100644
index 0000000..8aa49a7
--- /dev/null
+++ b/board/karo/tx8m/Makefile
@@ -0,0 +1,21 @@
+#
+# Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+	obj-y += spl.o
+ifeq ($(CONFIG_IMX8M_DRAM),)
+	obj-y += ddr/
+endif
+
+obj-$(CONFIG_IMX8M_DDR3L) += ddr3l_timing.o
+
+else
+
+obj-$(CONFIG_KARO_TX8MM) += tx8m.o
+obj-$(CONFIG_KARO_TX8MN) += tx8m.o
+obj-$(CONFIG_KARO_QS8M) += qs8m.o
+
+endif
diff --git a/board/karo/tx8m/config.mk b/board/karo/tx8m/config.mk
new file mode 100644
index 0000000..01f5eb4
--- /dev/null
+++ b/board/karo/tx8m/config.mk
@@ -0,0 +1,5 @@
+ifeq ($(CONFIG_SPL_BUILD),)
+#	PLATFORM_CPPFLAGS += -DDEBUG
+else
+#	PLATFORM_CPPFLAGS += -DDEBUG
+endif
diff --git a/board/karo/tx8m/ddr/Makefile b/board/karo/tx8m/ddr/Makefile
new file mode 100644
index 0000000..30b5b92
--- /dev/null
+++ b/board/karo/tx8m/ddr/Makefile
@@ -0,0 +1,10 @@
+#
+# Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += helper.o wait_ddrphy_training_complete.o
+obj-$(CONFIG_TARGET_TX8M) += ddrphy_train.o ddr_init.o
+endif
diff --git a/board/karo/tx8m/ddr/ddr.h b/board/karo/tx8m/ddr/ddr.h
new file mode 100644
index 0000000..b489233
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ * Common file for ddr code
+ */
+
+#ifndef __M845S_DDR_H_
+#define __M845S_DDR_H_
+
+#ifdef DDR_DEBUG
+#define ddr_dbg(fmt, ...) printf("DDR: debug:" fmt, ##__VA_ARGS__)
+#else
+#define ddr_dbg(fmt, ...) do {} while (0)
+#endif
+
+#if defined(CONFIG_KARO_TX8MM)
+#define SDRAM_BUS_WIDTH 0
+#elif defined(CONFIG_KARO_TX8MN)
+#define SDRAM_BUS_WIDTH 1
+#elif defined(CONFIG_KARO_QS8M)
+#define SDRAM_BUS_WIDTH 1
+#else
+#error Unsupported Board
+#endif
+
+/*******************************************************************
+ Desc: user data type
+
+ *******************************************************************/
+enum fw_type {
+	FW_1D_IMAGE,
+	FW_2D_IMAGE,
+};
+/*******************************************************************
+ Desc: prototype
+
+ *******************************************************************/
+void ddr_init(void);
+void ddr_load_train_code(enum fw_type type);
+void wait_ddrphy_training_complete(void);
+void dwc_ddrphy_phyinit_userCustom_E_setDfiClk(unsigned int pstate);
+void dwc_ddrphy_phyinit_userCustom_J_enterMissionMode(void);
+void dwc_ddrphy_phyinit_userCustom_customPostTrain(void);
+void dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy(void);
+void dwc_ddrphy_phyinit_userCustom_A_bringupPower(void);
+void dwc_ddrphy_phyinit_userCustom_overrideUserInput(void);
+void dwc_ddrphy_phyinit_userCustom_H_readMsgBlock(unsigned int run_2D);
+void dwc_ddrphy_phyinit_userCustom_G_waitFwDone(void);
+void ddr_cfg_phy(void);
+
+/*******************************************************************
+ Desc: definition
+
+ *******************************************************************/
+static inline void reg32_write(unsigned long addr, u32 val)
+{
+	writel(val, addr);
+}
+
+static inline uint32_t reg32_read(unsigned long addr)
+{
+	return readl(addr);
+}
+
+static inline void reg32setbit(unsigned long addr, u32 bit)
+{
+	setbits_le32(addr, (1 << bit));
+}
+#endif
diff --git a/board/karo/tx8m/ddr/ddr3l/Makefile b/board/karo/tx8m/ddr/ddr3l/Makefile
new file mode 100644
index 0000000..dac4d50
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr3l/Makefile
@@ -0,0 +1,13 @@
+#
+# Copyright 2018 NXP
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += ddr3_phyinit_task.o
+obj-y += ddr3_phyinit_train_sw_ffc_fw09.o
+obj-y += ddr3_sw_fast_freq_chg_fw09.o
+obj-y += restore_1d2d_trained_csr_ddr3_p012.o
+obj-y += save_1d2d_trained_csr_ddr3_p012.o
+endif
diff --git a/board/karo/tx8m/ddr/ddr3l/anamix_common.h b/board/karo/tx8m/ddr/ddr3l/anamix_common.h
new file mode 100644
index 0000000..2413fe1
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr3l/anamix_common.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef ANAMIX_COMMON_TMP_H
+#define ANAMIX_COMMON_TMP_H
+
+/* ANAMIX Address Definitions */
+#define ANAMIX_PLL_BASE_ADDR		0x30360000
+#define ANAMIX_OSC_BASE_ADDR		0x30270000
+#define ANAMIX_TSN_BASE_ADDR		0x30260000
+
+/*  PLL TOP REG */
+#define AUDIO_PLL1_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x00)
+#define AUDIO_PLL1_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x04)
+#define AUDIO_PLL1_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x08)
+#define AUDIO_PLL1_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x0c)
+#define AUDIO_PLL1_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x10)
+#define AUDIO_PLL2_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x14)
+#define AUDIO_PLL2_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x18)
+#define AUDIO_PLL2_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x1c)
+#define AUDIO_PLL2_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x20)
+#define AUDIO_PLL2_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x24)
+#define VIDEO_PLL1_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x28)
+#define VIDEO_PLL1_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x2c)
+#define VIDEO_PLL1_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x30)
+#define VIDEO_PLL1_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x34)
+#define VIDEO_PLL1_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x38)
+#define VIDEO_PLL2_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x3c)
+#define VIDEO_PLL2_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x40)
+#define VIDEO_PLL2_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x44)
+#define VIDEO_PLL2_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x48)
+#define VIDEO_PLL2_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x4c)
+#define DRAM_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x50)
+#define DRAM_PLL_FDIV_CTL0_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x54)
+#define DRAM_PLL_FDIV_CTL1_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x58)
+#define DRAM_PLL_SSCG_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x5c)
+#define DRAM_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x60)
+#define GPU_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x64)
+#define GPU_PLL_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x68)
+#define GPU_PLL_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x6c)
+#define GPU_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x70)
+#define VPU_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x74)
+#define VPU_PLL_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x78)
+#define VPU_PLL_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x7c)
+#define VPU_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x80)
+#define ARM_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x84)
+#define ARM_PLL_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x88)
+#define ARM_PLL_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x8c)
+#define ARM_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x90)
+#define SYS_PLL1_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x94)
+#define SYS_PLL1_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x98)
+#define SYS_PLL1_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x9c)
+#define SYS_PLL1_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x100)
+#define SYS_PLL2_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x104)
+#define SYS_PLL2_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x108)
+#define SYS_PLL2_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x10c)
+#define SYS_PLL2_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x110)
+#define SYS_PLL3_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x114)
+#define SYS_PLL3_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x118)
+#define SYS_PLL3_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x11c)
+#define SYS_PLL3_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x120)
+#define ANAMIX_MISC_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x124)
+#define ANAMIX_CLK_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x128)
+
+/* TMP SNSR REG */
+#define TER_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x00)
+#define TSR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x04)
+#define TIER_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x08)
+#define TIDR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x0c)
+#define TMHTITR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x10)
+#define TMHTATR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x14)
+#define TMHTACTR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x18)
+#define TSCR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x1c)
+#define TRITSR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x20)
+#define TRATSR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x24)
+#define TASR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x28)
+#define TTMC_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x2c)
+
+/* OSC */
+#define SYS_OSCNML_CTL0_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x00)
+#define SYS_OSCNML_CTL1_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x04)
+#define HDMI_OSCNML_CTL0_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x8000)
+#define HDMI_OSCNML_CTL1_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x8004)
+
+#endif
diff --git a/board/karo/tx8m/ddr/ddr3l/ddr3_define.h b/board/karo/tx8m/ddr/ddr3l/ddr3_define.h
new file mode 100644
index 0000000..e2ce727
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr3l/ddr3_define.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef DDR3_DEFINE_H
+#define DDR3_DEFINE_H
+
+#include "../ddr.h"
+
+#define RUN_ON_SILICON
+
+#ifdef DDR3_1600MTS_SWFFC_RET
+	#define DDR3_SW_FFC
+#endif
+
+#define SAVE_DDRPHY_TRAIN_ADDR		0x180000
+#define DDR_CSD1_BASE_ADDR		0x40000000
+#define DDR_CSD2_BASE_ADDR		0x80000000
+
+#define ANAMIX_PLL_BASE_ADDR		0x30360000
+#define HW_DRAM_PLL_CFG0_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x60)
+#define HW_DRAM_PLL_CFG1_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x64)
+#define HW_DRAM_PLL_CFG2_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x68)
+#define GPC_PU_PWRHSK			0x303A01FC
+#define GPC_TOP_CONFIG_OFFSET		0x0000
+#define AIPS1_ARB_BASE_ADDR		0x30000000
+#define AIPS_TZ1_BASE_ADDR		AIPS1_ARB_BASE_ADDR
+#define AIPS1_OFF_BASE_ADDR		(AIPS_TZ1_BASE_ADDR + 0x200000)
+#define CCM_IPS_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x180000)
+#define CCM_SRC_CTRL_OFFSET		(CCM_IPS_BASE_ADDR + 0x800)
+#define CCM_SRC_CTRL(n)			(CCM_SRC_CTRL_OFFSET + 0x10 * (n))
+
+#define dwc_ddrphy_apb_wr(addr, data)	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * (addr), data)
+#define dwc_ddrphy_apb_rd(addr)		reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * (addr))
+#define	 reg32clrbit(addr, bitpos)	reg32_write((addr), reg32_read(addr) & ~(1 << (bitpos)))
+
+void restore_1d2d_trained_csr_ddr3_p012(unsigned int addr);
+void save_1d2d_trained_csr_ddr3_p012(unsigned int addr);
+void ddr3_phyinit_train_sw_ffc(unsigned int after_retention);
+
+#endif
diff --git a/board/karo/tx8m/ddr/ddr3l/ddr3_phyinit_task.c b/board/karo/tx8m/ddr/ddr3l/ddr3_phyinit_task.c
new file mode 100644
index 0000000..fb1bfe4
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr3l/ddr3_phyinit_task.c
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "ddr3_define.h"
+
+void dwc_ddrphy_phyinit_userCustom_E_setDfiClk (unsigned int pstate) {
+	if (pstate == 0) {
+		ddr_dbg("C: 1 ...\n");
+		dram_pll_init(DRAM_PLL_OUT_400M);
+	} else if (pstate == 1) {
+		ddr_dbg("C: 2 ...\n");
+		dram_pll_init(DRAM_PLL_OUT_266M);
+	} else if (pstate == 2) {
+		ddr_dbg("C: 3 ...\n");
+		dram_pll_init(DRAM_PLL_OUT_167M);
+	} else {
+		printf("C: no freq match\n");
+	}
+}
+
+void dwc_ddrphy_phyinit_userCustom_G_waitFwDone(void)
+{
+	wait_ddrphy_training_complete();
+}
+void dwc_ddrphy_phyinit_userCustom_overrideUserInput (void) {}
+void dwc_ddrphy_phyinit_userCustom_A_bringupPower (void) {}
+void dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy (void) {}
+void dwc_ddrphy_phyinit_userCustom_H_readMsgBlock(unsigned int Train2D) {}
+void dwc_ddrphy_phyinit_userCustom_customPostTrain(void) {}
+void dwc_ddrphy_phyinit_userCustom_J_enterMissionMode(void) {}
+
+void ddr3_mr_write(unsigned int mr, unsigned int data, unsigned int read, unsigned int rank)
+{
+	unsigned int tmp, mr_mirror, data_mirror;
+
+	/* 1. Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction. No */
+	/* writes should be performed to MRCTRL0 and MRCTRL1 if MRSTAT.mr_wr_busy = 1. */
+	do {
+		tmp = reg32_read(DDRC_MRSTAT(0));
+	} while (tmp & 0x1);
+
+	/* 2. Write the MRCTRL0.mr_type, MRCTRL0.mr_addr, MRCTRL0.mr_rank and (for MRWs) */
+	/* MRCTRL1.mr_data to define the MR transaction. */
+	/*  (A3, A4), (A5, A6), (A7, A8), (BA0, BA1),*/
+	tmp = reg32_read(DDRC_DIMMCTL(0));
+	if ((tmp & 0x2) && (rank == 0x2)) {
+	    mr_mirror = (mr & 0x4) | ((mr & 0x1) << 1) | ((mr & 0x2) >> 1);/* BA0, BA1 swap */
+		data_mirror = (data & 0xfe07) | ((data & 0x8) << 1) | ((data & 0x10) >> 1) | ((data & 0x20) << 1) | ((data & 0x40) >> 1) | ((data & 0x80) << 1) | ((data & 0x100) >> 1);
+	} else {
+	    mr_mirror = mr;
+	    data_mirror = data;
+	}
+
+	reg32_write(DDRC_MRCTRL0(0), read | (mr_mirror << 12) | (rank << 4));
+	reg32_write(DDRC_MRCTRL1(0), data_mirror);
+
+	/* 3. In a separate APB transaction, write the MRCTRL0.mr_wr to 1. This bit is self-clearing, and triggers */
+	/* the MR transaction. The uMCTL2 then asserts the MRSTAT.mr_wr_busy while it performs the MR */
+	/* transaction to SDRAM, and no further accesses can be initiated until it is deasserted. */
+	reg32setbit(DDRC_MRCTRL0(0), 31);
+	do {
+		tmp = reg32_read(DDRC_MRSTAT(0));
+	} while (tmp);
+
+}
diff --git a/board/karo/tx8m/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c b/board/karo/tx8m/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c
new file mode 100644
index 0000000..0cf71a7
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c
@@ -0,0 +1,1156 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "../ddr.h"
+#include "ddr3_define.h"
+
+void ddr3_phyinit_train_sw_ffc(unsigned int after_retention)
+{
+	/*  [dwc_ddrphy_phyinit_main] Start of dwc_ddrphy_phyinit_main() */
+	/*  [dwc_ddrphy_phyinit_sequence] Start of dwc_ddrphy_phyinit_sequence() */
+	/*  [dwc_ddrphy_phyinit_initStruct] Start of dwc_ddrphy_phyinit_initStruct() */
+	/*  [dwc_ddrphy_phyinit_initStruct] End of dwc_ddrphy_phyinit_initStruct() */
+	/*  [dwc_ddrphy_phyinit_setDefault] Start of dwc_ddrphy_phyinit_setDefault() */
+	/*  [dwc_ddrphy_phyinit_setDefault] End of dwc_ddrphy_phyinit_setDefault() */
+
+
+	/*  ############################################################## */
+	/*  */
+	/*   dwc_ddrphy_phyinit_userCustom_overrideUserInput is a user-editable function. */
+	/*   */
+	/*   See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/*  ############################################################## */
+
+	dwc_ddrphy_phyinit_userCustom_overrideUserInput ();
+	/*  */
+	/*   [dwc_ddrphy_phyinit_userCustom_overrideUserInput] End of dwc_ddrphy_phyinit_userCustom_overrideUserInput() */
+
+
+	/*  ############################################################## */
+	/*   */
+	/*   Step (A) : Bring up VDD, VDDQ, and VAA */
+	/*   */
+	/*   See PhyInit App Note for detailed description and function usage */
+	/*   */
+	/*  ############################################################## */
+
+
+	dwc_ddrphy_phyinit_userCustom_A_bringupPower ();
+
+	/*  [dwc_ddrphy_phyinit_userCustom_A_bringupPower] End of dwc_ddrphy_phyinit_userCustom_A_bringupPower() */
+	/*  [dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy] Start of dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy() */
+	/*  */
+	/*  */
+	/*  ############################################################## */
+	/*   */
+	/*   Step (B) Start Clocks and Reset the PHY */
+	/*   */
+	/*   See PhyInit App Note for detailed description and function usage */
+	/*   */
+	/*  ############################################################## */
+	/*  */
+	/*  */
+	dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy ();
+
+	/*  [dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy] End of dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy() */
+	/*  */
+
+	/*  ############################################################## */
+	/*   */
+	/*   Step (C) Initialize PHY Configuration */
+	/*   */
+	/*   Load the required PHY configuration registers for the appropriate mode and memory configuration */
+	/*   */
+	/*  ############################################################## */
+	/*  */
+
+	/*   [phyinit_C_initPhyConfig] Start of dwc_ddrphy_phyinit_C_initPhyConfig() */
+	/*  */
+	/*  ############################################################## */
+	/*   TxPreDrvMode[2] = 0 */
+	/*  ############################################################## */
+	/*   [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxSlewRate::TxPreDrvMode to 0x3 */
+	/*   [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxSlewRate::TxPreP to 0xf */
+	/*   [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxSlewRate::TxPreN to 0xc */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for TxSlewRate::TxPreP and TxSlewRate::TxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x1005f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1015f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1105f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1115f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1205f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1215f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1305f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1315f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b1_p0 */
+	/*   [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxSlewRate::TxPreDrvMode to 0x3 */
+	/*   [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxSlewRate::TxPreP to 0xf */
+	/*   [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxSlewRate::TxPreN to 0xc */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for TxSlewRate::TxPreP and TxSlewRate::TxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x11005f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11015f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11105f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11115f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11205f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11215f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11305f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11315f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b1_p1 */
+	/*   [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxSlewRate::TxPreDrvMode to 0x3 */
+	/*   [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxSlewRate::TxPreP to 0xf */
+	/*   [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxSlewRate::TxPreN to 0xc */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for TxSlewRate::TxPreP and TxSlewRate::TxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x21005f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21015f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21105f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21115f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21205f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21215f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21305f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21315f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b1_p2 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=0 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=0 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=0 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x55, 0x365); /*  DWC_DDRPHYA_ANIB0_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=1 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=1 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=1 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x1055, 0x365); /*  DWC_DDRPHYA_ANIB1_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=2 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=2 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=2 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x2055, 0x365); /*  DWC_DDRPHYA_ANIB2_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=3 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=3 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=3 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x3055, 0x365); /*  DWC_DDRPHYA_ANIB3_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x0, ANIB=4 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=4 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=4 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x4055, 0x65); /*  DWC_DDRPHYA_ANIB4_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x0, ANIB=5 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=5 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=5 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x5055, 0x65); /*  DWC_DDRPHYA_ANIB5_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=6 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=6 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=6 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x6055, 0x365); /*  DWC_DDRPHYA_ANIB6_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=7 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=7 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=7 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x7055, 0x365); /*  DWC_DDRPHYA_ANIB7_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=8 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=8 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=8 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x8055, 0x365); /*  DWC_DDRPHYA_ANIB8_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=9 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=9 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=9 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x9055, 0x365); /*  DWC_DDRPHYA_ANIB9_ATxSlewRate */
+	dwc_ddrphy_apb_wr(0x200c5, 0xb); /*  DWC_DDRPHYA_MASTER0_PllCtrl2_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0,  Memclk=800MHz, Programming PllCtrl2 to b based on DfiClk frequency = 400. */
+	dwc_ddrphy_apb_wr(0x1200c5, 0x7); /*  DWC_DDRPHYA_MASTER0_PllCtrl2_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1,  Memclk=266MHz, Programming PllCtrl2 to 7 based on DfiClk frequency = 133. */
+	dwc_ddrphy_apb_wr(0x2200c5, 0x7); /*  DWC_DDRPHYA_MASTER0_PllCtrl2_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2,  Memclk=166MHz, Programming PllCtrl2 to 7 based on DfiClk frequency = 83. */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  Program ARdPtrInitVal based on Frequency and PLL Bypass inputs */
+	/*  The values programmed here assume ideal properties of DfiClk */
+	/*  and Pclk including: */
+	/*  - DfiClk skew */
+	/*  - DfiClk jitter */
+	/*  - DfiClk PVT variations */
+	/*  - Pclk skew */
+	/*  - Pclk jitter */
+	/*  */
+	/*  PLL Bypassed mode: */
+	/*      For MemClk frequency > 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 2-6 */
+	/*      For MemClk frequency < 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 1-6 */
+	/*  */
+	/*  PLL Enabled mode: */
+	/*      For MemClk frequency > 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 1-6 */
+	/*      For MemClk frequency < 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 0-6 */
+	/*  */
+	/* ############################################################## */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming ARdPtrInitVal to 0x1 */
+	dwc_ddrphy_apb_wr(0x2002e, 0x1); /*  DWC_DDRPHYA_MASTER0_ARdPtrInitVal_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming ARdPtrInitVal to 0x1 */
+	dwc_ddrphy_apb_wr(0x12002e, 0x1); /*  DWC_DDRPHYA_MASTER0_ARdPtrInitVal_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming ARdPtrInitVal to 0x1 */
+	dwc_ddrphy_apb_wr(0x22002e, 0x1); /*  DWC_DDRPHYA_MASTER0_ARdPtrInitVal_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::TwoTckRxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::TwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::PositionDfeInit to 0x2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::LP4TglTwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::LP4PostambleExt to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::LP4SttcPreBridgeRxEn to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl to 0x8 */
+	dwc_ddrphy_apb_wr(0x20024, 0x8); /*  DWC_DDRPHYA_MASTER0_DqsPreambleControl_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DbyteDllModeCntrl to 0x0 */
+	dwc_ddrphy_apb_wr(0x2003a, 0x0); /*  DWC_DDRPHYA_MASTER0_DbyteDllModeCntrl */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::TwoTckRxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::TwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::PositionDfeInit to 0x2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::LP4TglTwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::LP4PostambleExt to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::LP4SttcPreBridgeRxEn to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl to 0x8 */
+	dwc_ddrphy_apb_wr(0x120024, 0x8); /*  DWC_DDRPHYA_MASTER0_DqsPreambleControl_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DbyteDllModeCntrl to 0x0 */
+	dwc_ddrphy_apb_wr(0x2003a, 0x0); /*  DWC_DDRPHYA_MASTER0_DbyteDllModeCntrl */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::TwoTckRxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::TwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::PositionDfeInit to 0x2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::LP4TglTwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::LP4PostambleExt to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::LP4SttcPreBridgeRxEn to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl to 0x8 */
+	dwc_ddrphy_apb_wr(0x220024, 0x8); /*  DWC_DDRPHYA_MASTER0_DqsPreambleControl_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DbyteDllModeCntrl to 0x0 */
+	dwc_ddrphy_apb_wr(0x2003a, 0x0); /*  DWC_DDRPHYA_MASTER0_DbyteDllModeCntrl */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming ProcOdtTimeCtl to 0xa */
+	dwc_ddrphy_apb_wr(0x20056, 0xa); /*  DWC_DDRPHYA_MASTER0_ProcOdtTimeCtl_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming ProcOdtTimeCtl to 0xa */
+	dwc_ddrphy_apb_wr(0x120056, 0xa); /*  DWC_DDRPHYA_MASTER0_ProcOdtTimeCtl_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming ProcOdtTimeCtl to 0xa */
+	dwc_ddrphy_apb_wr(0x220056, 0xa); /*  DWC_DDRPHYA_MASTER0_ProcOdtTimeCtl_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxOdtDrvStren::ODTStrenP to 0x18 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxOdtDrvStren::ODTStrenN to 0x18 */
+	dwc_ddrphy_apb_wr(0x1004d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1014d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1104d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1114d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1204d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1214d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1304d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1314d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b1_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxOdtDrvStren::ODTStrenP to 0x18 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxOdtDrvStren::ODTStrenN to 0x18 */
+	dwc_ddrphy_apb_wr(0x11004d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11014d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11104d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11114d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11204d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11214d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11304d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11314d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b1_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxOdtDrvStren::ODTStrenP to 0x18 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxOdtDrvStren::ODTStrenN to 0x18 */
+	dwc_ddrphy_apb_wr(0x21004d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21014d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21104d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21114d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21204d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21214d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21304d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21314d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b1_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqP to 0x38 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqN to 0x38 */
+	dwc_ddrphy_apb_wr(0x10049, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b0_p0 */
+	dwc_ddrphy_apb_wr(0x10149, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b1_p0 */
+	dwc_ddrphy_apb_wr(0x11049, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b0_p0 */
+	dwc_ddrphy_apb_wr(0x11149, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b1_p0 */
+	dwc_ddrphy_apb_wr(0x12049, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b0_p0 */
+	dwc_ddrphy_apb_wr(0x12149, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b1_p0 */
+	dwc_ddrphy_apb_wr(0x13049, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b0_p0 */
+	dwc_ddrphy_apb_wr(0x13149, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b1_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqP to 0x38 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqN to 0x38 */
+	dwc_ddrphy_apb_wr(0x110049, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b0_p1 */
+	dwc_ddrphy_apb_wr(0x110149, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b1_p1 */
+	dwc_ddrphy_apb_wr(0x111049, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b0_p1 */
+	dwc_ddrphy_apb_wr(0x111149, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b1_p1 */
+	dwc_ddrphy_apb_wr(0x112049, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b0_p1 */
+	dwc_ddrphy_apb_wr(0x112149, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b1_p1 */
+	dwc_ddrphy_apb_wr(0x113049, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b0_p1 */
+	dwc_ddrphy_apb_wr(0x113149, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b1_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqP to 0x38 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqN to 0x38 */
+	dwc_ddrphy_apb_wr(0x210049, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b0_p2 */
+	dwc_ddrphy_apb_wr(0x210149, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b1_p2 */
+	dwc_ddrphy_apb_wr(0x211049, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b0_p2 */
+	dwc_ddrphy_apb_wr(0x211149, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b1_p2 */
+	dwc_ddrphy_apb_wr(0x212049, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b0_p2 */
+	dwc_ddrphy_apb_wr(0x212149, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b1_p2 */
+	dwc_ddrphy_apb_wr(0x213049, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b0_p2 */
+	dwc_ddrphy_apb_wr(0x213149, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b1_p2 */
+	/*  [phyinit_C_initPhyConfig] Programming ATxImpedance::ADrvStrenP to 0x3 */
+	/*  [phyinit_C_initPhyConfig] Programming ATxImpedance::ADrvStrenN to 0x3 */
+	dwc_ddrphy_apb_wr(0x43, 0x63); /*  DWC_DDRPHYA_ANIB0_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x1043, 0x63); /*  DWC_DDRPHYA_ANIB1_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x2043, 0x63); /*  DWC_DDRPHYA_ANIB2_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x3043, 0x63); /*  DWC_DDRPHYA_ANIB3_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x4043, 0x63); /*  DWC_DDRPHYA_ANIB4_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x5043, 0x63); /*  DWC_DDRPHYA_ANIB5_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x6043, 0x63); /*  DWC_DDRPHYA_ANIB6_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x7043, 0x63); /*  DWC_DDRPHYA_ANIB7_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x8043, 0x63); /*  DWC_DDRPHYA_ANIB8_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x9043, 0x63); /*  DWC_DDRPHYA_ANIB9_ATxImpedance */
+	/*  [phyinit_C_initPhyConfig] Programming DfiMode to 0x5 */
+	dwc_ddrphy_apb_wr(0x20018, 0x5); /*  DWC_DDRPHYA_MASTER0_DfiMode */
+	/*  [phyinit_C_initPhyConfig] Programming DfiCAMode to 0x0 */
+	dwc_ddrphy_apb_wr(0x20075, 0x0); /*  DWC_DDRPHYA_MASTER0_DfiCAMode */
+	/*  [phyinit_C_initPhyConfig] Programming CalDrvStr0::CalDrvStrPd50 to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Programming CalDrvStr0::CalDrvStrPu50 to 0x0 */
+	dwc_ddrphy_apb_wr(0x20050, 0x0); /*  DWC_DDRPHYA_MASTER0_CalDrvStr0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming CalUclkInfo::CalUClkTicksPer1uS to 0x190 */
+	dwc_ddrphy_apb_wr(0x20008, 0x190); /*  DWC_DDRPHYA_MASTER0_CalUclkInfo_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming CalUclkInfo::CalUClkTicksPer1uS to 0x85 */
+	dwc_ddrphy_apb_wr(0x120008, 0x85); /*  DWC_DDRPHYA_MASTER0_CalUclkInfo_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming CalUclkInfo::CalUClkTicksPer1uS to 0x53 */
+	dwc_ddrphy_apb_wr(0x220008, 0x53); /*  DWC_DDRPHYA_MASTER0_CalUclkInfo_p2 */
+	/*  [phyinit_C_initPhyConfig] Programming CalRate::CalInterval to 0x9 */
+	/*  [phyinit_C_initPhyConfig] Programming CalRate::CalOnce to 0x0 */
+	dwc_ddrphy_apb_wr(0x20088, 0x9); /*  DWC_DDRPHYA_MASTER0_CalRate */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming VrefInGlobal::GlobalVrefInSel to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming VrefInGlobal::GlobalVrefInDAC to 0x1f */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming VrefInGlobal to 0xf8 */
+	dwc_ddrphy_apb_wr(0x200b2, 0xf8); /*  DWC_DDRPHYA_MASTER0_VrefInGlobal_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming DqDqsRcvCntrl::MajorModeDbyte to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming DqDqsRcvCntrl to 0x581 */
+	dwc_ddrphy_apb_wr(0x10043, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b0_p0 */
+	dwc_ddrphy_apb_wr(0x10143, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b1_p0 */
+	dwc_ddrphy_apb_wr(0x11043, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b0_p0 */
+	dwc_ddrphy_apb_wr(0x11143, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b1_p0 */
+	dwc_ddrphy_apb_wr(0x12043, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b0_p0 */
+	dwc_ddrphy_apb_wr(0x12143, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b1_p0 */
+	dwc_ddrphy_apb_wr(0x13043, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b0_p0 */
+	dwc_ddrphy_apb_wr(0x13143, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b1_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming VrefInGlobal::GlobalVrefInSel to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming VrefInGlobal::GlobalVrefInDAC to 0x1f */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming VrefInGlobal to 0xf8 */
+	dwc_ddrphy_apb_wr(0x1200b2, 0xf8); /*  DWC_DDRPHYA_MASTER0_VrefInGlobal_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming DqDqsRcvCntrl::MajorModeDbyte to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming DqDqsRcvCntrl to 0x581 */
+	dwc_ddrphy_apb_wr(0x110043, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b0_p1 */
+	dwc_ddrphy_apb_wr(0x110143, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b1_p1 */
+	dwc_ddrphy_apb_wr(0x111043, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b0_p1 */
+	dwc_ddrphy_apb_wr(0x111143, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b1_p1 */
+	dwc_ddrphy_apb_wr(0x112043, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b0_p1 */
+	dwc_ddrphy_apb_wr(0x112143, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b1_p1 */
+	dwc_ddrphy_apb_wr(0x113043, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b0_p1 */
+	dwc_ddrphy_apb_wr(0x113143, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b1_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming VrefInGlobal::GlobalVrefInSel to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming VrefInGlobal::GlobalVrefInDAC to 0x1f */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming VrefInGlobal to 0xf8 */
+	dwc_ddrphy_apb_wr(0x2200b2, 0xf8); /*  DWC_DDRPHYA_MASTER0_VrefInGlobal_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming DqDqsRcvCntrl::MajorModeDbyte to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming DqDqsRcvCntrl to 0x581 */
+	dwc_ddrphy_apb_wr(0x210043, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b0_p2 */
+	dwc_ddrphy_apb_wr(0x210143, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b1_p2 */
+	dwc_ddrphy_apb_wr(0x211043, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b0_p2 */
+	dwc_ddrphy_apb_wr(0x211143, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b1_p2 */
+	dwc_ddrphy_apb_wr(0x212043, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b0_p2 */
+	dwc_ddrphy_apb_wr(0x212143, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b1_p2 */
+	dwc_ddrphy_apb_wr(0x213043, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b0_p2 */
+	dwc_ddrphy_apb_wr(0x213143, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b1_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DfiFreqRatio_p0 to 0x1 */
+	dwc_ddrphy_apb_wr(0x200fa, 0x1); /*  DWC_DDRPHYA_MASTER0_DfiFreqRatio_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DfiFreqRatio_p1 to 0x1 */
+	dwc_ddrphy_apb_wr(0x1200fa, 0x1); /*  DWC_DDRPHYA_MASTER0_DfiFreqRatio_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DfiFreqRatio_p2 to 0x1 */
+	dwc_ddrphy_apb_wr(0x2200fa, 0x1); /*  DWC_DDRPHYA_MASTER0_DfiFreqRatio_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TristateModeCA::DisDynAdrTri_p0 to 0x1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TristateModeCA::DDR2TMode_p0 to 0x0 */
+	dwc_ddrphy_apb_wr(0x20019, 0x5); /*  DWC_DDRPHYA_MASTER0_TristateModeCA_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TristateModeCA::DisDynAdrTri_p1 to 0x1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TristateModeCA::DDR2TMode_p1 to 0x0 */
+	dwc_ddrphy_apb_wr(0x120019, 0x5); /*  DWC_DDRPHYA_MASTER0_TristateModeCA_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TristateModeCA::DisDynAdrTri_p2 to 0x1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TristateModeCA::DDR2TMode_p2 to 0x0 */
+	dwc_ddrphy_apb_wr(0x220019, 0x5); /*  DWC_DDRPHYA_MASTER0_TristateModeCA_p2 */
+	/*  [phyinit_C_initPhyConfig] Programming DfiFreqXlat* */
+	dwc_ddrphy_apb_wr(0x200f0, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat0 */
+	dwc_ddrphy_apb_wr(0x200f1, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat1 */
+	dwc_ddrphy_apb_wr(0x200f2, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat2 */
+	dwc_ddrphy_apb_wr(0x200f3, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat3 */
+	dwc_ddrphy_apb_wr(0x200f4, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat4 */
+	dwc_ddrphy_apb_wr(0x200f5, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat5 */
+	dwc_ddrphy_apb_wr(0x200f6, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat6 */
+	dwc_ddrphy_apb_wr(0x200f7, 0xf000); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat7 */
+	/*  [phyinit_C_initPhyConfig] Programming MasterX4Config::X4TG to 0x0 */
+	dwc_ddrphy_apb_wr(0x20025, 0x0); /*  DWC_DDRPHYA_MASTER0_MasterX4Config */
+	/*  [phyinit_C_initPhyConfig] End of dwc_ddrphy_phyinit_C_initPhyConfig() */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  dwc_ddrphy_phyihunit_userCustom_customPreTrain is a user-editable function. */
+	/*  */
+	/*  See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  [phyinit_userCustom_customPreTrain] Start of dwc_ddrphy_phyinit_userCustom_customPreTrain() */
+	/*  [phyinit_userCustom_customPreTrain] End of dwc_ddrphy_phyinit_userCustom_customPreTrain() */
+	/*  [dwc_ddrphy_phyinit_D_loadIMEM, 1D] Start of dwc_ddrphy_phyinit_D_loadIMEM (Train2D=0) */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  (D) Load the 1D IMEM image */
+	/*  */
+	/*  This function loads the training firmware IMEM image into the SRAM. */
+	/*  See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  */
+	/*  [dwc_ddrphy_phyinit_D_loadIMEM, 1D] Programming MemResetL to 0x2 */
+	if (!after_retention) {
+		dwc_ddrphy_apb_wr(0x20060, 0x2);
+
+		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_imem.incv */
+
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x50000 size 0x4000 */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x4000 */
+		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		/*       This allows the firmware unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_D_loadIMEM, 1D] End of dwc_ddrphy_phyinit_D_loadIMEM() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  Step (E) Set the PHY input clocks to the desired frequency for pstate 0 */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		dwc_ddrphy_phyinit_userCustom_E_setDfiClk (0);
+
+		/*  */
+		/*  [dwc_ddrphy_phyinit_userCustom_E_setDfiClk] End of dwc_ddrphy_phyinit_userCustom_E_setDfiClk() */
+		/*  [phyinit_F_loadDMEM, 1D] Start of dwc_ddrphy_phyinit_F_loadDMEM (pstate=0, Train2D=0) */
+
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  for test on silicon, load 1D dmem/imem here */
+#ifdef CONFIG_SPL_VSI_FW_LOADING
+		load_train_1d_code();
+#else
+		ddr_load_train_code(FW_1D_IMAGE);
+#endif
+		ddr_dbg("start 1d train\n");
+
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (F) Load the 1D DMEM image and write the 1D Message Block parameters for the training firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_dmem.incv */
+
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x54000 size 0x36a */
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x54000, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54000, 0x600);
+#endif
+		dwc_ddrphy_apb_wr(0x54001, 0x0);
+		dwc_ddrphy_apb_wr(0x54002, 0x0);
+		dwc_ddrphy_apb_wr(0x54003, 0x640);
+		dwc_ddrphy_apb_wr(0x54004, 0x2);
+		dwc_ddrphy_apb_wr(0x54005, 0x0);
+		dwc_ddrphy_apb_wr(0x54006, 0x140);
+		dwc_ddrphy_apb_wr(0x54007, 0x2000);
+#ifdef DDR_ONE_RANK
+		dwc_ddrphy_apb_wr(0x54008, 0x101);
+		dwc_ddrphy_apb_wr(0x54009, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54008, 0x303);
+		dwc_ddrphy_apb_wr(0x54009, 0x200);
+#endif
+		dwc_ddrphy_apb_wr(0x5400a, 0x0);
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x5400b, 0x31f);
+#else
+		dwc_ddrphy_apb_wr(0x5400b, 0x1);
+#endif
+		dwc_ddrphy_apb_wr(0x5400c, 0xc8);
+		dwc_ddrphy_apb_wr(0x5400d, 0x0);
+		dwc_ddrphy_apb_wr(0x5400e, 0x0);
+		dwc_ddrphy_apb_wr(0x5400f, 0x0);
+		dwc_ddrphy_apb_wr(0x54010, 0x0);
+		dwc_ddrphy_apb_wr(0x54011, 0x0);
+		dwc_ddrphy_apb_wr(0x54012, 0x1);
+		dwc_ddrphy_apb_wr(0x5402f, 0xd70);
+		dwc_ddrphy_apb_wr(0x54030, 0x4);
+		dwc_ddrphy_apb_wr(0x54031, 0x18);
+		dwc_ddrphy_apb_wr(0x5403a, 0x1221);
+		dwc_ddrphy_apb_wr(0x5403b, 0x4884);
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x36a */
+		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		/*       This allows the firmware unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [phyinit_F_loadDMEM, 1D] End of dwc_ddrphy_phyinit_F_loadDMEM() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (G) Execute the Training Firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.  Reset the firmware microcontroller by writing the MicroReset CSR to set the StallToMicro and */
+		/*      ResetToMicro fields to 1 (all other fields should be zero). */
+		/*      Then rewrite the CSR so that only the StallToMicro remains set (all other fields should be zero). */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		dwc_ddrphy_apb_wr(0xd0099, 0x9); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  2. Begin execution of the training firmware by setting the MicroReset CSR to 4'b0000. */
+		dwc_ddrphy_apb_wr(0xd0099, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  3.   Wait for the training firmware to complete by following the procedure in "uCtrl Initialization and Mailbox Messaging" */
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] Wait for the training firmware to complete.  Implement timeout fucntion or follow the procedure in "3.4 Running the firmware" of the Training Firmware Application Note to poll the Mailbox message. */
+		dwc_ddrphy_phyinit_userCustom_G_waitFwDone ();
+
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] End of dwc_ddrphy_phyinit_userCustom_G_waitFwDone() */
+		/*  4.   Halt the microcontroller." */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  [dwc_ddrphy_phyinit_G_execFW] End of dwc_ddrphy_phyinit_G_execFW () */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (H) Read the Message Block results */
+		/*  */
+		/*  The procedure is as follows: */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  */
+		/*  2. Read the Firmware Message Block to obtain the results from the training. */
+		/*  This can be accomplished by issuing APB read commands to the DMEM addresses. */
+		/*  Example: */
+		/*  if (Train2D) */
+		/*  { */
+		/*    _read_2d_message_block_outputs_ */
+		/*  } */
+		/*  else */
+		/*  { */
+		/*    _read_1d_message_block_outputs_ */
+		/*  } */
+		dwc_ddrphy_phyinit_userCustom_H_readMsgBlock (0);
+
+		/*  [dwc_ddrphy_phyinit_userCustom_H_readMsgBlock] End of dwc_ddrphy_phyinit_userCustom_H_readMsgBlock () */
+		/*  3.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  4.	If training is required at another frequency, repeat the operations starting at step (E). */
+		/*  [dwc_ddrphy_phyinit_H_readMsgBlock] End of dwc_ddrphy_phyinit_H_readMsgBlock() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  Step (E) Set the PHY input clocks to the desired frequency for pstate 1 */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+#ifdef DDR3_SW_FFC
+		dwc_ddrphy_phyinit_userCustom_E_setDfiClk (1);
+
+		/*  */
+		/*  [dwc_ddrphy_phyinit_userCustom_E_setDfiClk] End of dwc_ddrphy_phyinit_userCustom_E_setDfiClk() */
+		/*  [phyinit_F_loadDMEM, 1D] Start of dwc_ddrphy_phyinit_F_loadDMEM (pstate=1, Train2D=0) */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (F) Load the 1D DMEM image and write the 1D Message Block parameters for the training firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_dmem.incv */
+
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x54000 size 0x36a */
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x54000, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54000, 0x600);
+#endif
+		dwc_ddrphy_apb_wr(0x54001, 0x0);
+		dwc_ddrphy_apb_wr(0x54002, 0x1);
+		dwc_ddrphy_apb_wr(0x54003, 0x214);
+		dwc_ddrphy_apb_wr(0x54004, 0x2);
+		dwc_ddrphy_apb_wr(0x54005, 0x0);
+		dwc_ddrphy_apb_wr(0x54006, 0x140);
+		dwc_ddrphy_apb_wr(0x54007, 0x2000);
+#ifdef DDR_ONE_RANK
+		dwc_ddrphy_apb_wr(0x54008, 0x101);
+		dwc_ddrphy_apb_wr(0x54009, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54008, 0x303);
+		dwc_ddrphy_apb_wr(0x54009, 0x200);
+#endif
+		dwc_ddrphy_apb_wr(0x5400a, 0x0);
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x5400b, 0x21f);
+#else
+		dwc_ddrphy_apb_wr(0x5400b, 0x1);
+#endif
+		dwc_ddrphy_apb_wr(0x5400c, 0xc8);
+		dwc_ddrphy_apb_wr(0x5400d, 0x0);
+		dwc_ddrphy_apb_wr(0x5400e, 0x0);
+		dwc_ddrphy_apb_wr(0x5400f, 0x0);
+		dwc_ddrphy_apb_wr(0x54010, 0x0);
+		dwc_ddrphy_apb_wr(0x54011, 0x0);
+		dwc_ddrphy_apb_wr(0x54012, 0x1);
+		dwc_ddrphy_apb_wr(0x5402f, 0x930);
+		dwc_ddrphy_apb_wr(0x54030, 0x4);
+		dwc_ddrphy_apb_wr(0x54031, 0x8);
+		dwc_ddrphy_apb_wr(0x5403a, 0x1221);
+		dwc_ddrphy_apb_wr(0x5403b, 0x4884);
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x36a */
+		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		/*       This allows the firmware unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [phyinit_F_loadDMEM, 1D] End of dwc_ddrphy_phyinit_F_loadDMEM() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (G) Execute the Training Firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.  Reset the firmware microcontroller by writing the MicroReset CSR to set the StallToMicro and */
+		/*      ResetToMicro fields to 1 (all other fields should be zero). */
+		/*      Then rewrite the CSR so that only the StallToMicro remains set (all other fields should be zero). */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		dwc_ddrphy_apb_wr(0xd0099, 0x9); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  2. Begin execution of the training firmware by setting the MicroReset CSR to 4'b0000. */
+		dwc_ddrphy_apb_wr(0xd0099, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  3.   Wait for the training firmware to complete by following the procedure in "uCtrl Initialization and Mailbox Messaging" */
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] Wait for the training firmware to complete.  Implement timeout fucntion or follow the procedure in "3.4 Running the firmware" of the Training Firmware Application Note to poll the Mailbox message. */
+		dwc_ddrphy_phyinit_userCustom_G_waitFwDone ();
+
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] End of dwc_ddrphy_phyinit_userCustom_G_waitFwDone() */
+		/*  4.   Halt the microcontroller." */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  [dwc_ddrphy_phyinit_G_execFW] End of dwc_ddrphy_phyinit_G_execFW () */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (H) Read the Message Block results */
+		/*  */
+		/*  The procedure is as follows: */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  */
+		/*  2. Read the Firmware Message Block to obtain the results from the training. */
+		/*  This can be accomplished by issuing APB read commands to the DMEM addresses. */
+		/*  Example: */
+		/*  if (Train2D) */
+		/*  { */
+		/*    _read_2d_message_block_outputs_ */
+		/*  } */
+		/*  else */
+		/*  { */
+		/*    _read_1d_message_block_outputs_ */
+		/*  } */
+		dwc_ddrphy_phyinit_userCustom_H_readMsgBlock (0);
+
+		/*  [dwc_ddrphy_phyinit_userCustom_H_readMsgBlock] End of dwc_ddrphy_phyinit_userCustom_H_readMsgBlock () */
+		/*  3.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  4.	If training is required at another frequency, repeat the operations starting at step (E). */
+		/*  [dwc_ddrphy_phyinit_H_readMsgBlock] End of dwc_ddrphy_phyinit_H_readMsgBlock() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  Step (E) Set the PHY input clocks to the desired frequency for pstate 2 */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		dwc_ddrphy_phyinit_userCustom_E_setDfiClk (2);
+
+		/*  */
+		/*  [dwc_ddrphy_phyinit_userCustom_E_setDfiClk] End of dwc_ddrphy_phyinit_userCustom_E_setDfiClk() */
+		/*  [phyinit_F_loadDMEM, 1D] Start of dwc_ddrphy_phyinit_F_loadDMEM (pstate=2, Train2D=0) */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (F) Load the 1D DMEM image and write the 1D Message Block parameters for the training firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_dmem.incv */
+
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x54000 size 0x36a */
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x54000, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54000, 0x600);
+#endif
+		dwc_ddrphy_apb_wr(0x54001, 0x0);
+		dwc_ddrphy_apb_wr(0x54002, 0x2);
+		dwc_ddrphy_apb_wr(0x54003, 0x14c);
+		dwc_ddrphy_apb_wr(0x54004, 0x2);
+		dwc_ddrphy_apb_wr(0x54005, 0x0);
+		dwc_ddrphy_apb_wr(0x54006, 0x140);
+		dwc_ddrphy_apb_wr(0x54007, 0x2000);
+#ifdef DDR_ONE_RANK
+		dwc_ddrphy_apb_wr(0x54008, 0x101);
+		dwc_ddrphy_apb_wr(0x54009, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54008, 0x303);
+		dwc_ddrphy_apb_wr(0x54009, 0x200);
+#endif
+		dwc_ddrphy_apb_wr(0x5400a, 0x0);
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x5400b, 0x21f);
+#else
+		dwc_ddrphy_apb_wr(0x5400b, 0x1);
+#endif
+		dwc_ddrphy_apb_wr(0x5400c, 0xc8);
+		dwc_ddrphy_apb_wr(0x5400d, 0x0);
+		dwc_ddrphy_apb_wr(0x5400e, 0x0);
+		dwc_ddrphy_apb_wr(0x5400f, 0x0);
+		dwc_ddrphy_apb_wr(0x54010, 0x0);
+		dwc_ddrphy_apb_wr(0x54011, 0x0);
+		dwc_ddrphy_apb_wr(0x54012, 0x1);
+		dwc_ddrphy_apb_wr(0x5402f, 0x520);
+		dwc_ddrphy_apb_wr(0x54030, 0x4);
+		dwc_ddrphy_apb_wr(0x54031, 0x0);
+		dwc_ddrphy_apb_wr(0x5403a, 0x1221);
+		dwc_ddrphy_apb_wr(0x5403b, 0x4884);
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x36a */
+		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		/*       This allows the firmware unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [phyinit_F_loadDMEM, 1D] End of dwc_ddrphy_phyinit_F_loadDMEM() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (G) Execute the Training Firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.  Reset the firmware microcontroller by writing the MicroReset CSR to set the StallToMicro and */
+		/*      ResetToMicro fields to 1 (all other fields should be zero). */
+		/*      Then rewrite the CSR so that only the StallToMicro remains set (all other fields should be zero). */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		dwc_ddrphy_apb_wr(0xd0099, 0x9); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  2. Begin execution of the training firmware by setting the MicroReset CSR to 4'b0000. */
+		dwc_ddrphy_apb_wr(0xd0099, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  3.   Wait for the training firmware to complete by following the procedure in "uCtrl Initialization and Mailbox Messaging" */
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] Wait for the training firmware to complete.  Implement timeout fucntion or follow the procedure in "3.4 Running the firmware" of the Training Firmware Application Note to poll the Mailbox message. */
+		dwc_ddrphy_phyinit_userCustom_G_waitFwDone ();
+
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] End of dwc_ddrphy_phyinit_userCustom_G_waitFwDone() */
+		/*  4.   Halt the microcontroller." */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  [dwc_ddrphy_phyinit_G_execFW] End of dwc_ddrphy_phyinit_G_execFW () */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (H) Read the Message Block results */
+		/*  */
+		/*  The procedure is as follows: */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  */
+		/*  2. Read the Firmware Message Block to obtain the results from the training. */
+		/*  This can be accomplished by issuing APB read commands to the DMEM addresses. */
+		/*  Example: */
+		/*  if (Train2D) */
+		/*  { */
+		/*    _read_2d_message_block_outputs_ */
+		/*  } */
+		/*  else */
+		/*  { */
+		/*    _read_1d_message_block_outputs_ */
+		/*  } */
+		dwc_ddrphy_phyinit_userCustom_H_readMsgBlock (0);
+
+		/*  [dwc_ddrphy_phyinit_userCustom_H_readMsgBlock] End of dwc_ddrphy_phyinit_userCustom_H_readMsgBlock () */
+		/*  3.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  4.	If training is required at another frequency, repeat the operations starting at step (E). */
+		/*  [dwc_ddrphy_phyinit_H_readMsgBlock] End of dwc_ddrphy_phyinit_H_readMsgBlock() */
+		/*  [phyinit_I_loadPIEImage] Start of dwc_ddrphy_phyinit_I_loadPIEImage() */
+#endif /*  DDR3_SW_FFC */
+		ddr_dbg("1D training done!!!!\n");
+	} /* !after_retention */else {/* after_retention */
+		/* restore_1d2d_trained_csr_ddr3_p0(SAVE_DDRPHY_TRAIN_ADDR); */
+		restore_1d2d_trained_csr_ddr3_p012(SAVE_DDRPHY_TRAIN_ADDR);
+	} /* after_retention */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  (I) Load PHY Init Engine Image */
+	/*  */
+	/*  Load the PHY Initialization Engine memory with the provided initialization sequence. */
+	/*  See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  */
+	/*  Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+	/*  This allows the memory controller unrestricted access to the configuration CSRs. */
+	dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+	/*  [phyinit_I_loadPIEImage] Programming PIE Production Code */
+	dwc_ddrphy_apb_wr(0x90000, 0x10); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s0 */
+	dwc_ddrphy_apb_wr(0x90001, 0x400); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s1 */
+	dwc_ddrphy_apb_wr(0x90002, 0x10e); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s2 */
+	dwc_ddrphy_apb_wr(0x90003, 0x0); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s0 */
+	dwc_ddrphy_apb_wr(0x90004, 0x0); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s1 */
+	dwc_ddrphy_apb_wr(0x90005, 0x8); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s2 */
+	dwc_ddrphy_apb_wr(0x90029, 0xb); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s0 */
+	dwc_ddrphy_apb_wr(0x9002a, 0x480); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s1 */
+	dwc_ddrphy_apb_wr(0x9002b, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s2 */
+	dwc_ddrphy_apb_wr(0x9002c, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s0 */
+	dwc_ddrphy_apb_wr(0x9002d, 0x448); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s1 */
+	dwc_ddrphy_apb_wr(0x9002e, 0x139); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s2 */
+	dwc_ddrphy_apb_wr(0x9002f, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s0 */
+	dwc_ddrphy_apb_wr(0x90030, 0x478); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s1 */
+	dwc_ddrphy_apb_wr(0x90031, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s2 */
+	dwc_ddrphy_apb_wr(0x90032, 0x2); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s0 */
+	dwc_ddrphy_apb_wr(0x90033, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s1 */
+	dwc_ddrphy_apb_wr(0x90034, 0x139); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s2 */
+	dwc_ddrphy_apb_wr(0x90035, 0xf); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s0 */
+	dwc_ddrphy_apb_wr(0x90036, 0x7c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s1 */
+	dwc_ddrphy_apb_wr(0x90037, 0x139); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s2 */
+	dwc_ddrphy_apb_wr(0x90038, 0x44); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s0 */
+	dwc_ddrphy_apb_wr(0x90039, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s1 */
+	dwc_ddrphy_apb_wr(0x9003a, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s2 */
+	dwc_ddrphy_apb_wr(0x9003b, 0x14f); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s0 */
+	dwc_ddrphy_apb_wr(0x9003c, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s1 */
+	dwc_ddrphy_apb_wr(0x9003d, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s2 */
+	dwc_ddrphy_apb_wr(0x9003e, 0x47); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s0 */
+	dwc_ddrphy_apb_wr(0x9003f, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s1 */
+	dwc_ddrphy_apb_wr(0x90040, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s2 */
+	dwc_ddrphy_apb_wr(0x90041, 0x4f); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s0 */
+	dwc_ddrphy_apb_wr(0x90042, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s1 */
+	dwc_ddrphy_apb_wr(0x90043, 0x179); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s2 */
+	dwc_ddrphy_apb_wr(0x90044, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s0 */
+	dwc_ddrphy_apb_wr(0x90045, 0xe0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s1 */
+	dwc_ddrphy_apb_wr(0x90046, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s2 */
+	dwc_ddrphy_apb_wr(0x90047, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s0 */
+	dwc_ddrphy_apb_wr(0x90048, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s1 */
+	dwc_ddrphy_apb_wr(0x90049, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s2 */
+	dwc_ddrphy_apb_wr(0x9004a, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s0 */
+	dwc_ddrphy_apb_wr(0x9004b, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s1 */
+	dwc_ddrphy_apb_wr(0x9004c, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s2 */
+	dwc_ddrphy_apb_wr(0x9004d, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s0 */
+	dwc_ddrphy_apb_wr(0x9004e, 0x45a); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s1 */
+	dwc_ddrphy_apb_wr(0x9004f, 0x9); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s2 */
+	dwc_ddrphy_apb_wr(0x90050, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s0 */
+	dwc_ddrphy_apb_wr(0x90051, 0x448); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s1 */
+	dwc_ddrphy_apb_wr(0x90052, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s2 */
+	dwc_ddrphy_apb_wr(0x90053, 0x40); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s0 */
+	dwc_ddrphy_apb_wr(0x90054, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s1 */
+	dwc_ddrphy_apb_wr(0x90055, 0x179); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s2 */
+	dwc_ddrphy_apb_wr(0x90056, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s0 */
+	dwc_ddrphy_apb_wr(0x90057, 0x618); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s1 */
+	dwc_ddrphy_apb_wr(0x90058, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s2 */
+	dwc_ddrphy_apb_wr(0x90059, 0x40c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s0 */
+	dwc_ddrphy_apb_wr(0x9005a, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s1 */
+	dwc_ddrphy_apb_wr(0x9005b, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s2 */
+	dwc_ddrphy_apb_wr(0x9005c, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s0 */
+	dwc_ddrphy_apb_wr(0x9005d, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s1 */
+	dwc_ddrphy_apb_wr(0x9005e, 0x48); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s2 */
+	dwc_ddrphy_apb_wr(0x9005f, 0x4040); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s0 */
+	dwc_ddrphy_apb_wr(0x90060, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s1 */
+	dwc_ddrphy_apb_wr(0x90061, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s2 */
+	dwc_ddrphy_apb_wr(0x90062, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s0 */
+	dwc_ddrphy_apb_wr(0x90063, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s1 */
+	dwc_ddrphy_apb_wr(0x90064, 0x48); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s2 */
+	dwc_ddrphy_apb_wr(0x90065, 0x40); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s0 */
+	dwc_ddrphy_apb_wr(0x90066, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s1 */
+	dwc_ddrphy_apb_wr(0x90067, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s2 */
+	dwc_ddrphy_apb_wr(0x90068, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s0 */
+	dwc_ddrphy_apb_wr(0x90069, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s1 */
+	dwc_ddrphy_apb_wr(0x9006a, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s2 */
+	dwc_ddrphy_apb_wr(0x9006b, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s0 */
+	dwc_ddrphy_apb_wr(0x9006c, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s1 */
+	dwc_ddrphy_apb_wr(0x9006d, 0x78); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s2 */
+	dwc_ddrphy_apb_wr(0x9006e, 0x549); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s0 */
+	dwc_ddrphy_apb_wr(0x9006f, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s1 */
+	dwc_ddrphy_apb_wr(0x90070, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s2 */
+	dwc_ddrphy_apb_wr(0x90071, 0xd49); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s0 */
+	dwc_ddrphy_apb_wr(0x90072, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s1 */
+	dwc_ddrphy_apb_wr(0x90073, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s2 */
+	dwc_ddrphy_apb_wr(0x90074, 0x94a); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s0 */
+	dwc_ddrphy_apb_wr(0x90075, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s1 */
+	dwc_ddrphy_apb_wr(0x90076, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s2 */
+	dwc_ddrphy_apb_wr(0x90077, 0x441); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s0 */
+	dwc_ddrphy_apb_wr(0x90078, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s1 */
+	dwc_ddrphy_apb_wr(0x90079, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s2 */
+	dwc_ddrphy_apb_wr(0x9007a, 0x42); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s0 */
+	dwc_ddrphy_apb_wr(0x9007b, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s1 */
+	dwc_ddrphy_apb_wr(0x9007c, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s2 */
+	dwc_ddrphy_apb_wr(0x9007d, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s0 */
+	dwc_ddrphy_apb_wr(0x9007e, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s1 */
+	dwc_ddrphy_apb_wr(0x9007f, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s2 */
+	dwc_ddrphy_apb_wr(0x90080, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s0 */
+	dwc_ddrphy_apb_wr(0x90081, 0xe0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s1 */
+	dwc_ddrphy_apb_wr(0x90082, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s2 */
+	dwc_ddrphy_apb_wr(0x90083, 0xa); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s0 */
+	dwc_ddrphy_apb_wr(0x90084, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s1 */
+	dwc_ddrphy_apb_wr(0x90085, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s2 */
+	dwc_ddrphy_apb_wr(0x90086, 0x9); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s0 */
+	dwc_ddrphy_apb_wr(0x90087, 0x3c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s1 */
+	dwc_ddrphy_apb_wr(0x90088, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s2 */
+	dwc_ddrphy_apb_wr(0x90089, 0x9); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s0 */
+	dwc_ddrphy_apb_wr(0x9008a, 0x3c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s1 */
+	dwc_ddrphy_apb_wr(0x9008b, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s2 */
+	dwc_ddrphy_apb_wr(0x9008c, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s0 */
+	dwc_ddrphy_apb_wr(0x9008d, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s1 */
+	dwc_ddrphy_apb_wr(0x9008e, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s2 */
+	dwc_ddrphy_apb_wr(0x9008f, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s0 */
+	dwc_ddrphy_apb_wr(0x90090, 0x3c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s1 */
+	dwc_ddrphy_apb_wr(0x90091, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s2 */
+	dwc_ddrphy_apb_wr(0x90092, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s0 */
+	dwc_ddrphy_apb_wr(0x90093, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s1 */
+	dwc_ddrphy_apb_wr(0x90094, 0x48); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s2 */
+	dwc_ddrphy_apb_wr(0x90095, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s0 */
+	dwc_ddrphy_apb_wr(0x90096, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s1 */
+	dwc_ddrphy_apb_wr(0x90097, 0x58); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s2 */
+	dwc_ddrphy_apb_wr(0x90098, 0xa); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s0 */
+	dwc_ddrphy_apb_wr(0x90099, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s1 */
+	dwc_ddrphy_apb_wr(0x9009a, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s2 */
+	dwc_ddrphy_apb_wr(0x9009b, 0x2); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s0 */
+	dwc_ddrphy_apb_wr(0x9009c, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s1 */
+	dwc_ddrphy_apb_wr(0x9009d, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s2 */
+	dwc_ddrphy_apb_wr(0x9009e, 0x7); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s0 */
+	dwc_ddrphy_apb_wr(0x9009f, 0x7c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s1 */
+	dwc_ddrphy_apb_wr(0x900a0, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s2 */
+	dwc_ddrphy_apb_wr(0x900a1, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s0 */
+	dwc_ddrphy_apb_wr(0x900a2, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s1 */
+	dwc_ddrphy_apb_wr(0x900a3, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s2 */
+	dwc_ddrphy_apb_wr(0x900a4, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s0 */
+	dwc_ddrphy_apb_wr(0x900a5, 0x8140); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s1 */
+	dwc_ddrphy_apb_wr(0x900a6, 0x10c); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s2 */
+	dwc_ddrphy_apb_wr(0x900a7, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s0 */
+	dwc_ddrphy_apb_wr(0x900a8, 0x8138); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s1 */
+	dwc_ddrphy_apb_wr(0x900a9, 0x10c); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s2 */
+	dwc_ddrphy_apb_wr(0x900aa, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s0 */
+	dwc_ddrphy_apb_wr(0x900ab, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s1 */
+	dwc_ddrphy_apb_wr(0x900ac, 0x101); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s2 */
+	dwc_ddrphy_apb_wr(0x900ad, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s0 */
+	dwc_ddrphy_apb_wr(0x900ae, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s1 */
+	dwc_ddrphy_apb_wr(0x900af, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s2 */
+	dwc_ddrphy_apb_wr(0x900b0, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s0 */
+	dwc_ddrphy_apb_wr(0x900b1, 0x448); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s1 */
+	dwc_ddrphy_apb_wr(0x900b2, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s2 */
+	dwc_ddrphy_apb_wr(0x900b3, 0xf); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s0 */
+	dwc_ddrphy_apb_wr(0x900b4, 0x7c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s1 */
+	dwc_ddrphy_apb_wr(0x900b5, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s2 */
+	dwc_ddrphy_apb_wr(0x900b6, 0x47); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s0 */
+	dwc_ddrphy_apb_wr(0x900b7, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s1 */
+	dwc_ddrphy_apb_wr(0x900b8, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s2 */
+	dwc_ddrphy_apb_wr(0x900b9, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s0 */
+	dwc_ddrphy_apb_wr(0x900ba, 0x618); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s1 */
+	dwc_ddrphy_apb_wr(0x900bb, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s2 */
+	dwc_ddrphy_apb_wr(0x900bc, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s0 */
+	dwc_ddrphy_apb_wr(0x900bd, 0xe0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s1 */
+	dwc_ddrphy_apb_wr(0x900be, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s2 */
+	dwc_ddrphy_apb_wr(0x900bf, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s0 */
+	dwc_ddrphy_apb_wr(0x900c0, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s1 */
+	dwc_ddrphy_apb_wr(0x900c1, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s2 */
+	dwc_ddrphy_apb_wr(0x900c2, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s0 */
+	dwc_ddrphy_apb_wr(0x900c3, 0x8140); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s1 */
+	dwc_ddrphy_apb_wr(0x900c4, 0x10c); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s2 */
+	dwc_ddrphy_apb_wr(0x900c5, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s0 */
+	dwc_ddrphy_apb_wr(0x900c6, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s1 */
+	dwc_ddrphy_apb_wr(0x900c7, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s2 */
+	dwc_ddrphy_apb_wr(0x900c8, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s0 */
+	dwc_ddrphy_apb_wr(0x900c9, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s1 */
+	dwc_ddrphy_apb_wr(0x900ca, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s2 */
+	dwc_ddrphy_apb_wr(0x900cb, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s0 */
+	dwc_ddrphy_apb_wr(0x900cc, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s1 */
+	dwc_ddrphy_apb_wr(0x900cd, 0x101); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s2 */
+	dwc_ddrphy_apb_wr(0x90006, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s0 */
+	dwc_ddrphy_apb_wr(0x90007, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s1 */
+	dwc_ddrphy_apb_wr(0x90008, 0x8); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s2 */
+	dwc_ddrphy_apb_wr(0x90009, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s0 */
+	dwc_ddrphy_apb_wr(0x9000a, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s1 */
+	dwc_ddrphy_apb_wr(0x9000b, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s2 */
+	dwc_ddrphy_apb_wr(0xd00e7, 0x400); /*  DWC_DDRPHYA_APBONLY0_SequencerOverride */
+	dwc_ddrphy_apb_wr(0x90017, 0x0); /*  DWC_DDRPHYA_INITENG0_StartVector0b0 */
+	dwc_ddrphy_apb_wr(0x90026, 0x2c); /*  DWC_DDRPHYA_INITENG0_StartVector0b15 */
+	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY0 to 0x32 */
+	dwc_ddrphy_apb_wr(0x2000b, 0x32); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p0 */
+	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY1 to 0x64 */
+	dwc_ddrphy_apb_wr(0x2000c, 0x64); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p0 */
+	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY2 to 0x3e8 */
+	dwc_ddrphy_apb_wr(0x2000d, 0x3e8); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p0 */
+	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY3 to 0x2c */
+	dwc_ddrphy_apb_wr(0x2000e, 0x2c); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p0 */
+	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY0 to 0x10 */
+	dwc_ddrphy_apb_wr(0x12000b, 0x10); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p1 */
+	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY1 to 0x21 */
+	dwc_ddrphy_apb_wr(0x12000c, 0x21); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p1 */
+	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY2 to 0x14c */
+	dwc_ddrphy_apb_wr(0x12000d, 0x14c); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p1 */
+	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY3 to 0x10 */
+	dwc_ddrphy_apb_wr(0x12000e, 0x10); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p1 */
+	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY0 to 0xa */
+	dwc_ddrphy_apb_wr(0x22000b, 0xa); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p2 */
+	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY1 to 0x14 */
+	dwc_ddrphy_apb_wr(0x22000c, 0x14); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p2 */
+	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY2 to 0xcf */
+	dwc_ddrphy_apb_wr(0x22000d, 0xcf); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p2 */
+	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY3 to 0x10 */
+	dwc_ddrphy_apb_wr(0x22000e, 0x10); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p2 */
+	dwc_ddrphy_apb_wr(0x9000c, 0x0); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag0 */
+	dwc_ddrphy_apb_wr(0x9000d, 0x173); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag1 */
+	dwc_ddrphy_apb_wr(0x9000e, 0x60); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag2 */
+	dwc_ddrphy_apb_wr(0x9000f, 0x6110); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag3 */
+	dwc_ddrphy_apb_wr(0x90010, 0x2152); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag4 */
+	dwc_ddrphy_apb_wr(0x90011, 0xdfbd); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag5 */
+	dwc_ddrphy_apb_wr(0x90012, 0xffff); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag6 */
+	dwc_ddrphy_apb_wr(0x90013, 0x6152); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag7 */
+	/*  Disabling Ucclk (PMU) and Hclk (training hardware) */
+	dwc_ddrphy_apb_wr(0xc0080, 0x0); /*  DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
+	/*  Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+	dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+	/*  [phyinit_I_loadPIEImage] End of dwc_ddrphy_phyinit_I_loadPIEImage() */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  dwc_ddrphy_phyinit_userCustom_customPostTrain is a user-editable function. */
+	/*  */
+	/*  See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	dwc_ddrphy_phyinit_userCustom_customPostTrain ();
+
+	/*  [dwc_ddrphy_phyinit_userCustom_customPostTrain] End of dwc_ddrphy_phyinit_userCustom_customPostTrain() */
+	/*  [dwc_ddrphy_phyinit_userCustom_J_enterMissionMode] Start of dwc_ddrphy_phyinit_userCustom_J_enterMissionMode() */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  (J) Initialize the PHY to Mission Mode through DFI Initialization */
+	/*  */
+	/*  Initialize the PHY to mission mode as follows: */
+	/*  */
+	/*  1. Set the PHY input clocks to the desired frequency. */
+	/*  2. Initialize the PHY to mission mode by performing DFI Initialization. */
+	/*     Please see the DFI specification for more information. See the DFI frequency bus encoding in section <XXX>. */
+	/*  Note: The PHY training firmware initializes the DRAM state. if skip */
+	/*  training is used, the DRAM state is not initialized. */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	dwc_ddrphy_phyinit_userCustom_J_enterMissionMode ();
+
+	/*  */
+	/*  [dwc_ddrphy_phyinit_userCustom_J_enterMissionMode] End of dwc_ddrphy_phyinit_userCustom_J_enterMissionMode() */
+	/*  [dwc_ddrphy_phyinit_sequence] End of dwc_ddrphy_phyinit_sequence() */
+	/*  [dwc_ddrphy_phyinit_main] End of dwc_ddrphy_phyinit_main() */
+
+	/* ---------------------------------------------------------------------- */
+	/*   save 1d2d training CSR */
+	/* ---------------------------------------------------------------------- */
+	if (!after_retention) {
+		save_1d2d_trained_csr_ddr3_p012(SAVE_DDRPHY_TRAIN_ADDR);
+	}
+}
diff --git a/board/karo/tx8m/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c b/board/karo/tx8m/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c
new file mode 100644
index 0000000..e3875f5
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c
@@ -0,0 +1,277 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "anamix_common.h"
+#include "ddr3_define.h"
+
+void umctl2_cfg(void)
+{
+#ifdef DDR_ONE_RANK
+	reg32_write(DDRC_MSTR(0), 0x81040001);
+#else
+	reg32_write(DDRC_MSTR(0), 0x83040001);
+#endif
+
+	reg32_write(DDRC_PWRCTL(0), 0x000000a8);
+	reg32_write(DDRC_PWRTMG(0), 0x00532203);
+
+	reg32_write(DDRC_RFSHCTL0(0), 0x00203020);
+	reg32_write(DDRC_RFSHCTL1(0), 0x0001000d);
+	reg32_write(DDRC_RFSHCTL3(0), 0x00000000);
+	reg32_write(DDRC_RFSHTMG(0), 0x0061008c);
+	reg32_write(DDRC_CRCPARCTL0(0), 0x00000000);
+	reg32_write(DDRC_CRCPARCTL1(0), 0x00000000);
+	reg32_write(DDRC_INIT0(0), 0xc0030002);
+	reg32_write(DDRC_INIT1(0), 0x0001000b);
+	reg32_write(DDRC_INIT2(0), 0x00006303);
+	reg32_write(DDRC_INIT3(0), 0x0d700004);/* MR1, MR0 */
+	reg32_write(DDRC_INIT4(0), 0x00180000);/* MR2 */
+	reg32_write(DDRC_INIT5(0), 0x00090071);
+	reg32_write(DDRC_INIT6(0), 0x00000000);
+	reg32_write(DDRC_INIT7(0), 0x00000000);
+	reg32_write(DDRC_DIMMCTL(0), 0x00000032); /* [1] dimm_addr_mirr_en, it will effect the MRS if use umctl2 to initi dram. */
+	reg32_write(DDRC_RANKCTL(0), 0x00000ee5);
+	reg32_write(DDRC_DRAMTMG0(0), 0x0c101a0e);
+	reg32_write(DDRC_DRAMTMG1(0), 0x000a0314);
+	reg32_write(DDRC_DRAMTMG2(0), 0x04060509);
+	reg32_write(DDRC_DRAMTMG3(0), 0x00002006);
+	reg32_write(DDRC_DRAMTMG4(0), 0x06020306);
+	reg32_write(DDRC_DRAMTMG5(0), 0x0b060202);
+	reg32_write(DDRC_DRAMTMG6(0), 0x060a0009);
+	reg32_write(DDRC_DRAMTMG7(0), 0x0000060b);
+	reg32_write(DDRC_DRAMTMG8(0), 0x01017c0a);
+	reg32_write(DDRC_DRAMTMG9(0), 0x4000000e);
+	reg32_write(DDRC_DRAMTMG10(0), 0x00070803);
+	reg32_write(DDRC_DRAMTMG11(0), 0x0101000b);
+	reg32_write(DDRC_DRAMTMG12(0), 0x00000000);
+	reg32_write(DDRC_DRAMTMG13(0), 0x5d000000);
+	reg32_write(DDRC_DRAMTMG14(0), 0x00000b39);
+	reg32_write(DDRC_DRAMTMG15(0), 0x80000000);
+	reg32_write(DDRC_DRAMTMG17(0), 0x00f1006a);
+	reg32_write(DDRC_ZQCTL0(0), 0x50800020);
+	reg32_write(DDRC_ZQCTL1(0), 0x00000070);
+	reg32_write(DDRC_ZQCTL2(0), 0x00000000);
+	reg32_write(DDRC_DFITMG0(0), 0x03868203);
+	reg32_write(DDRC_DFITMG1(0), 0x00020103);
+	reg32_write(DDRC_DFILPCFG0(0), 0x07713021);
+	reg32_write(DDRC_DFILPCFG1(0), 0x00000010);
+	reg32_write(DDRC_DFIUPD0(0), 0xe0400018);
+	reg32_write(DDRC_DFIUPD1(0), 0x0005003c);
+	reg32_write(DDRC_DFIUPD2(0), 0x80000000);
+	reg32_write(DDRC_DFIMISC(0), 0x00000011);
+	reg32_write(DDRC_DFITMG2(0), 0x00000603);
+	reg32_write(DDRC_DFITMG3(0), 0x00000001);
+	reg32_write(DDRC_DBICTL(0), 0x00000001);
+	reg32_write(DDRC_DFIPHYMSTR(0), 0x00000000);
+
+	/*  My test mapping in this test case, for 8Gb,(two 4Gb, x16 DDR3) (col addr:10 bits  row addr: 15 bits  bank addr: 3bits  2 ranks) */
+	/*  MEMC_BURST_LENGTH = 8 */
+	/* ----------------------------------------------------------------------------------------------------------------------------------- */
+	/*  AXI add: 31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13   12  11  10  9   8   7   6   5   4   3   2   1   0 (MEM_DATWIDTH=64) */
+	/*  AXI add: 30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12   11  10  9   8   7   6   5   4   3   2   1   0     (MEM_DATWIDTH=32) *** */
+	/*  AXI add: 29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11   10  9   8   7   6   5   4   3   2   1   0         (MEM_DATWIDTH=16) */
+	/* ----------------------------------------------------------------------------------------------------------------------------------- */
+	/*  HIF add: 28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0   -   -   - */
+	/* ----------------------------------------------------------------------------------------------------------------------------------- */
+	/*  **** for Full DQ bus width (X32) **** */
+	/*           cs  r14 r13 r12 r11 r10 r9  r8  r7  r6  r5  r4  r3  r2  r1  r0  b2  b1  b0  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 */
+	/* Int base  6   20  19  18  17  16  15  14  13  12  11  10  9   8   7   6   4   3   2    9   8  7   6   5    4   3   2   - */
+	/* p Value   22  7   7   7   7   7   7   7   7   7    7   7  7   7   7   7   8   8   8    0   0  0   0   0    0   0   0   - */
+	/* ----------------------------------------------------------------------------------------------------------------------------------- */
+
+	reg32_write(DDRC_ADDRMAP0(0), 0x00000016); /* [4:0] cs-bit0: 6+22=28; [12:8] cs-bit1: 7+0 */
+	reg32_write(DDRC_ADDRMAP1(0), 0x00080808); /* [5:0] bank b0: 2+8; [13:8] b1: P3+8 ; [21:16] b2: 4+8 */
+	reg32_write(DDRC_ADDRMAP2(0), 0x00000000); /* [3:0] col-b2: 2;  [11:8] col-b3: 3; [19:16] col-b4: 4 ; [27:24] col-b5: 5 */
+	reg32_write(DDRC_ADDRMAP3(0), 0x00000000); /* [3:0] col-b6: 6;  [11:8] col-b7: 7; [19:16] col-b8: 8 ; [27:24] col-b9: 9 */
+	reg32_write(DDRC_ADDRMAP4(0), 0x00001f1f); /* col-b10, col-b11 not used */
+	reg32_write(DDRC_ADDRMAP5(0), 0x07070707); /* [3:0] row-b0: 6;  [11:8] row-b1: 7; [19:16] row-b2_b10 ; [27:24] row-b11: 17 */
+	reg32_write(DDRC_ADDRMAP6(0), 0x0f070707); /* [3:0] row-b12:18; [11:8] row-b13: 19; [19:16] row-b14:20 */
+	reg32_write(DDRC_ADDRMAP7(0), 0x00000f0f);
+	reg32_write(DDRC_ADDRMAP8(0), 0x00000000); /* [5:0] bg-b0; [13:8]bg-b1 */
+	reg32_write(DDRC_ADDRMAP9(0), 0x0a020b06); /*  it's valid only when ADDRMAP5.addrmap_row_b2_10 is set to value 15 */
+	reg32_write(DDRC_ADDRMAP10(0), 0x0a0a0a0a);/*  it's valid only when ADDRMAP5.addrmap_row_b2_10 is set to value 15 */
+	reg32_write(DDRC_ADDRMAP11(0), 0x00000000);
+
+
+	reg32_write(DDRC_ODTCFG(0), 0x041d0f5c);
+	reg32_write(DDRC_ODTMAP(0), 0x00000201);
+	reg32_write(DDRC_SCHED(0), 0x7ab50b07);
+	reg32_write(DDRC_SCHED1(0), 0x00000022);
+	reg32_write(DDRC_PERFHPR1(0), 0x7b00665e);
+	reg32_write(DDRC_PERFLPR1(0), 0x2b00c4e1);
+	reg32_write(DDRC_PERFWR1(0), 0xb700c9fe);
+	reg32_write(DDRC_DBG0(0), 0x00000017);
+	reg32_write(DDRC_DBG1(0), 0x00000000);
+	reg32_write(DDRC_DBGCMD(0), 0x00000000);
+	reg32_write(DDRC_SWCTL(0), 0x00000001);
+	reg32_write(DDRC_POISONCFG(0), 0x00010000);
+	reg32_write(DDRC_PCCFG(0), 0x00000100);
+	reg32_write(DDRC_PCFGR_0(0), 0x00003051);
+	reg32_write(DDRC_PCFGW_0(0), 0x000061d2);
+	reg32_write(DDRC_PCTRL_0(0), 0x00000001);
+	reg32_write(DDRC_PCFGQOS0_0(0), 0x02100b04);
+	reg32_write(DDRC_PCFGQOS1_0(0), 0x003f0353);
+	reg32_write(DDRC_PCFGWQOS0_0(0), 0x00000002);
+	reg32_write(DDRC_PCFGWQOS1_0(0), 0x000005fd);
+}
+
+void umctl2_freq1_cfg(void)
+{
+	reg32_write(DDRC_FREQ1_RFSHCTL0(0), 0x00d19034);
+	reg32_write(DDRC_FREQ1_RFSHTMG(0), 0x0040805e);
+	reg32_write(DDRC_FREQ1_INIT3(0), 0x09300004);
+	reg32_write(DDRC_FREQ1_INIT4(0), 0x00080000);
+	reg32_write(DDRC_FREQ1_INIT6(0), 0x00000000);
+	reg32_write(DDRC_FREQ1_INIT7(0), 0x00000000);
+	reg32_write(DDRC_FREQ1_DRAMTMG0(0), 0x090e110a);
+	reg32_write(DDRC_FREQ1_DRAMTMG1(0), 0x0007020e);
+	reg32_write(DDRC_FREQ1_DRAMTMG2(0), 0x03040407);
+	reg32_write(DDRC_FREQ1_DRAMTMG3(0), 0x00002006);
+	reg32_write(DDRC_FREQ1_DRAMTMG4(0), 0x04020304); /*  tRP=6 --> 7 */
+	reg32_write(DDRC_FREQ1_DRAMTMG5(0), 0x09030202);
+	reg32_write(DDRC_FREQ1_DRAMTMG6(0), 0x0c020000);
+	reg32_write(DDRC_FREQ1_DRAMTMG7(0), 0x00000309);
+	reg32_write(DDRC_FREQ1_DRAMTMG8(0), 0x01010a06);
+	reg32_write(DDRC_FREQ1_DRAMTMG9(0), 0x00000003);
+	reg32_write(DDRC_FREQ1_DRAMTMG10(0), 0x00090906);
+	reg32_write(DDRC_FREQ1_DRAMTMG11(0), 0x01010011);
+	reg32_write(DDRC_FREQ1_DRAMTMG12(0), 0x00000000);
+	reg32_write(DDRC_FREQ1_DRAMTMG13(0), 0x40000000);
+	reg32_write(DDRC_FREQ1_DRAMTMG14(0), 0x000000f3);
+	reg32_write(DDRC_FREQ1_DRAMTMG15(0), 0x80000000);
+	reg32_write(DDRC_FREQ1_DRAMTMG17(0), 0x001a0046);
+	reg32_write(DDRC_FREQ1_ZQCTL0(0),  0x50800020);
+	reg32_write(DDRC_FREQ1_DFITMG0(0), 0x03828201);
+	reg32_write(DDRC_FREQ1_DFITMG1(0), 0x00020103);
+	reg32_write(DDRC_FREQ1_DFITMG2(0), 0x00000201);
+	reg32_write(DDRC_FREQ1_DFITMG3(0), 0x00000001);
+	reg32_write(DDRC_FREQ1_ODTCFG(0),  0x0a1a0768);
+
+}
+
+void umctl2_freq2_cfg(void)
+{
+	reg32_write(DDRC_FREQ2_RFSHCTL0(0), 0x00208014);
+	reg32_write(DDRC_FREQ2_RFSHTMG(0), 0x00308046);
+	reg32_write(DDRC_FREQ2_INIT3(0), 0x05200004);
+	reg32_write(DDRC_FREQ2_INIT4(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_INIT6(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_INIT7(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_DRAMTMG0(0), 0x070a0c07);
+	reg32_write(DDRC_FREQ2_DRAMTMG1(0), 0x0005020b);
+	reg32_write(DDRC_FREQ2_DRAMTMG2(0), 0x03030407);
+	reg32_write(DDRC_FREQ2_DRAMTMG3(0), 0x00002006);
+	reg32_write(DDRC_FREQ2_DRAMTMG4(0), 0x03020204);
+	reg32_write(DDRC_FREQ2_DRAMTMG5(0), 0x04070302);
+	reg32_write(DDRC_FREQ2_DRAMTMG6(0), 0x07080000);
+	reg32_write(DDRC_FREQ2_DRAMTMG7(0), 0x00000704);
+	reg32_write(DDRC_FREQ2_DRAMTMG8(0), 0x02026804);
+	reg32_write(DDRC_FREQ2_DRAMTMG9(0), 0x40000006);
+	reg32_write(DDRC_FREQ2_DRAMTMG10(0), 0x000c0b08);
+	reg32_write(DDRC_FREQ2_DRAMTMG11(0), 0x01010015);
+	reg32_write(DDRC_FREQ2_DRAMTMG12(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_DRAMTMG13(0), 0x51000000);
+	reg32_write(DDRC_FREQ2_DRAMTMG14(0), 0x000002a0);
+	reg32_write(DDRC_FREQ2_DRAMTMG15(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_DRAMTMG17(0), 0x008c0039);
+	reg32_write(DDRC_FREQ2_ZQCTL0(0), 0x50800020);
+	reg32_write(DDRC_FREQ2_DFITMG0(0), 0x03818200);
+	reg32_write(DDRC_FREQ2_DFITMG1(0), 0x00020103);
+	reg32_write(DDRC_FREQ2_DFITMG2(0), 0x00000100);
+	reg32_write(DDRC_FREQ2_DFITMG3(0), 0x00000001);
+	reg32_write(DDRC_FREQ2_ODTCFG(0), 0x04050800);
+
+}
+
+void ddr3_pub_train(void)
+{
+	volatile unsigned int tmp_t;
+
+	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F00003F); /*  assert [0]ddr1_preset_n, [1]ddr1_core_reset_n, [2]ddr1_phy_reset, [3]ddr1_phy_pwrokin_n, [4]src_system_rst_b! */
+	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F00000F); /*  deassert [4]src_system_rst_b! */
+
+	/* change the clock source of dram_apb_clk_root */
+	clock_set_target_val(DRAM_APB_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(4) | CLK_ROOT_PRE_DIV(CLK_ROOT_PRE_DIV4)); /* to source 4 --800MHz/4 */
+
+	dram_pll_init(DRAM_PLL_OUT_400M);
+	ddr_dbg("C: dram pll init finished\n");
+
+	reg32_write(0x303A00EC, 0x0000ffff); /* PGC_CPU_MAPPING */
+	reg32setbit(0x303A00F8, 5);/* PU_PGC_SW_PUP_REQ */
+
+	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F000006); /*  release [0]ddr1_preset_n, [3]ddr1_phy_pwrokin_n */
+
+	reg32_write(DDRC_DBG1(0), 0x00000001);
+	reg32_write(DDRC_PWRCTL(0), 0x00000001);
+
+	while (0 != (0x3 & reg32_read(DDRC_STAT(0))))
+		;
+
+	ddr_dbg("C: cfg umctl2 regs ...\n");
+	umctl2_cfg();
+#ifdef DDR3_SW_FFC
+	umctl2_freq1_cfg();
+	umctl2_freq2_cfg();
+#endif
+
+	reg32_write(DDRC_RFSHCTL3(0), 0x00000011);
+	/* RESET: <ctn> DEASSERTED */
+	/* RESET: <a Port 0  DEASSERTED(0) */
+	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F000000); /*  release all reset */
+
+	reg32_write(DDRC_DBG1(0), 0x00000000);
+	reg32_write(DDRC_PWRCTL(0), 0x00000a8);
+	reg32_write(DDRC_SWCTL(0), 0x00000000);
+
+	reg32_write(DDRC_DFIMISC(0), 0x00000000);
+
+	ddr_dbg("C: phy training ...\n");
+	ddr3_phyinit_train_sw_ffc(0);
+
+	do {
+		tmp_t = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x00020097);
+		ddr_dbg("C: Waiting CalBusy value = 0\n");
+	} while (tmp_t != 0);
+
+	reg32_write(DDRC_DFIMISC(0), 0x00000020);
+
+	/*  wait DFISTAT.dfi_init_complete to 1 */
+	while (0 == (0x1 & reg32_read(DDRC_DFISTAT(0))))
+		;
+
+	/*  clear DFIMISC.dfi_init_complete_en */
+	reg32_write(DDRC_DFIMISC(0), 0x00000000);
+	/*  set DFIMISC.dfi_init_complete_en again */
+	reg32_write(DDRC_DFIMISC(0), 0x00000001);
+	reg32_write(DDRC_PWRCTL(0), 0x0000088);
+
+	/*  set SWCTL.sw_done to enable quasi-dynamic register programming outside reset. */
+	reg32_write(DDRC_SWCTL(0), 0x00000001);
+	/* wait SWSTAT.sw_done_ack to 1 */
+	while (0 == (0x1 & reg32_read(DDRC_SWSTAT(0))))
+		;
+
+	/* wait STAT to normal state */
+	while (0x1 != (0x3 & reg32_read(DDRC_STAT(0))))
+		;
+
+	reg32_write(DDRC_PWRCTL(0), 0x0000088);
+
+	reg32_write(DDRC_PCTRL_0(0), 0x00000001);
+	reg32_write(DDRC_RFSHCTL3(0), 0x00000010); /*  dis_auto-refresh is set to 0 */
+
+ }
+
+void ddr_init(void)
+{
+	/* initialize DDR4-2400 (umctl2@800MHz) */
+	ddr3_pub_train();
+}
diff --git a/board/karo/tx8m/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c b/board/karo/tx8m/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c
new file mode 100644
index 0000000..f01ed9f
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c
@@ -0,0 +1,969 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "../ddr.h"
+#include "ddr3_define.h"
+
+static const unsigned int restore_csr[] = {
+	0x200b2,
+	0x1200b2,
+	0x2200b2,
+	0x200cb,
+#ifdef RUN_ON_SILICON
+	0x10043,
+	0x110043,
+	0x210043,
+	0x10143,
+	0x110143,
+	0x210143,
+	0x11043,
+	0x111043,
+	0x211043,
+	0x11143,
+	0x111143,
+	0x211143,
+	0x12043,
+	0x112043,
+	0x212043,
+	0x12143,
+	0x112143,
+	0x212143,
+	0x13043,
+	0x113043,
+	0x213043,
+	0x13143,
+	0x113143,
+	0x213143,
+	0x80,
+	0x100080,
+	0x200080,
+	0x1080,
+	0x101080,
+	0x201080,
+	0x2080,
+	0x102080,
+	0x202080,
+	0x3080,
+	0x103080,
+	0x203080,
+	0x4080,
+	0x104080,
+	0x204080,
+	0x5080,
+	0x105080,
+	0x205080,
+	0x6080,
+	0x106080,
+	0x206080,
+	0x7080,
+	0x107080,
+	0x207080,
+	0x8080,
+	0x108080,
+	0x208080,
+	0x9080,
+	0x109080,
+	0x209080,
+	0x10080,
+	0x110080,
+	0x210080,
+	0x10180,
+	0x110180,
+	0x210180,
+	0x10081,
+	0x110081,
+	0x210081,
+	0x10181,
+	0x110181,
+	0x210181,
+	0x10082,
+	0x110082,
+	0x210082,
+	0x10182,
+	0x110182,
+	0x210182,
+	0x10083,
+	0x110083,
+	0x210083,
+	0x10183,
+	0x110183,
+	0x210183,
+	0x11080,
+	0x111080,
+	0x211080,
+	0x11180,
+	0x111180,
+	0x211180,
+	0x11081,
+	0x111081,
+	0x211081,
+	0x11181,
+	0x111181,
+	0x211181,
+	0x11082,
+	0x111082,
+	0x211082,
+	0x11182,
+	0x111182,
+	0x211182,
+	0x11083,
+	0x111083,
+	0x211083,
+	0x11183,
+	0x111183,
+	0x211183,
+	0x12080,
+	0x112080,
+	0x212080,
+	0x12180,
+	0x112180,
+	0x212180,
+	0x12081,
+	0x112081,
+	0x212081,
+	0x12181,
+	0x112181,
+	0x212181,
+	0x12082,
+	0x112082,
+	0x212082,
+	0x12182,
+	0x112182,
+	0x212182,
+	0x12083,
+	0x112083,
+	0x212083,
+	0x12183,
+	0x112183,
+	0x212183,
+	0x13080,
+	0x113080,
+	0x213080,
+	0x13180,
+	0x113180,
+	0x213180,
+	0x13081,
+	0x113081,
+	0x213081,
+	0x13181,
+	0x113181,
+	0x213181,
+	0x13082,
+	0x113082,
+	0x213082,
+	0x13182,
+	0x113182,
+	0x213182,
+	0x13083,
+	0x113083,
+	0x213083,
+	0x13183,
+	0x113183,
+	0x213183,
+	0x100d0,
+	0x1100d0,
+	0x2100d0,
+	0x101d0,
+	0x1101d0,
+	0x2101d0,
+	0x100d1,
+	0x1100d1,
+	0x2100d1,
+	0x101d1,
+	0x1101d1,
+	0x2101d1,
+	0x100d2,
+	0x1100d2,
+	0x2100d2,
+	0x101d2,
+	0x1101d2,
+	0x2101d2,
+	0x100d3,
+	0x1100d3,
+	0x2100d3,
+	0x101d3,
+	0x1101d3,
+	0x2101d3,
+	0x110d0,
+	0x1110d0,
+	0x2110d0,
+	0x111d0,
+	0x1111d0,
+	0x2111d0,
+	0x110d1,
+	0x1110d1,
+	0x2110d1,
+	0x111d1,
+	0x1111d1,
+	0x2111d1,
+	0x110d2,
+	0x1110d2,
+	0x2110d2,
+	0x111d2,
+	0x1111d2,
+	0x2111d2,
+	0x110d3,
+	0x1110d3,
+	0x2110d3,
+	0x111d3,
+	0x1111d3,
+	0x2111d3,
+	0x120d0,
+	0x1120d0,
+	0x2120d0,
+	0x121d0,
+	0x1121d0,
+	0x2121d0,
+	0x120d1,
+	0x1120d1,
+	0x2120d1,
+	0x121d1,
+	0x1121d1,
+	0x2121d1,
+	0x120d2,
+	0x1120d2,
+	0x2120d2,
+	0x121d2,
+	0x1121d2,
+	0x2121d2,
+	0x120d3,
+	0x1120d3,
+	0x2120d3,
+	0x121d3,
+	0x1121d3,
+	0x2121d3,
+	0x130d0,
+	0x1130d0,
+	0x2130d0,
+	0x131d0,
+	0x1131d0,
+	0x2131d0,
+	0x130d1,
+	0x1130d1,
+	0x2130d1,
+	0x131d1,
+	0x1131d1,
+	0x2131d1,
+	0x130d2,
+	0x1130d2,
+	0x2130d2,
+	0x131d2,
+	0x1131d2,
+	0x2131d2,
+	0x130d3,
+	0x1130d3,
+	0x2130d3,
+	0x131d3,
+	0x1131d3,
+	0x2131d3,
+	0x10068,
+	0x10168,
+	0x10268,
+	0x10368,
+	0x10468,
+	0x10568,
+	0x10668,
+	0x10768,
+	0x10868,
+	0x10069,
+	0x10169,
+	0x10269,
+	0x10369,
+	0x10469,
+	0x10569,
+	0x10669,
+	0x10769,
+	0x10869,
+	0x1006a,
+	0x1016a,
+	0x1026a,
+	0x1036a,
+	0x1046a,
+	0x1056a,
+	0x1066a,
+	0x1076a,
+	0x1086a,
+	0x1006b,
+	0x1016b,
+	0x1026b,
+	0x1036b,
+	0x1046b,
+	0x1056b,
+	0x1066b,
+	0x1076b,
+	0x1086b,
+	0x11068,
+	0x11168,
+	0x11268,
+	0x11368,
+	0x11468,
+	0x11568,
+	0x11668,
+	0x11768,
+	0x11868,
+	0x11069,
+	0x11169,
+	0x11269,
+	0x11369,
+	0x11469,
+	0x11569,
+	0x11669,
+	0x11769,
+	0x11869,
+	0x1106a,
+	0x1116a,
+	0x1126a,
+	0x1136a,
+	0x1146a,
+	0x1156a,
+	0x1166a,
+	0x1176a,
+	0x1186a,
+	0x1106b,
+	0x1116b,
+	0x1126b,
+	0x1136b,
+	0x1146b,
+	0x1156b,
+	0x1166b,
+	0x1176b,
+	0x1186b,
+	0x12068,
+	0x12168,
+	0x12268,
+	0x12368,
+	0x12468,
+	0x12568,
+	0x12668,
+	0x12768,
+	0x12868,
+	0x12069,
+	0x12169,
+	0x12269,
+	0x12369,
+	0x12469,
+	0x12569,
+	0x12669,
+	0x12769,
+	0x12869,
+	0x1206a,
+	0x1216a,
+	0x1226a,
+	0x1236a,
+	0x1246a,
+	0x1256a,
+	0x1266a,
+	0x1276a,
+	0x1286a,
+	0x1206b,
+	0x1216b,
+	0x1226b,
+	0x1236b,
+	0x1246b,
+	0x1256b,
+	0x1266b,
+	0x1276b,
+	0x1286b,
+	0x13068,
+	0x13168,
+	0x13268,
+	0x13368,
+	0x13468,
+	0x13568,
+	0x13668,
+	0x13768,
+	0x13868,
+	0x13069,
+	0x13169,
+	0x13269,
+	0x13369,
+	0x13469,
+	0x13569,
+	0x13669,
+	0x13769,
+	0x13869,
+	0x1306a,
+	0x1316a,
+	0x1326a,
+	0x1336a,
+	0x1346a,
+	0x1356a,
+	0x1366a,
+	0x1376a,
+	0x1386a,
+	0x1306b,
+	0x1316b,
+	0x1326b,
+	0x1336b,
+	0x1346b,
+	0x1356b,
+	0x1366b,
+	0x1376b,
+	0x1386b,
+	0x1008c,
+	0x11008c,
+	0x21008c,
+	0x1018c,
+	0x11018c,
+	0x21018c,
+	0x1008d,
+	0x11008d,
+	0x21008d,
+	0x1018d,
+	0x11018d,
+	0x21018d,
+	0x1008e,
+	0x11008e,
+	0x21008e,
+	0x1018e,
+	0x11018e,
+	0x21018e,
+	0x1008f,
+	0x11008f,
+	0x21008f,
+	0x1018f,
+	0x11018f,
+	0x21018f,
+	0x1108c,
+	0x11108c,
+	0x21108c,
+	0x1118c,
+	0x11118c,
+	0x21118c,
+	0x1108d,
+	0x11108d,
+	0x21108d,
+	0x1118d,
+	0x11118d,
+	0x21118d,
+	0x1108e,
+	0x11108e,
+	0x21108e,
+	0x1118e,
+	0x11118e,
+	0x21118e,
+	0x1108f,
+	0x11108f,
+	0x21108f,
+	0x1118f,
+	0x11118f,
+	0x21118f,
+	0x1208c,
+	0x11208c,
+	0x21208c,
+	0x1218c,
+	0x11218c,
+	0x21218c,
+	0x1208d,
+	0x11208d,
+	0x21208d,
+	0x1218d,
+	0x11218d,
+	0x21218d,
+	0x1208e,
+	0x11208e,
+	0x21208e,
+	0x1218e,
+	0x11218e,
+	0x21218e,
+	0x1208f,
+	0x11208f,
+	0x21208f,
+	0x1218f,
+	0x11218f,
+	0x21218f,
+	0x1308c,
+	0x11308c,
+	0x21308c,
+	0x1318c,
+	0x11318c,
+	0x21318c,
+	0x1308d,
+	0x11308d,
+	0x21308d,
+	0x1318d,
+	0x11318d,
+	0x21318d,
+	0x1308e,
+	0x11308e,
+	0x21308e,
+	0x1318e,
+	0x11318e,
+	0x21318e,
+	0x1308f,
+	0x11308f,
+	0x21308f,
+	0x1318f,
+	0x11318f,
+	0x21318f,
+	0x100c0,
+	0x1100c0,
+	0x2100c0,
+	0x101c0,
+	0x1101c0,
+	0x2101c0,
+	0x102c0,
+	0x1102c0,
+	0x2102c0,
+	0x103c0,
+	0x1103c0,
+	0x2103c0,
+	0x104c0,
+	0x1104c0,
+	0x2104c0,
+	0x105c0,
+	0x1105c0,
+	0x2105c0,
+	0x106c0,
+	0x1106c0,
+	0x2106c0,
+	0x107c0,
+	0x1107c0,
+	0x2107c0,
+	0x108c0,
+	0x1108c0,
+	0x2108c0,
+	0x100c1,
+	0x1100c1,
+	0x2100c1,
+	0x101c1,
+	0x1101c1,
+	0x2101c1,
+	0x102c1,
+	0x1102c1,
+	0x2102c1,
+	0x103c1,
+	0x1103c1,
+	0x2103c1,
+	0x104c1,
+	0x1104c1,
+	0x2104c1,
+	0x105c1,
+	0x1105c1,
+	0x2105c1,
+	0x106c1,
+	0x1106c1,
+	0x2106c1,
+	0x107c1,
+	0x1107c1,
+	0x2107c1,
+	0x108c1,
+	0x1108c1,
+	0x2108c1,
+	0x100c2,
+	0x1100c2,
+	0x2100c2,
+	0x101c2,
+	0x1101c2,
+	0x2101c2,
+	0x102c2,
+	0x1102c2,
+	0x2102c2,
+	0x103c2,
+	0x1103c2,
+	0x2103c2,
+	0x104c2,
+	0x1104c2,
+	0x2104c2,
+	0x105c2,
+	0x1105c2,
+	0x2105c2,
+	0x106c2,
+	0x1106c2,
+	0x2106c2,
+	0x107c2,
+	0x1107c2,
+	0x2107c2,
+	0x108c2,
+	0x1108c2,
+	0x2108c2,
+	0x100c3,
+	0x1100c3,
+	0x2100c3,
+	0x101c3,
+	0x1101c3,
+	0x2101c3,
+	0x102c3,
+	0x1102c3,
+	0x2102c3,
+	0x103c3,
+	0x1103c3,
+	0x2103c3,
+	0x104c3,
+	0x1104c3,
+	0x2104c3,
+	0x105c3,
+	0x1105c3,
+	0x2105c3,
+	0x106c3,
+	0x1106c3,
+	0x2106c3,
+	0x107c3,
+	0x1107c3,
+	0x2107c3,
+	0x108c3,
+	0x1108c3,
+	0x2108c3,
+	0x110c0,
+	0x1110c0,
+	0x2110c0,
+	0x111c0,
+	0x1111c0,
+	0x2111c0,
+	0x112c0,
+	0x1112c0,
+	0x2112c0,
+	0x113c0,
+	0x1113c0,
+	0x2113c0,
+	0x114c0,
+	0x1114c0,
+	0x2114c0,
+	0x115c0,
+	0x1115c0,
+	0x2115c0,
+	0x116c0,
+	0x1116c0,
+	0x2116c0,
+	0x117c0,
+	0x1117c0,
+	0x2117c0,
+	0x118c0,
+	0x1118c0,
+	0x2118c0,
+	0x110c1,
+	0x1110c1,
+	0x2110c1,
+	0x111c1,
+	0x1111c1,
+	0x2111c1,
+	0x112c1,
+	0x1112c1,
+	0x2112c1,
+	0x113c1,
+	0x1113c1,
+	0x2113c1,
+	0x114c1,
+	0x1114c1,
+	0x2114c1,
+	0x115c1,
+	0x1115c1,
+	0x2115c1,
+	0x116c1,
+	0x1116c1,
+	0x2116c1,
+	0x117c1,
+	0x1117c1,
+	0x2117c1,
+	0x118c1,
+	0x1118c1,
+	0x2118c1,
+	0x110c2,
+	0x1110c2,
+	0x2110c2,
+	0x111c2,
+	0x1111c2,
+	0x2111c2,
+	0x112c2,
+	0x1112c2,
+	0x2112c2,
+	0x113c2,
+	0x1113c2,
+	0x2113c2,
+	0x114c2,
+	0x1114c2,
+	0x2114c2,
+	0x115c2,
+	0x1115c2,
+	0x2115c2,
+	0x116c2,
+	0x1116c2,
+	0x2116c2,
+	0x117c2,
+	0x1117c2,
+	0x2117c2,
+	0x118c2,
+	0x1118c2,
+	0x2118c2,
+	0x110c3,
+	0x1110c3,
+	0x2110c3,
+	0x111c3,
+	0x1111c3,
+	0x2111c3,
+	0x112c3,
+	0x1112c3,
+	0x2112c3,
+	0x113c3,
+	0x1113c3,
+	0x2113c3,
+	0x114c3,
+	0x1114c3,
+	0x2114c3,
+	0x115c3,
+	0x1115c3,
+	0x2115c3,
+	0x116c3,
+	0x1116c3,
+	0x2116c3,
+	0x117c3,
+	0x1117c3,
+	0x2117c3,
+	0x118c3,
+	0x1118c3,
+	0x2118c3,
+	0x120c0,
+	0x1120c0,
+	0x2120c0,
+	0x121c0,
+	0x1121c0,
+	0x2121c0,
+	0x122c0,
+	0x1122c0,
+	0x2122c0,
+	0x123c0,
+	0x1123c0,
+	0x2123c0,
+	0x124c0,
+	0x1124c0,
+	0x2124c0,
+	0x125c0,
+	0x1125c0,
+	0x2125c0,
+	0x126c0,
+	0x1126c0,
+	0x2126c0,
+	0x127c0,
+	0x1127c0,
+	0x2127c0,
+	0x128c0,
+	0x1128c0,
+	0x2128c0,
+	0x120c1,
+	0x1120c1,
+	0x2120c1,
+	0x121c1,
+	0x1121c1,
+	0x2121c1,
+	0x122c1,
+	0x1122c1,
+	0x2122c1,
+	0x123c1,
+	0x1123c1,
+	0x2123c1,
+	0x124c1,
+	0x1124c1,
+	0x2124c1,
+	0x125c1,
+	0x1125c1,
+	0x2125c1,
+	0x126c1,
+	0x1126c1,
+	0x2126c1,
+	0x127c1,
+	0x1127c1,
+	0x2127c1,
+	0x128c1,
+	0x1128c1,
+	0x2128c1,
+	0x120c2,
+	0x1120c2,
+	0x2120c2,
+	0x121c2,
+	0x1121c2,
+	0x2121c2,
+	0x122c2,
+	0x1122c2,
+	0x2122c2,
+	0x123c2,
+	0x1123c2,
+	0x2123c2,
+	0x124c2,
+	0x1124c2,
+	0x2124c2,
+	0x125c2,
+	0x1125c2,
+	0x2125c2,
+	0x126c2,
+	0x1126c2,
+	0x2126c2,
+	0x127c2,
+	0x1127c2,
+	0x2127c2,
+	0x128c2,
+	0x1128c2,
+	0x2128c2,
+	0x120c3,
+	0x1120c3,
+	0x2120c3,
+	0x121c3,
+	0x1121c3,
+	0x2121c3,
+	0x122c3,
+	0x1122c3,
+	0x2122c3,
+	0x123c3,
+	0x1123c3,
+	0x2123c3,
+	0x124c3,
+	0x1124c3,
+	0x2124c3,
+	0x125c3,
+	0x1125c3,
+	0x2125c3,
+	0x126c3,
+	0x1126c3,
+	0x2126c3,
+	0x127c3,
+	0x1127c3,
+	0x2127c3,
+	0x128c3,
+	0x1128c3,
+	0x2128c3,
+	0x130c0,
+	0x1130c0,
+	0x2130c0,
+	0x131c0,
+	0x1131c0,
+	0x2131c0,
+	0x132c0,
+	0x1132c0,
+	0x2132c0,
+	0x133c0,
+	0x1133c0,
+	0x2133c0,
+	0x134c0,
+	0x1134c0,
+	0x2134c0,
+	0x135c0,
+	0x1135c0,
+	0x2135c0,
+	0x136c0,
+	0x1136c0,
+	0x2136c0,
+	0x137c0,
+	0x1137c0,
+	0x2137c0,
+	0x138c0,
+	0x1138c0,
+	0x2138c0,
+	0x130c1,
+	0x1130c1,
+	0x2130c1,
+	0x131c1,
+	0x1131c1,
+	0x2131c1,
+	0x132c1,
+	0x1132c1,
+	0x2132c1,
+	0x133c1,
+	0x1133c1,
+	0x2133c1,
+	0x134c1,
+	0x1134c1,
+	0x2134c1,
+	0x135c1,
+	0x1135c1,
+	0x2135c1,
+	0x136c1,
+	0x1136c1,
+	0x2136c1,
+	0x137c1,
+	0x1137c1,
+	0x2137c1,
+	0x138c1,
+	0x1138c1,
+	0x2138c1,
+	0x130c2,
+	0x1130c2,
+	0x2130c2,
+	0x131c2,
+	0x1131c2,
+	0x2131c2,
+	0x132c2,
+	0x1132c2,
+	0x2132c2,
+	0x133c2,
+	0x1133c2,
+	0x2133c2,
+	0x134c2,
+	0x1134c2,
+	0x2134c2,
+	0x135c2,
+	0x1135c2,
+	0x2135c2,
+	0x136c2,
+	0x1136c2,
+	0x2136c2,
+	0x137c2,
+	0x1137c2,
+	0x2137c2,
+	0x138c2,
+	0x1138c2,
+	0x2138c2,
+	0x130c3,
+	0x1130c3,
+	0x2130c3,
+	0x131c3,
+	0x1131c3,
+	0x2131c3,
+	0x132c3,
+	0x1132c3,
+	0x2132c3,
+	0x133c3,
+	0x1133c3,
+	0x2133c3,
+	0x134c3,
+	0x1134c3,
+	0x2134c3,
+	0x135c3,
+	0x1135c3,
+	0x2135c3,
+	0x136c3,
+	0x1136c3,
+	0x2136c3,
+	0x137c3,
+	0x1137c3,
+	0x2137c3,
+	0x138c3,
+	0x1138c3,
+	0x2138c3,
+	0x10020,
+	0x110020,
+	0x210020,
+	0x11020,
+	0x111020,
+	0x211020,
+	0x12020,
+	0x112020,
+	0x212020,
+	0x13020,
+	0x113020,
+#endif
+	0x213020,
+	0x2007d,
+	0x12007d,
+	0x22007d,
+	0
+};
+
+void restore_1d2d_trained_csr_ddr3_p012(unsigned int addr)
+{
+	unsigned int i;
+
+	dwc_ddrphy_apb_wr(0xd0000, 0x0); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+	for (i = 0; restore_csr[i] != 0; i++) {
+		dwc_ddrphy_apb_wr(restore_csr[i], reg32_read(addr + (i << 2)));
+	}
+	dwc_ddrphy_apb_wr(0xd0000, 0x1); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+
+	ddr_dbg("restore 1d2d training registers done \n");
+}
diff --git a/board/karo/tx8m/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c b/board/karo/tx8m/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c
new file mode 100644
index 0000000..4ea62bb
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c
@@ -0,0 +1,971 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "../ddr.h"
+#include "ddr3_define.h"
+
+static const unsigned int save_csr[] = {
+	0x200b2,
+	0x1200b2,
+	0x2200b2,
+	0x200cb,
+#ifdef RUN_ON_SILICON
+	0x10043,
+	0x110043,
+	0x210043,
+	0x10143,
+	0x110143,
+	0x210143,
+	0x11043,
+	0x111043,
+	0x211043,
+	0x11143,
+	0x111143,
+	0x211143,
+	0x12043,
+	0x112043,
+	0x212043,
+	0x12143,
+	0x112143,
+	0x212143,
+	0x13043,
+	0x113043,
+	0x213043,
+	0x13143,
+	0x113143,
+	0x213143,
+	0x80,
+	0x100080,
+	0x200080,
+	0x1080,
+	0x101080,
+	0x201080,
+	0x2080,
+	0x102080,
+	0x202080,
+	0x3080,
+	0x103080,
+	0x203080,
+	0x4080,
+	0x104080,
+	0x204080,
+	0x5080,
+	0x105080,
+	0x205080,
+	0x6080,
+	0x106080,
+	0x206080,
+	0x7080,
+	0x107080,
+	0x207080,
+	0x8080,
+	0x108080,
+	0x208080,
+	0x9080,
+	0x109080,
+	0x209080,
+	0x10080,
+	0x110080,
+	0x210080,
+	0x10180,
+	0x110180,
+	0x210180,
+	0x10081,
+	0x110081,
+	0x210081,
+	0x10181,
+	0x110181,
+	0x210181,
+	0x10082,
+	0x110082,
+	0x210082,
+	0x10182,
+	0x110182,
+	0x210182,
+	0x10083,
+	0x110083,
+	0x210083,
+	0x10183,
+	0x110183,
+	0x210183,
+	0x11080,
+	0x111080,
+	0x211080,
+	0x11180,
+	0x111180,
+	0x211180,
+	0x11081,
+	0x111081,
+	0x211081,
+	0x11181,
+	0x111181,
+	0x211181,
+	0x11082,
+	0x111082,
+	0x211082,
+	0x11182,
+	0x111182,
+	0x211182,
+	0x11083,
+	0x111083,
+	0x211083,
+	0x11183,
+	0x111183,
+	0x211183,
+	0x12080,
+	0x112080,
+	0x212080,
+	0x12180,
+	0x112180,
+	0x212180,
+	0x12081,
+	0x112081,
+	0x212081,
+	0x12181,
+	0x112181,
+	0x212181,
+	0x12082,
+	0x112082,
+	0x212082,
+	0x12182,
+	0x112182,
+	0x212182,
+	0x12083,
+	0x112083,
+	0x212083,
+	0x12183,
+	0x112183,
+	0x212183,
+	0x13080,
+	0x113080,
+	0x213080,
+	0x13180,
+	0x113180,
+	0x213180,
+	0x13081,
+	0x113081,
+	0x213081,
+	0x13181,
+	0x113181,
+	0x213181,
+	0x13082,
+	0x113082,
+	0x213082,
+	0x13182,
+	0x113182,
+	0x213182,
+	0x13083,
+	0x113083,
+	0x213083,
+	0x13183,
+	0x113183,
+	0x213183,
+	0x100d0,
+	0x1100d0,
+	0x2100d0,
+	0x101d0,
+	0x1101d0,
+	0x2101d0,
+	0x100d1,
+	0x1100d1,
+	0x2100d1,
+	0x101d1,
+	0x1101d1,
+	0x2101d1,
+	0x100d2,
+	0x1100d2,
+	0x2100d2,
+	0x101d2,
+	0x1101d2,
+	0x2101d2,
+	0x100d3,
+	0x1100d3,
+	0x2100d3,
+	0x101d3,
+	0x1101d3,
+	0x2101d3,
+	0x110d0,
+	0x1110d0,
+	0x2110d0,
+	0x111d0,
+	0x1111d0,
+	0x2111d0,
+	0x110d1,
+	0x1110d1,
+	0x2110d1,
+	0x111d1,
+	0x1111d1,
+	0x2111d1,
+	0x110d2,
+	0x1110d2,
+	0x2110d2,
+	0x111d2,
+	0x1111d2,
+	0x2111d2,
+	0x110d3,
+	0x1110d3,
+	0x2110d3,
+	0x111d3,
+	0x1111d3,
+	0x2111d3,
+	0x120d0,
+	0x1120d0,
+	0x2120d0,
+	0x121d0,
+	0x1121d0,
+	0x2121d0,
+	0x120d1,
+	0x1120d1,
+	0x2120d1,
+	0x121d1,
+	0x1121d1,
+	0x2121d1,
+	0x120d2,
+	0x1120d2,
+	0x2120d2,
+	0x121d2,
+	0x1121d2,
+	0x2121d2,
+	0x120d3,
+	0x1120d3,
+	0x2120d3,
+	0x121d3,
+	0x1121d3,
+	0x2121d3,
+	0x130d0,
+	0x1130d0,
+	0x2130d0,
+	0x131d0,
+	0x1131d0,
+	0x2131d0,
+	0x130d1,
+	0x1130d1,
+	0x2130d1,
+	0x131d1,
+	0x1131d1,
+	0x2131d1,
+	0x130d2,
+	0x1130d2,
+	0x2130d2,
+	0x131d2,
+	0x1131d2,
+	0x2131d2,
+	0x130d3,
+	0x1130d3,
+	0x2130d3,
+	0x131d3,
+	0x1131d3,
+	0x2131d3,
+	0x10068,
+	0x10168,
+	0x10268,
+	0x10368,
+	0x10468,
+	0x10568,
+	0x10668,
+	0x10768,
+	0x10868,
+	0x10069,
+	0x10169,
+	0x10269,
+	0x10369,
+	0x10469,
+	0x10569,
+	0x10669,
+	0x10769,
+	0x10869,
+	0x1006a,
+	0x1016a,
+	0x1026a,
+	0x1036a,
+	0x1046a,
+	0x1056a,
+	0x1066a,
+	0x1076a,
+	0x1086a,
+	0x1006b,
+	0x1016b,
+	0x1026b,
+	0x1036b,
+	0x1046b,
+	0x1056b,
+	0x1066b,
+	0x1076b,
+	0x1086b,
+	0x11068,
+	0x11168,
+	0x11268,
+	0x11368,
+	0x11468,
+	0x11568,
+	0x11668,
+	0x11768,
+	0x11868,
+	0x11069,
+	0x11169,
+	0x11269,
+	0x11369,
+	0x11469,
+	0x11569,
+	0x11669,
+	0x11769,
+	0x11869,
+	0x1106a,
+	0x1116a,
+	0x1126a,
+	0x1136a,
+	0x1146a,
+	0x1156a,
+	0x1166a,
+	0x1176a,
+	0x1186a,
+	0x1106b,
+	0x1116b,
+	0x1126b,
+	0x1136b,
+	0x1146b,
+	0x1156b,
+	0x1166b,
+	0x1176b,
+	0x1186b,
+	0x12068,
+	0x12168,
+	0x12268,
+	0x12368,
+	0x12468,
+	0x12568,
+	0x12668,
+	0x12768,
+	0x12868,
+	0x12069,
+	0x12169,
+	0x12269,
+	0x12369,
+	0x12469,
+	0x12569,
+	0x12669,
+	0x12769,
+	0x12869,
+	0x1206a,
+	0x1216a,
+	0x1226a,
+	0x1236a,
+	0x1246a,
+	0x1256a,
+	0x1266a,
+	0x1276a,
+	0x1286a,
+	0x1206b,
+	0x1216b,
+	0x1226b,
+	0x1236b,
+	0x1246b,
+	0x1256b,
+	0x1266b,
+	0x1276b,
+	0x1286b,
+	0x13068,
+	0x13168,
+	0x13268,
+	0x13368,
+	0x13468,
+	0x13568,
+	0x13668,
+	0x13768,
+	0x13868,
+	0x13069,
+	0x13169,
+	0x13269,
+	0x13369,
+	0x13469,
+	0x13569,
+	0x13669,
+	0x13769,
+	0x13869,
+	0x1306a,
+	0x1316a,
+	0x1326a,
+	0x1336a,
+	0x1346a,
+	0x1356a,
+	0x1366a,
+	0x1376a,
+	0x1386a,
+	0x1306b,
+	0x1316b,
+	0x1326b,
+	0x1336b,
+	0x1346b,
+	0x1356b,
+	0x1366b,
+	0x1376b,
+	0x1386b,
+	0x1008c,
+	0x11008c,
+	0x21008c,
+	0x1018c,
+	0x11018c,
+	0x21018c,
+	0x1008d,
+	0x11008d,
+	0x21008d,
+	0x1018d,
+	0x11018d,
+	0x21018d,
+	0x1008e,
+	0x11008e,
+	0x21008e,
+	0x1018e,
+	0x11018e,
+	0x21018e,
+	0x1008f,
+	0x11008f,
+	0x21008f,
+	0x1018f,
+	0x11018f,
+	0x21018f,
+	0x1108c,
+	0x11108c,
+	0x21108c,
+	0x1118c,
+	0x11118c,
+	0x21118c,
+	0x1108d,
+	0x11108d,
+	0x21108d,
+	0x1118d,
+	0x11118d,
+	0x21118d,
+	0x1108e,
+	0x11108e,
+	0x21108e,
+	0x1118e,
+	0x11118e,
+	0x21118e,
+	0x1108f,
+	0x11108f,
+	0x21108f,
+	0x1118f,
+	0x11118f,
+	0x21118f,
+	0x1208c,
+	0x11208c,
+	0x21208c,
+	0x1218c,
+	0x11218c,
+	0x21218c,
+	0x1208d,
+	0x11208d,
+	0x21208d,
+	0x1218d,
+	0x11218d,
+	0x21218d,
+	0x1208e,
+	0x11208e,
+	0x21208e,
+	0x1218e,
+	0x11218e,
+	0x21218e,
+	0x1208f,
+	0x11208f,
+	0x21208f,
+	0x1218f,
+	0x11218f,
+	0x21218f,
+	0x1308c,
+	0x11308c,
+	0x21308c,
+	0x1318c,
+	0x11318c,
+	0x21318c,
+	0x1308d,
+	0x11308d,
+	0x21308d,
+	0x1318d,
+	0x11318d,
+	0x21318d,
+	0x1308e,
+	0x11308e,
+	0x21308e,
+	0x1318e,
+	0x11318e,
+	0x21318e,
+	0x1308f,
+	0x11308f,
+	0x21308f,
+	0x1318f,
+	0x11318f,
+	0x21318f,
+	0x100c0,
+	0x1100c0,
+	0x2100c0,
+	0x101c0,
+	0x1101c0,
+	0x2101c0,
+	0x102c0,
+	0x1102c0,
+	0x2102c0,
+	0x103c0,
+	0x1103c0,
+	0x2103c0,
+	0x104c0,
+	0x1104c0,
+	0x2104c0,
+	0x105c0,
+	0x1105c0,
+	0x2105c0,
+	0x106c0,
+	0x1106c0,
+	0x2106c0,
+	0x107c0,
+	0x1107c0,
+	0x2107c0,
+	0x108c0,
+	0x1108c0,
+	0x2108c0,
+	0x100c1,
+	0x1100c1,
+	0x2100c1,
+	0x101c1,
+	0x1101c1,
+	0x2101c1,
+	0x102c1,
+	0x1102c1,
+	0x2102c1,
+	0x103c1,
+	0x1103c1,
+	0x2103c1,
+	0x104c1,
+	0x1104c1,
+	0x2104c1,
+	0x105c1,
+	0x1105c1,
+	0x2105c1,
+	0x106c1,
+	0x1106c1,
+	0x2106c1,
+	0x107c1,
+	0x1107c1,
+	0x2107c1,
+	0x108c1,
+	0x1108c1,
+	0x2108c1,
+	0x100c2,
+	0x1100c2,
+	0x2100c2,
+	0x101c2,
+	0x1101c2,
+	0x2101c2,
+	0x102c2,
+	0x1102c2,
+	0x2102c2,
+	0x103c2,
+	0x1103c2,
+	0x2103c2,
+	0x104c2,
+	0x1104c2,
+	0x2104c2,
+	0x105c2,
+	0x1105c2,
+	0x2105c2,
+	0x106c2,
+	0x1106c2,
+	0x2106c2,
+	0x107c2,
+	0x1107c2,
+	0x2107c2,
+	0x108c2,
+	0x1108c2,
+	0x2108c2,
+	0x100c3,
+	0x1100c3,
+	0x2100c3,
+	0x101c3,
+	0x1101c3,
+	0x2101c3,
+	0x102c3,
+	0x1102c3,
+	0x2102c3,
+	0x103c3,
+	0x1103c3,
+	0x2103c3,
+	0x104c3,
+	0x1104c3,
+	0x2104c3,
+	0x105c3,
+	0x1105c3,
+	0x2105c3,
+	0x106c3,
+	0x1106c3,
+	0x2106c3,
+	0x107c3,
+	0x1107c3,
+	0x2107c3,
+	0x108c3,
+	0x1108c3,
+	0x2108c3,
+	0x110c0,
+	0x1110c0,
+	0x2110c0,
+	0x111c0,
+	0x1111c0,
+	0x2111c0,
+	0x112c0,
+	0x1112c0,
+	0x2112c0,
+	0x113c0,
+	0x1113c0,
+	0x2113c0,
+	0x114c0,
+	0x1114c0,
+	0x2114c0,
+	0x115c0,
+	0x1115c0,
+	0x2115c0,
+	0x116c0,
+	0x1116c0,
+	0x2116c0,
+	0x117c0,
+	0x1117c0,
+	0x2117c0,
+	0x118c0,
+	0x1118c0,
+	0x2118c0,
+	0x110c1,
+	0x1110c1,
+	0x2110c1,
+	0x111c1,
+	0x1111c1,
+	0x2111c1,
+	0x112c1,
+	0x1112c1,
+	0x2112c1,
+	0x113c1,
+	0x1113c1,
+	0x2113c1,
+	0x114c1,
+	0x1114c1,
+	0x2114c1,
+	0x115c1,
+	0x1115c1,
+	0x2115c1,
+	0x116c1,
+	0x1116c1,
+	0x2116c1,
+	0x117c1,
+	0x1117c1,
+	0x2117c1,
+	0x118c1,
+	0x1118c1,
+	0x2118c1,
+	0x110c2,
+	0x1110c2,
+	0x2110c2,
+	0x111c2,
+	0x1111c2,
+	0x2111c2,
+	0x112c2,
+	0x1112c2,
+	0x2112c2,
+	0x113c2,
+	0x1113c2,
+	0x2113c2,
+	0x114c2,
+	0x1114c2,
+	0x2114c2,
+	0x115c2,
+	0x1115c2,
+	0x2115c2,
+	0x116c2,
+	0x1116c2,
+	0x2116c2,
+	0x117c2,
+	0x1117c2,
+	0x2117c2,
+	0x118c2,
+	0x1118c2,
+	0x2118c2,
+	0x110c3,
+	0x1110c3,
+	0x2110c3,
+	0x111c3,
+	0x1111c3,
+	0x2111c3,
+	0x112c3,
+	0x1112c3,
+	0x2112c3,
+	0x113c3,
+	0x1113c3,
+	0x2113c3,
+	0x114c3,
+	0x1114c3,
+	0x2114c3,
+	0x115c3,
+	0x1115c3,
+	0x2115c3,
+	0x116c3,
+	0x1116c3,
+	0x2116c3,
+	0x117c3,
+	0x1117c3,
+	0x2117c3,
+	0x118c3,
+	0x1118c3,
+	0x2118c3,
+	0x120c0,
+	0x1120c0,
+	0x2120c0,
+	0x121c0,
+	0x1121c0,
+	0x2121c0,
+	0x122c0,
+	0x1122c0,
+	0x2122c0,
+	0x123c0,
+	0x1123c0,
+	0x2123c0,
+	0x124c0,
+	0x1124c0,
+	0x2124c0,
+	0x125c0,
+	0x1125c0,
+	0x2125c0,
+	0x126c0,
+	0x1126c0,
+	0x2126c0,
+	0x127c0,
+	0x1127c0,
+	0x2127c0,
+	0x128c0,
+	0x1128c0,
+	0x2128c0,
+	0x120c1,
+	0x1120c1,
+	0x2120c1,
+	0x121c1,
+	0x1121c1,
+	0x2121c1,
+	0x122c1,
+	0x1122c1,
+	0x2122c1,
+	0x123c1,
+	0x1123c1,
+	0x2123c1,
+	0x124c1,
+	0x1124c1,
+	0x2124c1,
+	0x125c1,
+	0x1125c1,
+	0x2125c1,
+	0x126c1,
+	0x1126c1,
+	0x2126c1,
+	0x127c1,
+	0x1127c1,
+	0x2127c1,
+	0x128c1,
+	0x1128c1,
+	0x2128c1,
+	0x120c2,
+	0x1120c2,
+	0x2120c2,
+	0x121c2,
+	0x1121c2,
+	0x2121c2,
+	0x122c2,
+	0x1122c2,
+	0x2122c2,
+	0x123c2,
+	0x1123c2,
+	0x2123c2,
+	0x124c2,
+	0x1124c2,
+	0x2124c2,
+	0x125c2,
+	0x1125c2,
+	0x2125c2,
+	0x126c2,
+	0x1126c2,
+	0x2126c2,
+	0x127c2,
+	0x1127c2,
+	0x2127c2,
+	0x128c2,
+	0x1128c2,
+	0x2128c2,
+	0x120c3,
+	0x1120c3,
+	0x2120c3,
+	0x121c3,
+	0x1121c3,
+	0x2121c3,
+	0x122c3,
+	0x1122c3,
+	0x2122c3,
+	0x123c3,
+	0x1123c3,
+	0x2123c3,
+	0x124c3,
+	0x1124c3,
+	0x2124c3,
+	0x125c3,
+	0x1125c3,
+	0x2125c3,
+	0x126c3,
+	0x1126c3,
+	0x2126c3,
+	0x127c3,
+	0x1127c3,
+	0x2127c3,
+	0x128c3,
+	0x1128c3,
+	0x2128c3,
+	0x130c0,
+	0x1130c0,
+	0x2130c0,
+	0x131c0,
+	0x1131c0,
+	0x2131c0,
+	0x132c0,
+	0x1132c0,
+	0x2132c0,
+	0x133c0,
+	0x1133c0,
+	0x2133c0,
+	0x134c0,
+	0x1134c0,
+	0x2134c0,
+	0x135c0,
+	0x1135c0,
+	0x2135c0,
+	0x136c0,
+	0x1136c0,
+	0x2136c0,
+	0x137c0,
+	0x1137c0,
+	0x2137c0,
+	0x138c0,
+	0x1138c0,
+	0x2138c0,
+	0x130c1,
+	0x1130c1,
+	0x2130c1,
+	0x131c1,
+	0x1131c1,
+	0x2131c1,
+	0x132c1,
+	0x1132c1,
+	0x2132c1,
+	0x133c1,
+	0x1133c1,
+	0x2133c1,
+	0x134c1,
+	0x1134c1,
+	0x2134c1,
+	0x135c1,
+	0x1135c1,
+	0x2135c1,
+	0x136c1,
+	0x1136c1,
+	0x2136c1,
+	0x137c1,
+	0x1137c1,
+	0x2137c1,
+	0x138c1,
+	0x1138c1,
+	0x2138c1,
+	0x130c2,
+	0x1130c2,
+	0x2130c2,
+	0x131c2,
+	0x1131c2,
+	0x2131c2,
+	0x132c2,
+	0x1132c2,
+	0x2132c2,
+	0x133c2,
+	0x1133c2,
+	0x2133c2,
+	0x134c2,
+	0x1134c2,
+	0x2134c2,
+	0x135c2,
+	0x1135c2,
+	0x2135c2,
+	0x136c2,
+	0x1136c2,
+	0x2136c2,
+	0x137c2,
+	0x1137c2,
+	0x2137c2,
+	0x138c2,
+	0x1138c2,
+	0x2138c2,
+	0x130c3,
+	0x1130c3,
+	0x2130c3,
+	0x131c3,
+	0x1131c3,
+	0x2131c3,
+	0x132c3,
+	0x1132c3,
+	0x2132c3,
+	0x133c3,
+	0x1133c3,
+	0x2133c3,
+	0x134c3,
+	0x1134c3,
+	0x2134c3,
+	0x135c3,
+	0x1135c3,
+	0x2135c3,
+	0x136c3,
+	0x1136c3,
+	0x2136c3,
+	0x137c3,
+	0x1137c3,
+	0x2137c3,
+	0x138c3,
+	0x1138c3,
+	0x2138c3,
+	0x10020,
+	0x110020,
+	0x210020,
+	0x11020,
+	0x111020,
+	0x211020,
+	0x12020,
+	0x112020,
+	0x212020,
+	0x13020,
+	0x113020,
+#endif
+	0x213020,
+	0x2007d,
+	0x12007d,
+	0x22007d,
+	0
+};
+
+void save_1d2d_trained_csr_ddr3_p012(unsigned int addr)
+{
+	unsigned int i;
+
+	dwc_ddrphy_apb_wr(0xd0000, 0x0); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+	dwc_ddrphy_apb_wr(0xc0080, 0x3); /* DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
+	for (i = 0; save_csr[i] != 0; i++) {
+		reg32_write(addr + (i << 2), dwc_ddrphy_apb_rd(save_csr[i]));
+	}
+	dwc_ddrphy_apb_wr(0xc0080, 0x0); /* DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
+	dwc_ddrphy_apb_wr(0xd0000, 0x1); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+
+	ddr_dbg("save 1d2d training registers done \n");
+}
diff --git a/board/karo/tx8m/ddr/ddr_init.c b/board/karo/tx8m/ddr/ddr_init.c
new file mode 100644
index 0000000..63bb39b
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddr_init.c
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Generated code from MX8M_DDR_tool
+ * Align with uboot-imx_v2017.03_4.9.51_imx8m_ga
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "ddr.h"
+
+#ifdef CONFIG_ENABLE_DDR_TRAINING_DEBUG
+#define ddr_printf(args...) printf(args)
+#else
+#define ddr_printf(args...) do {} while (0)
+#endif
+
+#define SILICON_TRAIN
+
+/*
+ * SDRAM_BUS_WIDTH:
+ *		0 => Full DQ bus width
+ *		1 => Half DQ bus width
+ *		2 => Quarter DQ bus width
+ */
+
+void ddr_init(void)
+{
+	unsigned int tmp, tmp_t;
+
+	/** Initialize DDR clock and DDRC registers **/
+	reg32_write(0x30391000, 0x8f00003f);
+	reg32_write(0x30391000, 0x8f00000f);
+	reg32_write(0x3038a088, 0x7070000);
+	reg32_write(0x3038a084, 0x4030000);
+	reg32_write(0x303a00ec, 0xffff);
+	tmp = reg32_read(0x303a00f8);
+	tmp |= 0x20;
+	reg32_write(0x303a00f8, tmp);
+	reg32_write(0x30391004, 0x8f000000);
+	reg32_write(0x30360054, 0x12c091);
+	reg32_write(0x30360058, 0x0);
+	tmp = reg32_read(0x30360050);
+	tmp |= 0x200;
+	reg32_write(0x30360050, tmp);
+	tmp = reg32_read(0x30360050);
+	tmp &= ~0x10;
+	reg32_write(0x30360050, tmp);
+	do {
+		tmp = reg32_read(0x30360050);
+		if (tmp & 0x80000000)
+			break;
+	} while (1);
+	reg32_write(0x30391000, 0x8f000006);
+	reg32_write(0x3d400304, 0x1);
+	reg32_write(0x3d400030, 0x20);
+	reg32_write(0x3d400000, 0x81040001 | (SDRAM_BUS_WIDTH << 12));
+	reg32_write(0x3d400010, 0x40004010);
+	reg32_write(0x3d400064, 0x610068);
+	reg32_write(0x3d4000d0, 0xc00200c5);
+	reg32_write(0x3d4000d4, 0x0001000b);
+	reg32_write(0x3d4000dc, 0x1c700004);
+	reg32_write(0x3d4000e0, 0x00180000);
+	reg32_write(0x3d4000e4, 0x00090000);
+	reg32_write(0x3d4000f0, 0x00000000);
+	reg32_write(0x3d4000f4, 0x00000ee5);
+	reg32_write(0x3d400100, 0x0c101b0e);
+	reg32_write(0x3d400104, 0x00030314);
+	reg32_write(0x3d400108, 0x04060509);
+	reg32_write(0x3d40010c, 0x00002006);
+	reg32_write(0x3d400110, 0x06020306);
+	reg32_write(0x3d400114, 0x04040302);
+#if SDRAM_BUS_WIDTH == 0
+	reg32_write(0x3d400120, 0x00000905);
+#else
+	reg32_write(0x3d400120, 0x00000906);
+#endif
+	reg32_write(0x3d400180, 0x40800020);
+	reg32_write(0x3d400184, 0x0000c350);
+	reg32_write(0x3d400190, 0x03868203);
+	reg32_write(0x3d400194, 0x00020303);
+	reg32_write(0x3d4001b4, 0x00000603);
+	reg32_write(0x3d400198, 0x07000000);
+	reg32_write(0x3d4001b0, 0x00000011);
+	reg32_write(0x3d4001a0, 0x00400018);
+	reg32_write(0x3d4001a4, 0x0005003c);
+	reg32_write(0x3d4001a8, 0x80000000);
+	reg32_write(0x3d4001c4, 0x00000001);
+	reg32_write(0x3d400200, 0x0000001f);
+#if SDRAM_BUS_WIDTH == 0
+	reg32_write(0x3d400204, 0x00080808);
+#else
+	reg32_write(0x3d400204, 0x00070707);
+#endif
+	reg32_write(0x3d400208, 0x00000000);
+#if SDRAM_BUS_WIDTH == 0
+	reg32_write(0x3d40020c, 0x00000000);
+#else
+	reg32_write(0x3d40020c, 0x1f000000);
+#endif
+	reg32_write(0x3d400210, 0x00001f1f);
+#if SDRAM_BUS_WIDTH == 0
+	reg32_write(0x3d400214, 0x07070707);
+	reg32_write(0x3d400218, 0x0f070707);
+#else
+	reg32_write(0x3d400214, 0x06060606);
+	reg32_write(0x3d400218, 0x0f060606);
+#endif
+	reg32_write(0x3d400224, 0x0a020b06);
+	reg32_write(0x3d400228, 0x0a0a0a0a);
+	reg32_write(0x3d40022c, 0x00000000);
+	reg32_write(0x3d400240, 0x0600060c);
+	reg32_write(0x3d400244, 0x00001323);
+	reg32_write(0x3d400264, 0x00000009);
+	reg32_write(0x3d40049c, 0x00100001);
+	reg32_write(0x3d4004a0, 0x0000041f);
+	reg32_write(0x30391000, 0x8f000000);
+	reg32_write(0x3d400304, 0x00000000);
+	reg32_write(0x3d400030, 0x000000a8);
+	reg32_write(0x3d400320, 0x00000000);
+	reg32_write(0x30391000, 0x8f000004);
+	reg32_write(0x30391000, 0x8f000000);
+	reg32_write(0x3d400320, 0x00000000);
+	reg32_write(0x3d4001b0, 0x00000000);
+	do {
+		tmp = reg32_read(0x3d400308);
+		if (tmp & 0x36000000) break;
+	} while (1);
+	reg32_write(0x3d400490, 0x00000000);
+	do {
+		tmp = reg32_read(0x3d4003fc);
+		if ((tmp & 0x10001) == 0) break;
+	} while (1);
+	reg32_write(0x3d400030, 0xa8);
+	do {
+		tmp = reg32_read(0x3d400004);
+		if (tmp & 0x3) break;
+	} while (1);
+
+	/* Configure DDR PHY's registers */
+	ddr_cfg_phy();
+
+	reg32_write(DDRC_RFSHCTL3(0), 0x00000000);
+	reg32_write(DDRC_SWCTL(0), 0x0000);
+	/*
+	 * ------------------- 9 -------------------
+	 * Set DFIMISC.dfi_init_start to 1
+	 *  -----------------------------------------
+	 */
+	reg32_write(DDRC_DFIMISC(0), 0x00000030);
+	reg32_write(DDRC_SWCTL(0), 0x0001);
+
+	/* wait DFISTAT.dfi_init_complete to 1 */
+	tmp_t = 0;
+	while (tmp_t == 0) {
+		tmp  = reg32_read(DDRC_DFISTAT(0));
+		tmp_t = tmp & 0x01;
+		tmp  = reg32_read(DDRC_MRSTAT(0));
+	}
+
+	reg32_write(DDRC_SWCTL(0), 0x0000);
+
+	/* clear DFIMISC.dfi_init_complete_en */
+	reg32_write(DDRC_DFIMISC(0), 0x00000010);
+	reg32_write(DDRC_DFIMISC(0), 0x00000011);
+	reg32_write(DDRC_PWRCTL(0), 0x00000088);
+
+	tmp = reg32_read(DDRC_CRCPARSTAT(0));
+	/*
+	 * set SWCTL.sw_done to enable quasi-dynamic register
+	 * programming outside reset.
+	 */
+	reg32_write(DDRC_SWCTL(0), 0x00000001);
+
+	/* wait SWSTAT.sw_done_ack to 1 */
+	while ((reg32_read(DDRC_SWSTAT(0)) & 0x1) == 0)
+		;
+
+	/* wait STAT.operating_mode([1:0] for ddr3) to normal state */
+	while ((reg32_read(DDRC_STAT(0)) & 0x3) != 0x1)
+		;
+
+	reg32_write(DDRC_PWRCTL(0), 0x00000088);
+	/* reg32_write(DDRC_PWRCTL(0), 0x018a); */
+	tmp = reg32_read(DDRC_CRCPARSTAT(0));
+
+	/* enable port 0 */
+	reg32_write(DDRC_PCTRL_0(0), 0x00000001);
+	/* enable DDR auto-refresh mode */
+	tmp = reg32_read(DDRC_RFSHCTL3(0)) & ~0x1;
+	reg32_write(DDRC_RFSHCTL3(0), tmp);
+}
diff --git a/board/karo/tx8m/ddr/ddrphy_train.c b/board/karo/tx8m/ddr/ddrphy_train.c
new file mode 100644
index 0000000..7b25ca0
--- /dev/null
+++ b/board/karo/tx8m/ddr/ddrphy_train.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Generated code from MX8M_DDR_tool
+ * Align with uboot-imx_v2017.03_4.9.51_imx8m_ga
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include "ddr.h"
+
+extern void wait_ddrphy_training_complete(void);
+void ddr_cfg_phy(void) {
+	unsigned int tmp, calbusy;
+
+	//Init DDRPHY register...
+	reg32_write(0x3c04017c, 0x3ff);
+	reg32_write(0x3c04057c, 0x3ff);
+	reg32_write(0x3c04417c, 0x3ff);
+	reg32_write(0x3c04457c, 0x3ff);
+	reg32_write(0x3c04817c, 0x3ff);
+	reg32_write(0x3c04857c, 0x3ff);
+	reg32_write(0x3c04c17c, 0x3ff);
+	reg32_write(0x3c04c57c, 0x3ff);
+	reg32_write(0x3c000154, 0x3ff);
+	reg32_write(0x3c004154, 0x3ff);
+	reg32_write(0x3c008154, 0x3ff);
+	reg32_write(0x3c00c154, 0x3ff);
+	reg32_write(0x3c010154, 0xff);
+	reg32_write(0x3c014154, 0xff);
+	reg32_write(0x3c018154, 0x3ff);
+	reg32_write(0x3c01c154, 0x3ff);
+	reg32_write(0x3c020154, 0x3ff);
+	reg32_write(0x3c024154, 0x3ff);
+	reg32_write(0x3c080314, 0xb);
+	reg32_write(0x3c0800b8, 0x1);
+	reg32_write(0x3c080090, 0x8);
+	reg32_write(0x3c0800e8, 0x0);
+	reg32_write(0x3c080158, 0xa);
+	reg32_write(0x3c040134, 0x208);
+	reg32_write(0x3c040534, 0x208);
+	reg32_write(0x3c044134, 0x208);
+	reg32_write(0x3c044534, 0x208);
+	reg32_write(0x3c048134, 0x208);
+	reg32_write(0x3c048534, 0x208);
+	reg32_write(0x3c04c134, 0x208);
+	reg32_write(0x3c04c534, 0x208);
+	reg32_write(0x3c040124, 0x618);
+	reg32_write(0x3c040524, 0x618);
+	reg32_write(0x3c044124, 0x618);
+	reg32_write(0x3c044524, 0x618);
+	reg32_write(0x3c048124, 0x618);
+	reg32_write(0x3c048524, 0x618);
+	reg32_write(0x3c04c124, 0x618);
+	reg32_write(0x3c04c524, 0x618);
+	reg32_write(0x3c00010c, 0x21);
+	reg32_write(0x3c00410c, 0x21);
+	reg32_write(0x3c00810c, 0x21);
+	reg32_write(0x3c00c10c, 0x21);
+	reg32_write(0x3c01010c, 0x21);
+	reg32_write(0x3c01410c, 0x21);
+	reg32_write(0x3c01810c, 0x21);
+	reg32_write(0x3c01c10c, 0x21);
+	reg32_write(0x3c02010c, 0x21);
+	reg32_write(0x3c02410c, 0x21);
+	reg32_write(0x3c080060, 0x5);
+	reg32_write(0x3c0801d4, 0x0);
+	reg32_write(0x3c080140, 0x0);
+	reg32_write(0x3c080020, 0x190);
+	reg32_write(0x3c080220, 0x9);
+	reg32_write(0x3c0802c8, 0x0);
+	reg32_write(0x3c04010c, 0x581);
+	reg32_write(0x3c04050c, 0x581);
+	reg32_write(0x3c04410c, 0x581);
+	reg32_write(0x3c04450c, 0x581);
+	reg32_write(0x3c04810c, 0x581);
+	reg32_write(0x3c04850c, 0x581);
+	reg32_write(0x3c04c10c, 0x581);
+	reg32_write(0x3c04c50c, 0x581);
+	reg32_write(0x3c0803e8, 0x1);
+	reg32_write(0x3c080064, 0x5);
+	reg32_write(0x3c0803c0, 0x5555);
+	reg32_write(0x3c0803c4, 0x5555);
+	reg32_write(0x3c0803c8, 0x5555);
+	reg32_write(0x3c0803cc, 0x5555);
+	reg32_write(0x3c0803d0, 0x5555);
+	reg32_write(0x3c0803d4, 0x5555);
+	reg32_write(0x3c0803d8, 0x5555);
+	reg32_write(0x3c0803dc, 0xf000);
+	reg32_write(0x3c080094, 0x0);
+	reg32_write(0x3c0800b4, 0x0);
+	reg32_write(0x3c08031c, 0x21);
+	reg32_write(0x3c080328, 0x24);
+
+	//enable APB bus to access DDRPHY RAM
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x0);
+	//load the 1D training image
+	ddr_load_train_code(FW_1D_IMAGE);
+
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54003, 0x640);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54004, 0x2);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54005, 0x3c3c);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54006, 0x12c);
+#if SDRAM_BUS_WIDTH == 0
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54007, 0x2000);
+#else
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54007, 0x1000);
+#endif
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54008, 0x101);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5400b, 0x31f);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5400c, 0xc8);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54012, 0x1);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5402f, 0x1c70);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54030, 0x4);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54031, 0x18);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5403a, 0x1323);
+
+	//disable APB bus to access DDRPHY RAM
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x1);
+	//Reset MPU and run
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x9);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x1);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x0);
+	wait_ddrphy_training_complete();
+
+	//set the PHY input clock to the desired frequency for pstate 0
+	reg32_write(0x30360054, 0x12c091);
+	reg32_write(0x30360058, 0x0);
+	tmp = reg32_read(0x30360050);
+	tmp |= 0x200;
+	reg32_write(0x30360050, tmp);
+	tmp = reg32_read(0x30360050);
+	tmp &= ~0x10;
+	reg32_write(0x30360050, tmp);
+	do {
+		tmp = reg32_read(0x30360050);
+		if (tmp & 0x80000000)
+			break;
+	} while (1);
+
+	//Halt MPU
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x1);
+	//enable APB bus to access DDRPHY RAM
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x0);
+
+	//Load firmware PIE image
+	reg32_write(0x3c240000, 0x10);
+	reg32_write(0x3c240004, 0x400);
+	reg32_write(0x3c240008, 0x10e);
+	reg32_write(0x3c24000c, 0x0);
+	reg32_write(0x3c240010, 0x0);
+	reg32_write(0x3c240014, 0x8);
+	reg32_write(0x3c2400a4, 0xb);
+	reg32_write(0x3c2400a8, 0x480);
+	reg32_write(0x3c2400ac, 0x109);
+	reg32_write(0x3c2400b0, 0x8);
+	reg32_write(0x3c2400b4, 0x448);
+	reg32_write(0x3c2400b8, 0x139);
+	reg32_write(0x3c2400bc, 0x8);
+	reg32_write(0x3c2400c0, 0x478);
+	reg32_write(0x3c2400c4, 0x109);
+	reg32_write(0x3c2400c8, 0x2);
+	reg32_write(0x3c2400cc, 0x10);
+	reg32_write(0x3c2400d0, 0x139);
+	reg32_write(0x3c2400d4, 0xf);
+	reg32_write(0x3c2400d8, 0x7c0);
+	reg32_write(0x3c2400dc, 0x139);
+	reg32_write(0x3c2400e0, 0x44);
+	reg32_write(0x3c2400e4, 0x630);
+	reg32_write(0x3c2400e8, 0x159);
+	reg32_write(0x3c2400ec, 0x14f);
+	reg32_write(0x3c2400f0, 0x630);
+	reg32_write(0x3c2400f4, 0x159);
+	reg32_write(0x3c2400f8, 0x47);
+	reg32_write(0x3c2400fc, 0x630);
+	reg32_write(0x3c240100, 0x149);
+	reg32_write(0x3c240104, 0x4f);
+	reg32_write(0x3c240108, 0x630);
+	reg32_write(0x3c24010c, 0x179);
+	reg32_write(0x3c240110, 0x8);
+	reg32_write(0x3c240114, 0xe0);
+	reg32_write(0x3c240118, 0x109);
+	reg32_write(0x3c24011c, 0x0);
+	reg32_write(0x3c240120, 0x7c8);
+	reg32_write(0x3c240124, 0x109);
+	reg32_write(0x3c240128, 0x0);
+	reg32_write(0x3c24012c, 0x1);
+	reg32_write(0x3c240130, 0x8);
+	reg32_write(0x3c240134, 0x0);
+	reg32_write(0x3c240138, 0x45a);
+	reg32_write(0x3c24013c, 0x9);
+	reg32_write(0x3c240140, 0x0);
+	reg32_write(0x3c240144, 0x448);
+	reg32_write(0x3c240148, 0x109);
+	reg32_write(0x3c24014c, 0x40);
+	reg32_write(0x3c240150, 0x630);
+	reg32_write(0x3c240154, 0x179);
+	reg32_write(0x3c240158, 0x1);
+	reg32_write(0x3c24015c, 0x618);
+	reg32_write(0x3c240160, 0x109);
+	reg32_write(0x3c240164, 0x40c0);
+	reg32_write(0x3c240168, 0x630);
+	reg32_write(0x3c24016c, 0x149);
+	reg32_write(0x3c240170, 0x8);
+	reg32_write(0x3c240174, 0x4);
+	reg32_write(0x3c240178, 0x48);
+	reg32_write(0x3c24017c, 0x4040);
+	reg32_write(0x3c240180, 0x630);
+	reg32_write(0x3c240184, 0x149);
+	reg32_write(0x3c240188, 0x0);
+	reg32_write(0x3c24018c, 0x4);
+	reg32_write(0x3c240190, 0x48);
+	reg32_write(0x3c240194, 0x40);
+	reg32_write(0x3c240198, 0x630);
+	reg32_write(0x3c24019c, 0x149);
+	reg32_write(0x3c2401a0, 0x10);
+	reg32_write(0x3c2401a4, 0x4);
+	reg32_write(0x3c2401a8, 0x18);
+	reg32_write(0x3c2401ac, 0x0);
+	reg32_write(0x3c2401b0, 0x4);
+	reg32_write(0x3c2401b4, 0x78);
+	reg32_write(0x3c2401b8, 0x549);
+	reg32_write(0x3c2401bc, 0x630);
+	reg32_write(0x3c2401c0, 0x159);
+	reg32_write(0x3c2401c4, 0xd49);
+	reg32_write(0x3c2401c8, 0x630);
+	reg32_write(0x3c2401cc, 0x159);
+	reg32_write(0x3c2401d0, 0x94a);
+	reg32_write(0x3c2401d4, 0x630);
+	reg32_write(0x3c2401d8, 0x159);
+	reg32_write(0x3c2401dc, 0x441);
+	reg32_write(0x3c2401e0, 0x630);
+	reg32_write(0x3c2401e4, 0x149);
+	reg32_write(0x3c2401e8, 0x42);
+	reg32_write(0x3c2401ec, 0x630);
+	reg32_write(0x3c2401f0, 0x149);
+	reg32_write(0x3c2401f4, 0x1);
+	reg32_write(0x3c2401f8, 0x630);
+	reg32_write(0x3c2401fc, 0x149);
+	reg32_write(0x3c240200, 0x0);
+	reg32_write(0x3c240204, 0xe0);
+	reg32_write(0x3c240208, 0x109);
+	reg32_write(0x3c24020c, 0xa);
+	reg32_write(0x3c240210, 0x10);
+	reg32_write(0x3c240214, 0x109);
+	reg32_write(0x3c240218, 0x9);
+	reg32_write(0x3c24021c, 0x3c0);
+	reg32_write(0x3c240220, 0x149);
+	reg32_write(0x3c240224, 0x9);
+	reg32_write(0x3c240228, 0x3c0);
+	reg32_write(0x3c24022c, 0x159);
+	reg32_write(0x3c240230, 0x18);
+	reg32_write(0x3c240234, 0x10);
+	reg32_write(0x3c240238, 0x109);
+	reg32_write(0x3c24023c, 0x0);
+	reg32_write(0x3c240240, 0x3c0);
+	reg32_write(0x3c240244, 0x109);
+	reg32_write(0x3c240248, 0x18);
+	reg32_write(0x3c24024c, 0x4);
+	reg32_write(0x3c240250, 0x48);
+	reg32_write(0x3c240254, 0x18);
+	reg32_write(0x3c240258, 0x4);
+	reg32_write(0x3c24025c, 0x58);
+	reg32_write(0x3c240260, 0xa);
+	reg32_write(0x3c240264, 0x10);
+	reg32_write(0x3c240268, 0x109);
+	reg32_write(0x3c24026c, 0x2);
+	reg32_write(0x3c240270, 0x10);
+	reg32_write(0x3c240274, 0x109);
+	reg32_write(0x3c240278, 0x7);
+	reg32_write(0x3c24027c, 0x7c0);
+	reg32_write(0x3c240280, 0x109);
+	reg32_write(0x3c240284, 0x10);
+	reg32_write(0x3c240288, 0x10);
+	reg32_write(0x3c24028c, 0x109);
+	reg32_write(0x3c240290, 0x0);
+	reg32_write(0x3c240294, 0x8140);
+	reg32_write(0x3c240298, 0x10c);
+	reg32_write(0x3c24029c, 0x10);
+	reg32_write(0x3c2402a0, 0x8138);
+	reg32_write(0x3c2402a4, 0x10c);
+	reg32_write(0x3c2402a8, 0x8);
+	reg32_write(0x3c2402ac, 0x7c8);
+	reg32_write(0x3c2402b0, 0x101);
+	reg32_write(0x3c2402b4, 0x8);
+	reg32_write(0x3c2402b8, 0x0);
+	reg32_write(0x3c2402bc, 0x8);
+	reg32_write(0x3c2402c0, 0x8);
+	reg32_write(0x3c2402c4, 0x448);
+	reg32_write(0x3c2402c8, 0x109);
+	reg32_write(0x3c2402cc, 0xf);
+	reg32_write(0x3c2402d0, 0x7c0);
+	reg32_write(0x3c2402d4, 0x109);
+	reg32_write(0x3c2402d8, 0x47);
+	reg32_write(0x3c2402dc, 0x630);
+	reg32_write(0x3c2402e0, 0x109);
+	reg32_write(0x3c2402e4, 0x8);
+	reg32_write(0x3c2402e8, 0x618);
+	reg32_write(0x3c2402ec, 0x109);
+	reg32_write(0x3c2402f0, 0x8);
+	reg32_write(0x3c2402f4, 0xe0);
+	reg32_write(0x3c2402f8, 0x109);
+	reg32_write(0x3c2402fc, 0x0);
+	reg32_write(0x3c240300, 0x7c8);
+	reg32_write(0x3c240304, 0x109);
+	reg32_write(0x3c240308, 0x8);
+	reg32_write(0x3c24030c, 0x8140);
+	reg32_write(0x3c240310, 0x10c);
+	reg32_write(0x3c240314, 0x0);
+	reg32_write(0x3c240318, 0x1);
+	reg32_write(0x3c24031c, 0x8);
+	reg32_write(0x3c240320, 0x8);
+	reg32_write(0x3c240324, 0x4);
+	reg32_write(0x3c240328, 0x8);
+	reg32_write(0x3c24032c, 0x8);
+	reg32_write(0x3c240330, 0x7c8);
+	reg32_write(0x3c240334, 0x101);
+	reg32_write(0x3c240018, 0x0);
+	reg32_write(0x3c24001c, 0x0);
+	reg32_write(0x3c240020, 0x8);
+	reg32_write(0x3c240024, 0x0);
+	reg32_write(0x3c240028, 0x0);
+	reg32_write(0x3c24002c, 0x0);
+	reg32_write(0x3c34039c, 0x400);
+	reg32_write(0x3c24005c, 0x0);
+	reg32_write(0x3c240098, 0x2c);
+	reg32_write(0x3c08002c, 0x32);
+	reg32_write(0x3c080030, 0x64);
+	reg32_write(0x3c080034, 0x3e8);
+	reg32_write(0x3c080038, 0x2c);
+	reg32_write(0x3c240030, 0x0);
+	reg32_write(0x3c240034, 0x173);
+	reg32_write(0x3c240038, 0x60);
+	reg32_write(0x3c24003c, 0x6110);
+	reg32_write(0x3c240040, 0x2152);
+	reg32_write(0x3c240044, 0xdfbd);
+	reg32_write(0x3c240048, 0xffff);
+	reg32_write(0x3c24004c, 0x6152);
+	reg32_write(0x3c300200, 0x00000000);
+	/*
+	 * CalBusy.0 == 1, indicates the calibrator is actively calibrating.
+	 * Wait Calibrating done.
+	 */
+	do {
+		tmp = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x20097);
+		calbusy = tmp & 0x01;
+	} while (calbusy);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x0);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x2006e, 0x0);
+	//disable APB bus to access DDRPHY RAM
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x1);
+}
diff --git a/board/karo/tx8m/ddr/helper.c b/board/karo/tx8m/ddr/helper.c
new file mode 100644
index 0000000..a63be80
--- /dev/null
+++ b/board/karo/tx8m/ddr/helper.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spl.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/sections.h>
+
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define IMEM_LEN 32768
+#define DMEM_LEN 16384
+#define IMEM_2D_OFFSET	49152
+
+#define IMEM_OFFSET_ADDR 0x00050000
+#define DMEM_OFFSET_ADDR 0x00054000
+#define DDR_TRAIN_CODE_BASE_ADDR IP2APB_DDRPHY_IPS_BASE_ADDR(0)
+
+/* We need PHY iMEM PHY is 32KB padded */
+void ddr_load_train_code(enum fw_type type)
+{
+	u32 tmp32, i;
+	u32 error = 0;
+	unsigned long pr_to32, pr_from32;
+	unsigned long fw_offset = type ? IMEM_2D_OFFSET : 0;
+	unsigned long imem_start = (unsigned long)&_end + fw_offset;
+	unsigned long dmem_start = imem_start + IMEM_LEN;
+
+	pr_from32 = imem_start;
+	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * IMEM_OFFSET_ADDR;
+	for (i = 0x0; i < IMEM_LEN; ) {
+		tmp32 = readl(pr_from32);
+		writew(tmp32 & 0x0000ffff, pr_to32);
+		pr_to32 += 4;
+		writew((tmp32 >> 16) & 0x0000ffff, pr_to32);
+		pr_to32 += 4;
+		pr_from32 += 4;
+		i += 4;
+	}
+
+	pr_from32 = dmem_start;
+	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * DMEM_OFFSET_ADDR;
+	for (i = 0x0; i < DMEM_LEN;) {
+		tmp32 = readl(pr_from32);
+		writew(tmp32 & 0x0000ffff, pr_to32);
+		pr_to32 += 4;
+		writew((tmp32 >> 16) & 0x0000ffff, pr_to32);
+		pr_to32 += 4;
+		pr_from32 += 4;
+		i += 4;
+	}
+
+	debug("check ddr_train_imem code\n");
+	pr_from32 = imem_start;
+	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * IMEM_OFFSET_ADDR;
+	for (i = 0x0; i < IMEM_LEN;) {
+		tmp32 = (readw(pr_to32) & 0x0000ffff);
+		pr_to32 += 4;
+		tmp32 += ((readw(pr_to32) & 0x0000ffff) << 16);
+
+		if (tmp32 != readl(pr_from32)) {
+			printf("%lx %lx\n", pr_from32, pr_to32);
+			error++;
+		}
+		pr_from32 += 4;
+		pr_to32 += 4;
+		i += 4;
+	}
+	if (error)
+		printf("check ddr_train_imem code fail=%d\n", error);
+	else
+		debug("check ddr_train_imem code pass\n");
+
+	debug("check ddr_train_dmem code\n");
+	pr_from32 = dmem_start;
+	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * DMEM_OFFSET_ADDR;
+	for (i = 0x0; i < DMEM_LEN;) {
+		tmp32 = (readw(pr_to32) & 0x0000ffff);
+		pr_to32 += 4;
+		tmp32 += ((readw(pr_to32) & 0x0000ffff) << 16);
+		if (tmp32 != readl(pr_from32)) {
+			printf("%lx %lx\n", pr_from32, pr_to32);
+			error++;
+		}
+		pr_from32 += 4;
+		pr_to32 += 4;
+		i += 4;
+	}
+
+	if (error)
+		printf("check ddr_train_dmem code fail=%d", error);
+	else
+		debug("check ddr_train_dmem code pass\n");
+}
diff --git a/board/karo/tx8m/ddr/wait_ddrphy_training_complete.c b/board/karo/tx8m/ddr/wait_ddrphy_training_complete.c
new file mode 100644
index 0000000..8b1febe
--- /dev/null
+++ b/board/karo/tx8m/ddr/wait_ddrphy_training_complete.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "ddr.h"
+
+static inline void poll_pmu_message_ready(void)
+{
+	unsigned int reg;
+
+	do {
+		reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0004);
+	} while (reg & 0x1);
+}
+
+static inline void ack_pmu_message_recieve(void)
+{
+	unsigned int reg;
+
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0031, 0x0);
+
+	do {
+		reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0004);
+	} while (!(reg & 0x1));
+
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0031, 0x1);
+}
+
+static inline unsigned int get_mail(void)
+{
+	unsigned int reg;
+
+	poll_pmu_message_ready();
+
+	reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0032);
+
+	ack_pmu_message_recieve();
+
+	return reg;
+}
+
+static inline unsigned int get_stream_message(void)
+{
+	unsigned int reg, reg2;
+
+	poll_pmu_message_ready();
+
+	reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0032);
+	reg2 = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0034);
+	reg2 = (reg2 << 16) | reg;
+
+	ack_pmu_message_recieve();
+
+	return reg2;
+}
+
+static inline void decode_major_message(unsigned int mail)
+{
+	ddr_dbg("[PMU Major message = 0x%08x]\n", mail);
+}
+
+static inline void decode_streaming_message(void)
+{
+	unsigned int string_index, arg __maybe_unused;
+	int i = 0;
+
+	string_index = get_stream_message();
+	ddr_dbg("	PMU String index = 0x%08x\n", string_index);
+	while (i < (string_index & 0xffff)) {
+		arg = get_stream_message();
+		ddr_dbg("	arg[%d] = 0x%08x\n", i, arg);
+		i++;
+	}
+
+	ddr_dbg("\n");
+}
+
+void wait_ddrphy_training_complete(void)
+{
+	unsigned int mail;
+
+	while (1) {
+		mail = get_mail();
+		decode_major_message(mail);
+		if (mail == 0x08) {
+			decode_streaming_message();
+		} else if (mail == 0x07) {
+			debug("DDR training PASS\n");
+			break;
+		} else if (mail == 0xff) {
+			printf("DDR training FAILED\n");
+			break;
+		}
+	}
+}
diff --git a/board/karo/tx8m/ddr3l_timing.c b/board/karo/tx8m/ddr3l_timing.c
new file mode 100644
index 0000000..66ee552
--- /dev/null
+++ b/board/karo/tx8m/ddr3l_timing.c
@@ -0,0 +1,1385 @@
+/*
+ * Copyright 2018-2019 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <linux/kernel.h>
+#include <common.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/imx8m_ddr.h>
+
+struct dram_cfg_param ddr3l_ddrc_cfg[] = {
+	{ DDRC_MSTR(0), 0xa3040001 },
+	{ DDRC_PWRCTL(0), 0x000000a8 },
+	{ DDRC_PWRTMG(0), 0x00532203 },
+	{ DDRC_RFSHCTL0(0), 0x00203020 },
+	{ DDRC_RFSHCTL1(0), 0x0001000d },
+	{ DDRC_RFSHCTL3(0), 0x00000000 },
+	{ DDRC_RFSHTMG(0), 0x0061008c },
+	{ DDRC_CRCPARCTL0(0), 0x00000000 },
+	{ DDRC_CRCPARCTL1(0), 0x00000000 },
+	{ DDRC_INIT0(0), 0xc0030002 },
+	{ DDRC_INIT1(0), 0x0001000b },
+	{ DDRC_INIT2(0), 0x00006303 },
+	{ DDRC_INIT3(0), 0x0d700004 },/* MR1, MR0 */
+	{ DDRC_INIT4(0), 0x00180000 },/* MR2 */
+	{ DDRC_INIT5(0), 0x00090071 },
+	{ DDRC_INIT6(0), 0x00000000 },
+	{ DDRC_INIT7(0), 0x00000000 },
+	{ DDRC_DIMMCTL(0), 0x00000032 }, /* [1] dimm_addr_mirr_en, it will effect the MRS if use umctl2 to initi dram. */
+	{ DDRC_RANKCTL(0), 0x00000ee5 },
+	{ DDRC_DRAMTMG0(0), 0x0c101a0e },
+	{ DDRC_DRAMTMG1(0), 0x000a0314 },
+	{ DDRC_DRAMTMG2(0), 0x04060509 },
+	{ DDRC_DRAMTMG3(0), 0x00002006 },
+	{ DDRC_DRAMTMG4(0), 0x06020306 },
+	{ DDRC_DRAMTMG5(0), 0x0b060202 },
+	{ DDRC_DRAMTMG6(0), 0x060a0009 },
+	{ DDRC_DRAMTMG7(0), 0x0000060b },
+	{ DDRC_DRAMTMG8(0), 0x01017c0a },
+	{ DDRC_DRAMTMG9(0), 0x4000000e },
+	{ DDRC_DRAMTMG10(0), 0x00070803 },
+	{ DDRC_DRAMTMG11(0), 0x0101000b },
+	{ DDRC_DRAMTMG12(0), 0x00000000 },
+	{ DDRC_DRAMTMG13(0), 0x5d000000 },
+	{ DDRC_DRAMTMG14(0), 0x00000b39 },
+	{ DDRC_DRAMTMG15(0), 0x80000000 },
+	{ DDRC_DRAMTMG17(0), 0x00f1006a },
+	{ DDRC_ZQCTL0(0), 0x50800020 },
+	{ DDRC_ZQCTL1(0), 0x00000070 },
+	{ DDRC_ZQCTL2(0), 0x00000000 },
+	{ DDRC_DFITMG0(0), 0x03868203 },
+	{ DDRC_DFITMG1(0), 0x00020103 },
+	{ DDRC_DFILPCFG0(0), 0x07713021 },
+	{ DDRC_DFILPCFG1(0), 0x00000010 },
+	{ DDRC_DFIUPD0(0), 0xe0400018 },
+	{ DDRC_DFIUPD1(0), 0x0005003c },
+	{ DDRC_DFIUPD2(0), 0x80000000 },
+	{ DDRC_DFIMISC(0), 0x00000001 },
+	{ DDRC_DFITMG2(0), 0x00000603 },
+	{ DDRC_DFITMG3(0), 0x00000001 },
+	{ DDRC_DBICTL(0), 0x00000001 },
+	{ DDRC_DFIPHYMSTR(0), 0x00000000 },
+
+	{ DDRC_ADDRMAP0(0), 0x00000016 }, /* [4:0] cs-bit0: 6+22=28; [12:8] cs-bit1: 7+0 */
+	{ DDRC_ADDRMAP1(0), 0x00080808 }, /* [5:0] bank b0: 2+8; [13:8] b1: P3+8 ; [21:16] b2: 4+8 */
+	{ DDRC_ADDRMAP2(0), 0x00000000 }, /* [3:0] col-b2: 2;  [11:8] col-b3: 3; [19:16] col-b4: 4 ; [27:24] col-b5: 5 */
+	{ DDRC_ADDRMAP3(0), 0x00000000 }, /* [3:0] col-b6: 6;  [11:8] col-b7: 7; [19:16] col-b8: 8 ; [27:24] col-b9: 9 */
+	{ DDRC_ADDRMAP4(0), 0x00001f1f }, /* col-b10, col-b11 not used */
+	{ DDRC_ADDRMAP5(0), 0x07070707 }, /* [3:0] row-b0: 6;  [11:8] row-b1: 7; [19:16] row-b2_b10 ; [27:24] row-b11: 17 */
+	{ DDRC_ADDRMAP6(0), 0x0f070707 }, /* [3:0] row-b12:18; [11:8] row-b13: 19; [19:16] row-b14:20 */
+	{ DDRC_ADDRMAP7(0), 0x00000f0f },
+	{ DDRC_ADDRMAP8(0), 0x00000000 }, /* [5:0] bg-b0; [13:8]bg-b1 */
+	{ DDRC_ADDRMAP9(0), 0x0a020b06 }, /*  it's valid only when ADDRMAP5.addrmap_row_b2_10 is set to value 15 */
+	{ DDRC_ADDRMAP10(0), 0x0a0a0a0a },/*  it's valid only when ADDRMAP5.addrmap_row_b2_10 is set to value 15 */
+	{ DDRC_ADDRMAP11(0), 0x00000000 },
+
+	{ DDRC_ODTCFG(0), 0x041d0f5c },
+	{ DDRC_ODTMAP(0), 0x00000201 },
+	{ DDRC_SCHED(0), 0x7ab50b07 },
+	{ DDRC_SCHED1(0), 0x00000022 },
+	{ DDRC_PERFHPR1(0), 0x7b00665e },
+	{ DDRC_PERFLPR1(0), 0x2b00c4e1 },
+	{ DDRC_PERFWR1(0), 0xb700c9fe },
+	{ DDRC_DBG0(0), 0x00000017 },
+	{ DDRC_DBG1(0), 0x00000000 },
+	{ DDRC_DBGCMD(0), 0x00000000 },
+	{ DDRC_SWCTL(0), 0x00000001 },
+	{ DDRC_POISONCFG(0), 0x00010000 },
+	{ DDRC_PCCFG(0), 0x00000100 },
+	{ DDRC_PCFGR_0(0), 0x00003051 },
+	{ DDRC_PCFGW_0(0), 0x000061d2 },
+	{ DDRC_PCTRL_0(0), 0x00000001 },
+	{ DDRC_PCFGQOS0_0(0), 0x02100b04 },
+	{ DDRC_PCFGQOS1_0(0), 0x003f0353 },
+	{ DDRC_PCFGWQOS0_0(0), 0x00000002 },
+	{ DDRC_PCFGWQOS1_0(0), 0x000005fd },
+
+	{ DDRC_FREQ1_RFSHCTL0(0), 0x00d19034 },
+	{ DDRC_FREQ1_RFSHTMG(0), 0x0040805e },
+	{ DDRC_FREQ1_INIT3(0), 0x09300004 },
+	{ DDRC_FREQ1_INIT4(0), 0x00080000 },
+	{ DDRC_FREQ1_INIT6(0), 0x00000000 },
+	{ DDRC_FREQ1_INIT7(0), 0x00000000 },
+	{ DDRC_FREQ1_DRAMTMG0(0), 0x090e110a },
+	{ DDRC_FREQ1_DRAMTMG1(0), 0x0007020e },
+	{ DDRC_FREQ1_DRAMTMG2(0), 0x03040407 },
+	{ DDRC_FREQ1_DRAMTMG3(0), 0x00002006 },
+	{ DDRC_FREQ1_DRAMTMG4(0), 0x04020304 }, /*  tRP=6 --> 7 */
+	{ DDRC_FREQ1_DRAMTMG5(0), 0x09030202 },
+	{ DDRC_FREQ1_DRAMTMG6(0), 0x0c020000 },
+	{ DDRC_FREQ1_DRAMTMG7(0), 0x00000309 },
+	{ DDRC_FREQ1_DRAMTMG8(0), 0x01010a06 },
+	{ DDRC_FREQ1_DRAMTMG9(0), 0x00000003 },
+	{ DDRC_FREQ1_DRAMTMG10(0), 0x00090906 },
+	{ DDRC_FREQ1_DRAMTMG11(0), 0x01010011 },
+	{ DDRC_FREQ1_DRAMTMG12(0), 0x00000000 },
+	{ DDRC_FREQ1_DRAMTMG13(0), 0x40000000 },
+	{ DDRC_FREQ1_DRAMTMG14(0), 0x000000f3 },
+	{ DDRC_FREQ1_DRAMTMG15(0), 0x80000000 },
+	{ DDRC_FREQ1_DRAMTMG17(0), 0x001a0046 },
+	{ DDRC_FREQ1_ZQCTL0(0),  0x50800020 },
+	{ DDRC_FREQ1_DFITMG0(0), 0x03828201 },
+	{ DDRC_FREQ1_DFITMG1(0), 0x00020103 },
+	{ DDRC_FREQ1_DFITMG2(0), 0x00000201 },
+	{ DDRC_FREQ1_DFITMG3(0), 0x00000001 },
+	{ DDRC_FREQ1_ODTCFG(0),  0x0a1a0768 },
+
+	{ DDRC_FREQ2_RFSHCTL0(0), 0x00208014 },
+	{ DDRC_FREQ2_RFSHTMG(0), 0x00308046 },
+	{ DDRC_FREQ2_INIT3(0), 0x05200004 },
+	{ DDRC_FREQ2_INIT4(0), 0x00000000 },
+	{ DDRC_FREQ2_INIT6(0), 0x00000000 },
+	{ DDRC_FREQ2_INIT7(0), 0x00000000 },
+	{ DDRC_FREQ2_DRAMTMG0(0), 0x070a0c07 },
+	{ DDRC_FREQ2_DRAMTMG1(0), 0x0005020b },
+	{ DDRC_FREQ2_DRAMTMG2(0), 0x03030407 },
+	{ DDRC_FREQ2_DRAMTMG3(0), 0x00002006 },
+	{ DDRC_FREQ2_DRAMTMG4(0), 0x03020204 },
+	{ DDRC_FREQ2_DRAMTMG5(0), 0x04070302 },
+	{ DDRC_FREQ2_DRAMTMG6(0), 0x07080000 },
+	{ DDRC_FREQ2_DRAMTMG7(0), 0x00000704 },
+	{ DDRC_FREQ2_DRAMTMG8(0), 0x02026804 },
+	{ DDRC_FREQ2_DRAMTMG9(0), 0x40000006 },
+	{ DDRC_FREQ2_DRAMTMG10(0), 0x000c0b08 },
+	{ DDRC_FREQ2_DRAMTMG11(0), 0x01010015 },
+	{ DDRC_FREQ2_DRAMTMG12(0), 0x00000000 },
+	{ DDRC_FREQ2_DRAMTMG13(0), 0x51000000 },
+	{ DDRC_FREQ2_DRAMTMG14(0), 0x000002a0 },
+	{ DDRC_FREQ2_DRAMTMG15(0), 0x00000000 },
+	{ DDRC_FREQ2_DRAMTMG17(0), 0x008c0039 },
+	{ DDRC_FREQ2_ZQCTL0(0), 0x50800020 },
+	{ DDRC_FREQ2_DFITMG0(0), 0x03818200 },
+	{ DDRC_FREQ2_DFITMG1(0), 0x00020103 },
+	{ DDRC_FREQ2_DFITMG2(0), 0x00000100 },
+	{ DDRC_FREQ2_DFITMG3(0), 0x00000001 },
+	{ DDRC_FREQ2_ODTCFG(0), 0x04050800 },
+
+	/* default start freq point */
+	{ DDRC_MSTR2(0), 0x0},
+};
+
+/* PHY Initialize Configuration */
+struct dram_cfg_param ddr3l_ddrphy_cfg[] = {
+	{ 0x1005f, 0x3cf },
+	{ 0x1015f, 0x3cf },
+	{ 0x1105f, 0x3cf },
+	{ 0x1115f, 0x3cf },
+	{ 0x1205f, 0x3cf },
+	{ 0x1215f, 0x3cf },
+	{ 0x1305f, 0x3cf },
+	{ 0x1315f, 0x3cf },
+
+	{ 0x11005f, 0x3cf },
+	{ 0x11015f, 0x3cf },
+	{ 0x11105f, 0x3cf },
+	{ 0x11115f, 0x3cf },
+	{ 0x11205f, 0x3cf },
+	{ 0x11215f, 0x3cf },
+	{ 0x11305f, 0x3cf },
+	{ 0x11315f, 0x3cf },
+
+	{ 0x21005f, 0x3cf },
+	{ 0x21015f, 0x3cf },
+	{ 0x21105f, 0x3cf },
+	{ 0x21115f, 0x3cf },
+	{ 0x21205f, 0x3cf },
+	{ 0x21215f, 0x3cf },
+	{ 0x21305f, 0x3cf },
+	{ 0x21315f, 0x3cf },
+
+	{ 0x55, 0x365 },
+	{ 0x1055, 0x365 },
+	{ 0x2055, 0x365 },
+	{ 0x3055, 0x365 },
+	{ 0x4055, 0x65 },
+	{ 0x5055, 0x65 },
+	{ 0x6055, 0x365 },
+	{ 0x7055, 0x365 },
+	{ 0x8055, 0x365 },
+	{ 0x9055, 0x365 },
+	{ 0x200c5, 0xb },
+	{ 0x1200c5, 0x7 },
+	{ 0x2200c5, 0x7 },
+	{ 0x2002e, 0x1 },
+	{ 0x12002e, 0x1 },
+	{ 0x22002e, 0x1 },
+	{ 0x20024, 0x8 },
+	{ 0x2003a, 0x0 },
+	{ 0x120024, 0x8 },
+	{ 0x2003a, 0x0 },
+	{ 0x220024, 0x8 },
+	{ 0x2003a, 0x0 },
+	{ 0x20056, 0xa },
+	{ 0x120056, 0xa },
+	{ 0x220056, 0xa },
+	{ 0x1004d, 0x618 },
+	{ 0x1014d, 0x618 },
+	{ 0x1104d, 0x618 },
+	{ 0x1114d, 0x618 },
+	{ 0x1204d, 0x618 },
+	{ 0x1214d, 0x618 },
+	{ 0x1304d, 0x618 },
+	{ 0x1314d, 0x618 },
+	{ 0x11004d, 0x618 },
+	{ 0x11014d, 0x618 },
+	{ 0x11104d, 0x618 },
+	{ 0x11114d, 0x618 },
+	{ 0x11204d, 0x618 },
+	{ 0x11214d, 0x618 },
+	{ 0x11304d, 0x618 },
+	{ 0x11314d, 0x618 },
+	{ 0x21004d, 0x618 },
+	{ 0x21014d, 0x618 },
+	{ 0x21104d, 0x618 },
+	{ 0x21114d, 0x618 },
+	{ 0x21204d, 0x618 },
+	{ 0x21214d, 0x618 },
+	{ 0x21304d, 0x618 },
+	{ 0x21314d, 0x618 },
+	{ 0x10049, 0xe38 },
+	{ 0x10149, 0xe38 },
+	{ 0x11049, 0xe38 },
+	{ 0x11149, 0xe38 },
+	{ 0x12049, 0xe38 },
+	{ 0x12149, 0xe38 },
+	{ 0x13049, 0xe38 },
+	{ 0x13149, 0xe38 },
+	{ 0x110049, 0xe38 },
+	{ 0x110149, 0xe38 },
+	{ 0x111049, 0xe38 },
+	{ 0x111149, 0xe38 },
+	{ 0x112049, 0xe38 },
+	{ 0x112149, 0xe38 },
+	{ 0x113049, 0xe38 },
+	{ 0x113149, 0xe38 },
+	{ 0x210049, 0xe38 },
+	{ 0x210149, 0xe38 },
+	{ 0x211049, 0xe38 },
+	{ 0x211149, 0xe38 },
+	{ 0x212049, 0xe38 },
+	{ 0x212149, 0xe38 },
+	{ 0x213049, 0xe38 },
+	{ 0x213149, 0xe38 },
+	{ 0x43, 0x63 },
+	{ 0x1043, 0x63 },
+	{ 0x2043, 0x63 },
+	{ 0x3043, 0x63 },
+	{ 0x4043, 0x63 },
+	{ 0x5043, 0x63 },
+	{ 0x6043, 0x63 },
+	{ 0x7043, 0x63 },
+	{ 0x8043, 0x63 },
+	{ 0x9043, 0x63 },
+	{ 0x20018, 0x5 },
+	{ 0x20075, 0x0 },
+	{ 0x20050, 0x0 },
+	{ 0x20008, 0x190 },
+	{ 0x120008, 0x85 },
+	{ 0x220008, 0x53 },
+	{ 0x20088, 0x9 },
+	{ 0x200b2, 0xf8 },
+	{ 0x10043, 0x581 },
+	{ 0x10143, 0x581 },
+	{ 0x11043, 0x581 },
+	{ 0x11143, 0x581 },
+	{ 0x12043, 0x581 },
+	{ 0x12143, 0x581 },
+	{ 0x13043, 0x581 },
+	{ 0x13143, 0x581 },
+	{ 0x1200b2, 0xf8 },
+	{ 0x110043, 0x581 },
+	{ 0x110143, 0x581 },
+	{ 0x111043, 0x581 },
+	{ 0x111143, 0x581 },
+	{ 0x112043, 0x581 },
+	{ 0x112143, 0x581 },
+	{ 0x113043, 0x581 },
+	{ 0x113143, 0x581 },
+	{ 0x2200b2, 0xf8 },
+	{ 0x210043, 0x581 },
+	{ 0x210143, 0x581 },
+	{ 0x211043, 0x581 },
+	{ 0x211143, 0x581 },
+	{ 0x212043, 0x581 },
+	{ 0x212143, 0x581 },
+	{ 0x213043, 0x581 },
+	{ 0x213143, 0x581 },
+	{ 0x200fa, 0x1 },
+	{ 0x1200fa, 0x1 },
+	{ 0x2200fa, 0x1 },
+	{ 0x20019, 0x5 },
+	{ 0x120019, 0x5 },
+	{ 0x220019, 0x5 },
+	{ 0x200f0, 0x5555 },
+	{ 0x200f1, 0x5555 },
+	{ 0x200f2, 0x5555 },
+	{ 0x200f3, 0x5555 },
+	{ 0x200f4, 0x5555 },
+	{ 0x200f5, 0x5555 },
+	{ 0x200f6, 0x5555 },
+	{ 0x200f7, 0xf000 },
+	{ 0x20025, 0x0 },
+	{ 0x20060, 0x2 },
+};
+
+/* ddr phy trained CSR */
+struct dram_cfg_param ddr3l_ddrphy_trained_csr[] = {
+	{ 0x200b2, 0x0 },
+	{ 0x1200b2, 0x0 },
+	{ 0x2200b2, 0x0 },
+	{ 0x200cb, 0x0 },
+	{ 0x10043, 0x0 },
+	{ 0x110043, 0x0 },
+	{ 0x210043, 0x0 },
+	{ 0x10143, 0x0 },
+	{ 0x110143, 0x0 },
+	{ 0x210143, 0x0 },
+	{ 0x11043, 0x0 },
+	{ 0x111043, 0x0 },
+	{ 0x211043, 0x0 },
+	{ 0x11143, 0x0 },
+	{ 0x111143, 0x0 },
+	{ 0x211143, 0x0 },
+	{ 0x12043, 0x0 },
+	{ 0x112043, 0x0 },
+	{ 0x212043, 0x0 },
+	{ 0x12143, 0x0 },
+	{ 0x112143, 0x0 },
+	{ 0x212143, 0x0 },
+	{ 0x13043, 0x0 },
+	{ 0x113043, 0x0 },
+	{ 0x213043, 0x0 },
+	{ 0x13143, 0x0 },
+	{ 0x113143, 0x0 },
+	{ 0x213143, 0x0 },
+	{ 0x80, 0x0 },
+	{ 0x100080, 0x0 },
+	{ 0x200080, 0x0 },
+	{ 0x1080, 0x0 },
+	{ 0x101080, 0x0 },
+	{ 0x201080, 0x0 },
+	{ 0x2080, 0x0 },
+	{ 0x102080, 0x0 },
+	{ 0x202080, 0x0 },
+	{ 0x3080, 0x0 },
+	{ 0x103080, 0x0 },
+	{ 0x203080, 0x0 },
+	{ 0x4080, 0x0 },
+	{ 0x104080, 0x0 },
+	{ 0x204080, 0x0 },
+	{ 0x5080, 0x0 },
+	{ 0x105080, 0x0 },
+	{ 0x205080, 0x0 },
+	{ 0x6080, 0x0 },
+	{ 0x106080, 0x0 },
+	{ 0x206080, 0x0 },
+	{ 0x7080, 0x0 },
+	{ 0x107080, 0x0 },
+	{ 0x207080, 0x0 },
+	{ 0x8080, 0x0 },
+	{ 0x108080, 0x0 },
+	{ 0x208080, 0x0 },
+	{ 0x9080, 0x0 },
+	{ 0x109080, 0x0 },
+	{ 0x209080, 0x0 },
+	{ 0x10080, 0x0 },
+	{ 0x110080, 0x0 },
+	{ 0x210080, 0x0 },
+	{ 0x10180, 0x0 },
+	{ 0x110180, 0x0 },
+	{ 0x210180, 0x0 },
+	{ 0x11080, 0x0 },
+	{ 0x111080, 0x0 },
+	{ 0x211080, 0x0 },
+	{ 0x11180, 0x0 },
+	{ 0x111180, 0x0 },
+	{ 0x211180, 0x0 },
+	{ 0x12080, 0x0 },
+	{ 0x112080, 0x0 },
+	{ 0x212080, 0x0 },
+	{ 0x12180, 0x0 },
+	{ 0x112180, 0x0 },
+	{ 0x212180, 0x0 },
+	{ 0x13080, 0x0 },
+	{ 0x113080, 0x0 },
+	{ 0x213080, 0x0 },
+	{ 0x13180, 0x0 },
+	{ 0x113180, 0x0 },
+	{ 0x213180, 0x0 },
+	{ 0x10081, 0x0 },
+	{ 0x110081, 0x0 },
+	{ 0x210081, 0x0 },
+	{ 0x10181, 0x0 },
+	{ 0x110181, 0x0 },
+	{ 0x210181, 0x0 },
+	{ 0x11081, 0x0 },
+	{ 0x111081, 0x0 },
+	{ 0x211081, 0x0 },
+	{ 0x11181, 0x0 },
+	{ 0x111181, 0x0 },
+	{ 0x211181, 0x0 },
+	{ 0x12081, 0x0 },
+	{ 0x112081, 0x0 },
+	{ 0x212081, 0x0 },
+	{ 0x12181, 0x0 },
+	{ 0x112181, 0x0 },
+	{ 0x212181, 0x0 },
+	{ 0x13081, 0x0 },
+	{ 0x113081, 0x0 },
+	{ 0x213081, 0x0 },
+	{ 0x13181, 0x0 },
+	{ 0x113181, 0x0 },
+	{ 0x213181, 0x0 },
+	{ 0x100d0, 0x0 },
+	{ 0x1100d0, 0x0 },
+	{ 0x2100d0, 0x0 },
+	{ 0x101d0, 0x0 },
+	{ 0x1101d0, 0x0 },
+	{ 0x2101d0, 0x0 },
+	{ 0x110d0, 0x0 },
+	{ 0x1110d0, 0x0 },
+	{ 0x2110d0, 0x0 },
+	{ 0x111d0, 0x0 },
+	{ 0x1111d0, 0x0 },
+	{ 0x2111d0, 0x0 },
+	{ 0x120d0, 0x0 },
+	{ 0x1120d0, 0x0 },
+	{ 0x2120d0, 0x0 },
+	{ 0x121d0, 0x0 },
+	{ 0x1121d0, 0x0 },
+	{ 0x2121d0, 0x0 },
+	{ 0x130d0, 0x0 },
+	{ 0x1130d0, 0x0 },
+	{ 0x2130d0, 0x0 },
+	{ 0x131d0, 0x0 },
+	{ 0x1131d0, 0x0 },
+	{ 0x2131d0, 0x0 },
+	{ 0x100d1, 0x0 },
+	{ 0x1100d1, 0x0 },
+	{ 0x2100d1, 0x0 },
+	{ 0x101d1, 0x0 },
+	{ 0x1101d1, 0x0 },
+	{ 0x2101d1, 0x0 },
+	{ 0x110d1, 0x0 },
+	{ 0x1110d1, 0x0 },
+	{ 0x2110d1, 0x0 },
+	{ 0x111d1, 0x0 },
+	{ 0x1111d1, 0x0 },
+	{ 0x2111d1, 0x0 },
+	{ 0x120d1, 0x0 },
+	{ 0x1120d1, 0x0 },
+	{ 0x2120d1, 0x0 },
+	{ 0x121d1, 0x0 },
+	{ 0x1121d1, 0x0 },
+	{ 0x2121d1, 0x0 },
+	{ 0x130d1, 0x0 },
+	{ 0x1130d1, 0x0 },
+	{ 0x2130d1, 0x0 },
+	{ 0x131d1, 0x0 },
+	{ 0x1131d1, 0x0 },
+	{ 0x2131d1, 0x0 },
+	{ 0x10068, 0x0 },
+	{ 0x10168, 0x0 },
+	{ 0x10268, 0x0 },
+	{ 0x10368, 0x0 },
+	{ 0x10468, 0x0 },
+	{ 0x10568, 0x0 },
+	{ 0x10668, 0x0 },
+	{ 0x10768, 0x0 },
+	{ 0x10868, 0x0 },
+	{ 0x11068, 0x0 },
+	{ 0x11168, 0x0 },
+	{ 0x11268, 0x0 },
+	{ 0x11368, 0x0 },
+	{ 0x11468, 0x0 },
+	{ 0x11568, 0x0 },
+	{ 0x11668, 0x0 },
+	{ 0x11768, 0x0 },
+	{ 0x11868, 0x0 },
+	{ 0x12068, 0x0 },
+	{ 0x12168, 0x0 },
+	{ 0x12268, 0x0 },
+	{ 0x12368, 0x0 },
+	{ 0x12468, 0x0 },
+	{ 0x12568, 0x0 },
+	{ 0x12668, 0x0 },
+	{ 0x12768, 0x0 },
+	{ 0x12868, 0x0 },
+	{ 0x13068, 0x0 },
+	{ 0x13168, 0x0 },
+	{ 0x13268, 0x0 },
+	{ 0x13368, 0x0 },
+	{ 0x13468, 0x0 },
+	{ 0x13568, 0x0 },
+	{ 0x13668, 0x0 },
+	{ 0x13768, 0x0 },
+	{ 0x13868, 0x0 },
+	{ 0x10069, 0x0 },
+	{ 0x10169, 0x0 },
+	{ 0x10269, 0x0 },
+	{ 0x10369, 0x0 },
+	{ 0x10469, 0x0 },
+	{ 0x10569, 0x0 },
+	{ 0x10669, 0x0 },
+	{ 0x10769, 0x0 },
+	{ 0x10869, 0x0 },
+	{ 0x11069, 0x0 },
+	{ 0x11169, 0x0 },
+	{ 0x11269, 0x0 },
+	{ 0x11369, 0x0 },
+	{ 0x11469, 0x0 },
+	{ 0x11569, 0x0 },
+	{ 0x11669, 0x0 },
+	{ 0x11769, 0x0 },
+	{ 0x11869, 0x0 },
+	{ 0x12069, 0x0 },
+	{ 0x12169, 0x0 },
+	{ 0x12269, 0x0 },
+	{ 0x12369, 0x0 },
+	{ 0x12469, 0x0 },
+	{ 0x12569, 0x0 },
+	{ 0x12669, 0x0 },
+	{ 0x12769, 0x0 },
+	{ 0x12869, 0x0 },
+	{ 0x13069, 0x0 },
+	{ 0x13169, 0x0 },
+	{ 0x13269, 0x0 },
+	{ 0x13369, 0x0 },
+	{ 0x13469, 0x0 },
+	{ 0x13569, 0x0 },
+	{ 0x13669, 0x0 },
+	{ 0x13769, 0x0 },
+	{ 0x13869, 0x0 },
+	{ 0x1008c, 0x0 },
+	{ 0x11008c, 0x0 },
+	{ 0x21008c, 0x0 },
+	{ 0x1018c, 0x0 },
+	{ 0x11018c, 0x0 },
+	{ 0x21018c, 0x0 },
+	{ 0x1108c, 0x0 },
+	{ 0x11108c, 0x0 },
+	{ 0x21108c, 0x0 },
+	{ 0x1118c, 0x0 },
+	{ 0x11118c, 0x0 },
+	{ 0x21118c, 0x0 },
+	{ 0x1208c, 0x0 },
+	{ 0x11208c, 0x0 },
+	{ 0x21208c, 0x0 },
+	{ 0x1218c, 0x0 },
+	{ 0x11218c, 0x0 },
+	{ 0x21218c, 0x0 },
+	{ 0x1308c, 0x0 },
+	{ 0x11308c, 0x0 },
+	{ 0x21308c, 0x0 },
+	{ 0x1318c, 0x0 },
+	{ 0x11318c, 0x0 },
+	{ 0x21318c, 0x0 },
+	{ 0x1008d, 0x0 },
+	{ 0x11008d, 0x0 },
+	{ 0x21008d, 0x0 },
+	{ 0x1018d, 0x0 },
+	{ 0x11018d, 0x0 },
+	{ 0x21018d, 0x0 },
+	{ 0x1108d, 0x0 },
+	{ 0x11108d, 0x0 },
+	{ 0x21108d, 0x0 },
+	{ 0x1118d, 0x0 },
+	{ 0x11118d, 0x0 },
+	{ 0x21118d, 0x0 },
+	{ 0x1208d, 0x0 },
+	{ 0x11208d, 0x0 },
+	{ 0x21208d, 0x0 },
+	{ 0x1218d, 0x0 },
+	{ 0x11218d, 0x0 },
+	{ 0x21218d, 0x0 },
+	{ 0x1308d, 0x0 },
+	{ 0x11308d, 0x0 },
+	{ 0x21308d, 0x0 },
+	{ 0x1318d, 0x0 },
+	{ 0x11318d, 0x0 },
+	{ 0x21318d, 0x0 },
+	{ 0x100c0, 0x0 },
+	{ 0x1100c0, 0x0 },
+	{ 0x2100c0, 0x0 },
+	{ 0x101c0, 0x0 },
+	{ 0x1101c0, 0x0 },
+	{ 0x2101c0, 0x0 },
+	{ 0x102c0, 0x0 },
+	{ 0x1102c0, 0x0 },
+	{ 0x2102c0, 0x0 },
+	{ 0x103c0, 0x0 },
+	{ 0x1103c0, 0x0 },
+	{ 0x2103c0, 0x0 },
+	{ 0x104c0, 0x0 },
+	{ 0x1104c0, 0x0 },
+	{ 0x2104c0, 0x0 },
+	{ 0x105c0, 0x0 },
+	{ 0x1105c0, 0x0 },
+	{ 0x2105c0, 0x0 },
+	{ 0x106c0, 0x0 },
+	{ 0x1106c0, 0x0 },
+	{ 0x2106c0, 0x0 },
+	{ 0x107c0, 0x0 },
+	{ 0x1107c0, 0x0 },
+	{ 0x2107c0, 0x0 },
+	{ 0x108c0, 0x0 },
+	{ 0x1108c0, 0x0 },
+	{ 0x2108c0, 0x0 },
+	{ 0x110c0, 0x0 },
+	{ 0x1110c0, 0x0 },
+	{ 0x2110c0, 0x0 },
+	{ 0x111c0, 0x0 },
+	{ 0x1111c0, 0x0 },
+	{ 0x2111c0, 0x0 },
+	{ 0x112c0, 0x0 },
+	{ 0x1112c0, 0x0 },
+	{ 0x2112c0, 0x0 },
+	{ 0x113c0, 0x0 },
+	{ 0x1113c0, 0x0 },
+	{ 0x2113c0, 0x0 },
+	{ 0x114c0, 0x0 },
+	{ 0x1114c0, 0x0 },
+	{ 0x2114c0, 0x0 },
+	{ 0x115c0, 0x0 },
+	{ 0x1115c0, 0x0 },
+	{ 0x2115c0, 0x0 },
+	{ 0x116c0, 0x0 },
+	{ 0x1116c0, 0x0 },
+	{ 0x2116c0, 0x0 },
+	{ 0x117c0, 0x0 },
+	{ 0x1117c0, 0x0 },
+	{ 0x2117c0, 0x0 },
+	{ 0x118c0, 0x0 },
+	{ 0x1118c0, 0x0 },
+	{ 0x2118c0, 0x0 },
+	{ 0x120c0, 0x0 },
+	{ 0x1120c0, 0x0 },
+	{ 0x2120c0, 0x0 },
+	{ 0x121c0, 0x0 },
+	{ 0x1121c0, 0x0 },
+	{ 0x2121c0, 0x0 },
+	{ 0x122c0, 0x0 },
+	{ 0x1122c0, 0x0 },
+	{ 0x2122c0, 0x0 },
+	{ 0x123c0, 0x0 },
+	{ 0x1123c0, 0x0 },
+	{ 0x2123c0, 0x0 },
+	{ 0x124c0, 0x0 },
+	{ 0x1124c0, 0x0 },
+	{ 0x2124c0, 0x0 },
+	{ 0x125c0, 0x0 },
+	{ 0x1125c0, 0x0 },
+	{ 0x2125c0, 0x0 },
+	{ 0x126c0, 0x0 },
+	{ 0x1126c0, 0x0 },
+	{ 0x2126c0, 0x0 },
+	{ 0x127c0, 0x0 },
+	{ 0x1127c0, 0x0 },
+	{ 0x2127c0, 0x0 },
+	{ 0x128c0, 0x0 },
+	{ 0x1128c0, 0x0 },
+	{ 0x2128c0, 0x0 },
+	{ 0x130c0, 0x0 },
+	{ 0x1130c0, 0x0 },
+	{ 0x2130c0, 0x0 },
+	{ 0x131c0, 0x0 },
+	{ 0x1131c0, 0x0 },
+	{ 0x2131c0, 0x0 },
+	{ 0x132c0, 0x0 },
+	{ 0x1132c0, 0x0 },
+	{ 0x2132c0, 0x0 },
+	{ 0x133c0, 0x0 },
+	{ 0x1133c0, 0x0 },
+	{ 0x2133c0, 0x0 },
+	{ 0x134c0, 0x0 },
+	{ 0x1134c0, 0x0 },
+	{ 0x2134c0, 0x0 },
+	{ 0x135c0, 0x0 },
+	{ 0x1135c0, 0x0 },
+	{ 0x2135c0, 0x0 },
+	{ 0x136c0, 0x0 },
+	{ 0x1136c0, 0x0 },
+	{ 0x2136c0, 0x0 },
+	{ 0x137c0, 0x0 },
+	{ 0x1137c0, 0x0 },
+	{ 0x2137c0, 0x0 },
+	{ 0x138c0, 0x0 },
+	{ 0x1138c0, 0x0 },
+	{ 0x2138c0, 0x0 },
+	{ 0x100c1, 0x0 },
+	{ 0x1100c1, 0x0 },
+	{ 0x2100c1, 0x0 },
+	{ 0x101c1, 0x0 },
+	{ 0x1101c1, 0x0 },
+	{ 0x2101c1, 0x0 },
+	{ 0x102c1, 0x0 },
+	{ 0x1102c1, 0x0 },
+	{ 0x2102c1, 0x0 },
+	{ 0x103c1, 0x0 },
+	{ 0x1103c1, 0x0 },
+	{ 0x2103c1, 0x0 },
+	{ 0x104c1, 0x0 },
+	{ 0x1104c1, 0x0 },
+	{ 0x2104c1, 0x0 },
+	{ 0x105c1, 0x0 },
+	{ 0x1105c1, 0x0 },
+	{ 0x2105c1, 0x0 },
+	{ 0x106c1, 0x0 },
+	{ 0x1106c1, 0x0 },
+	{ 0x2106c1, 0x0 },
+	{ 0x107c1, 0x0 },
+	{ 0x1107c1, 0x0 },
+	{ 0x2107c1, 0x0 },
+	{ 0x108c1, 0x0 },
+	{ 0x1108c1, 0x0 },
+	{ 0x2108c1, 0x0 },
+	{ 0x110c1, 0x0 },
+	{ 0x1110c1, 0x0 },
+	{ 0x2110c1, 0x0 },
+	{ 0x111c1, 0x0 },
+	{ 0x1111c1, 0x0 },
+	{ 0x2111c1, 0x0 },
+	{ 0x112c1, 0x0 },
+	{ 0x1112c1, 0x0 },
+	{ 0x2112c1, 0x0 },
+	{ 0x113c1, 0x0 },
+	{ 0x1113c1, 0x0 },
+	{ 0x2113c1, 0x0 },
+	{ 0x114c1, 0x0 },
+	{ 0x1114c1, 0x0 },
+	{ 0x2114c1, 0x0 },
+	{ 0x115c1, 0x0 },
+	{ 0x1115c1, 0x0 },
+	{ 0x2115c1, 0x0 },
+	{ 0x116c1, 0x0 },
+	{ 0x1116c1, 0x0 },
+	{ 0x2116c1, 0x0 },
+	{ 0x117c1, 0x0 },
+	{ 0x1117c1, 0x0 },
+	{ 0x2117c1, 0x0 },
+	{ 0x118c1, 0x0 },
+	{ 0x1118c1, 0x0 },
+	{ 0x2118c1, 0x0 },
+	{ 0x120c1, 0x0 },
+	{ 0x1120c1, 0x0 },
+	{ 0x2120c1, 0x0 },
+	{ 0x121c1, 0x0 },
+	{ 0x1121c1, 0x0 },
+	{ 0x2121c1, 0x0 },
+	{ 0x122c1, 0x0 },
+	{ 0x1122c1, 0x0 },
+	{ 0x2122c1, 0x0 },
+	{ 0x123c1, 0x0 },
+	{ 0x1123c1, 0x0 },
+	{ 0x2123c1, 0x0 },
+	{ 0x124c1, 0x0 },
+	{ 0x1124c1, 0x0 },
+	{ 0x2124c1, 0x0 },
+	{ 0x125c1, 0x0 },
+	{ 0x1125c1, 0x0 },
+	{ 0x2125c1, 0x0 },
+	{ 0x126c1, 0x0 },
+	{ 0x1126c1, 0x0 },
+	{ 0x2126c1, 0x0 },
+	{ 0x127c1, 0x0 },
+	{ 0x1127c1, 0x0 },
+	{ 0x2127c1, 0x0 },
+	{ 0x128c1, 0x0 },
+	{ 0x1128c1, 0x0 },
+	{ 0x2128c1, 0x0 },
+	{ 0x130c1, 0x0 },
+	{ 0x1130c1, 0x0 },
+	{ 0x2130c1, 0x0 },
+	{ 0x131c1, 0x0 },
+	{ 0x1131c1, 0x0 },
+	{ 0x2131c1, 0x0 },
+	{ 0x132c1, 0x0 },
+	{ 0x1132c1, 0x0 },
+	{ 0x2132c1, 0x0 },
+	{ 0x133c1, 0x0 },
+	{ 0x1133c1, 0x0 },
+	{ 0x2133c1, 0x0 },
+	{ 0x134c1, 0x0 },
+	{ 0x1134c1, 0x0 },
+	{ 0x2134c1, 0x0 },
+	{ 0x135c1, 0x0 },
+	{ 0x1135c1, 0x0 },
+	{ 0x2135c1, 0x0 },
+	{ 0x136c1, 0x0 },
+	{ 0x1136c1, 0x0 },
+	{ 0x2136c1, 0x0 },
+	{ 0x137c1, 0x0 },
+	{ 0x1137c1, 0x0 },
+	{ 0x2137c1, 0x0 },
+	{ 0x138c1, 0x0 },
+	{ 0x1138c1, 0x0 },
+	{ 0x2138c1, 0x0 },
+	{ 0x10020, 0x0 },
+	{ 0x110020, 0x0 },
+	{ 0x210020, 0x0 },
+	{ 0x11020, 0x0 },
+	{ 0x111020, 0x0 },
+	{ 0x211020, 0x0 },
+	{ 0x12020, 0x0 },
+	{ 0x112020, 0x0 },
+	{ 0x212020, 0x0 },
+	{ 0x13020, 0x0 },
+	{ 0x113020, 0x0 },
+	{ 0x213020, 0x0 },
+	{ 0x20072, 0x0 },
+	{ 0x20073, 0x0 },
+	{ 0x20074, 0x0 },
+	{ 0x100aa, 0x0 },
+	{ 0x110aa, 0x0 },
+	{ 0x120aa, 0x0 },
+	{ 0x130aa, 0x0 },
+	{ 0x20010, 0x0 },
+	{ 0x120010, 0x0 },
+	{ 0x220010, 0x0 },
+	{ 0x20011, 0x0 },
+	{ 0x120011, 0x0 },
+	{ 0x220011, 0x0 },
+	{ 0x100ae, 0x0 },
+	{ 0x1100ae, 0x0 },
+	{ 0x2100ae, 0x0 },
+	{ 0x100af, 0x0 },
+	{ 0x1100af, 0x0 },
+	{ 0x2100af, 0x0 },
+	{ 0x110ae, 0x0 },
+	{ 0x1110ae, 0x0 },
+	{ 0x2110ae, 0x0 },
+	{ 0x110af, 0x0 },
+	{ 0x1110af, 0x0 },
+	{ 0x2110af, 0x0 },
+	{ 0x120ae, 0x0 },
+	{ 0x1120ae, 0x0 },
+	{ 0x2120ae, 0x0 },
+	{ 0x120af, 0x0 },
+	{ 0x1120af, 0x0 },
+	{ 0x2120af, 0x0 },
+	{ 0x130ae, 0x0 },
+	{ 0x1130ae, 0x0 },
+	{ 0x2130ae, 0x0 },
+	{ 0x130af, 0x0 },
+	{ 0x1130af, 0x0 },
+	{ 0x2130af, 0x0 },
+	{ 0x20020, 0x0 },
+	{ 0x120020, 0x0 },
+	{ 0x220020, 0x0 },
+	{ 0x100a0, 0x0 },
+	{ 0x100a1, 0x0 },
+	{ 0x100a2, 0x0 },
+	{ 0x100a3, 0x0 },
+	{ 0x100a4, 0x0 },
+	{ 0x100a5, 0x0 },
+	{ 0x100a6, 0x0 },
+	{ 0x100a7, 0x0 },
+	{ 0x110a0, 0x0 },
+	{ 0x110a1, 0x0 },
+	{ 0x110a2, 0x0 },
+	{ 0x110a3, 0x0 },
+	{ 0x110a4, 0x0 },
+	{ 0x110a5, 0x0 },
+	{ 0x110a6, 0x0 },
+	{ 0x110a7, 0x0 },
+	{ 0x120a0, 0x0 },
+	{ 0x120a1, 0x0 },
+	{ 0x120a2, 0x0 },
+	{ 0x120a3, 0x0 },
+	{ 0x120a4, 0x0 },
+	{ 0x120a5, 0x0 },
+	{ 0x120a6, 0x0 },
+	{ 0x120a7, 0x0 },
+	{ 0x130a0, 0x0 },
+	{ 0x130a1, 0x0 },
+	{ 0x130a2, 0x0 },
+	{ 0x130a3, 0x0 },
+	{ 0x130a4, 0x0 },
+	{ 0x130a5, 0x0 },
+	{ 0x130a6, 0x0 },
+	{ 0x130a7, 0x0 },
+	{ 0x2007c, 0x0 },
+	{ 0x12007c, 0x0 },
+	{ 0x22007c, 0x0 },
+	{ 0x2007d, 0x0 },
+	{ 0x12007d, 0x0 },
+	{ 0x22007d, 0x0 },
+	{ 0x400fd, 0x0 },
+	{ 0x400c0, 0x0 },
+	{ 0x90201, 0x0 },
+	{ 0x190201, 0x0 },
+	{ 0x290201, 0x0 },
+	{ 0x90202, 0x0 },
+	{ 0x190202, 0x0 },
+	{ 0x290202, 0x0 },
+	{ 0x90203, 0x0 },
+	{ 0x190203, 0x0 },
+	{ 0x290203, 0x0 },
+	{ 0x90204, 0x0 },
+	{ 0x190204, 0x0 },
+	{ 0x290204, 0x0 },
+	{ 0x90205, 0x0 },
+	{ 0x190205, 0x0 },
+	{ 0x290205, 0x0 },
+	{ 0x90206, 0x0 },
+	{ 0x190206, 0x0 },
+	{ 0x290206, 0x0 },
+	{ 0x90207, 0x0 },
+	{ 0x190207, 0x0 },
+	{ 0x290207, 0x0 },
+	{ 0x90208, 0x0 },
+	{ 0x190208, 0x0 },
+	{ 0x290208, 0x0 },
+	{ 0x10062, 0x0 },
+	{ 0x10162, 0x0 },
+	{ 0x10262, 0x0 },
+	{ 0x10362, 0x0 },
+	{ 0x10462, 0x0 },
+	{ 0x10562, 0x0 },
+	{ 0x10662, 0x0 },
+	{ 0x10762, 0x0 },
+	{ 0x10862, 0x0 },
+	{ 0x11062, 0x0 },
+	{ 0x11162, 0x0 },
+	{ 0x11262, 0x0 },
+	{ 0x11362, 0x0 },
+	{ 0x11462, 0x0 },
+	{ 0x11562, 0x0 },
+	{ 0x11662, 0x0 },
+	{ 0x11762, 0x0 },
+	{ 0x11862, 0x0 },
+	{ 0x12062, 0x0 },
+	{ 0x12162, 0x0 },
+	{ 0x12262, 0x0 },
+	{ 0x12362, 0x0 },
+	{ 0x12462, 0x0 },
+	{ 0x12562, 0x0 },
+	{ 0x12662, 0x0 },
+	{ 0x12762, 0x0 },
+	{ 0x12862, 0x0 },
+	{ 0x13062, 0x0 },
+	{ 0x13162, 0x0 },
+	{ 0x13262, 0x0 },
+	{ 0x13362, 0x0 },
+	{ 0x13462, 0x0 },
+	{ 0x13562, 0x0 },
+	{ 0x13662, 0x0 },
+	{ 0x13762, 0x0 },
+	{ 0x13862, 0x0 },
+	{ 0x20077, 0x0 },
+	{ 0x10001, 0x0 },
+	{ 0x11001, 0x0 },
+	{ 0x12001, 0x0 },
+	{ 0x13001, 0x0 },
+	{ 0x10040, 0x0 },
+	{ 0x10140, 0x0 },
+	{ 0x10240, 0x0 },
+	{ 0x10340, 0x0 },
+	{ 0x10440, 0x0 },
+	{ 0x10540, 0x0 },
+	{ 0x10640, 0x0 },
+	{ 0x10740, 0x0 },
+	{ 0x10840, 0x0 },
+	{ 0x10030, 0x0 },
+	{ 0x10130, 0x0 },
+	{ 0x10230, 0x0 },
+	{ 0x10330, 0x0 },
+	{ 0x10430, 0x0 },
+	{ 0x10530, 0x0 },
+	{ 0x10630, 0x0 },
+	{ 0x10730, 0x0 },
+	{ 0x10830, 0x0 },
+	{ 0x11040, 0x0 },
+	{ 0x11140, 0x0 },
+	{ 0x11240, 0x0 },
+	{ 0x11340, 0x0 },
+	{ 0x11440, 0x0 },
+	{ 0x11540, 0x0 },
+	{ 0x11640, 0x0 },
+	{ 0x11740, 0x0 },
+	{ 0x11840, 0x0 },
+	{ 0x11030, 0x0 },
+	{ 0x11130, 0x0 },
+	{ 0x11230, 0x0 },
+	{ 0x11330, 0x0 },
+	{ 0x11430, 0x0 },
+	{ 0x11530, 0x0 },
+	{ 0x11630, 0x0 },
+	{ 0x11730, 0x0 },
+	{ 0x11830, 0x0 },
+	{ 0x12040, 0x0 },
+	{ 0x12140, 0x0 },
+	{ 0x12240, 0x0 },
+	{ 0x12340, 0x0 },
+	{ 0x12440, 0x0 },
+	{ 0x12540, 0x0 },
+	{ 0x12640, 0x0 },
+	{ 0x12740, 0x0 },
+	{ 0x12840, 0x0 },
+	{ 0x12030, 0x0 },
+	{ 0x12130, 0x0 },
+	{ 0x12230, 0x0 },
+	{ 0x12330, 0x0 },
+	{ 0x12430, 0x0 },
+	{ 0x12530, 0x0 },
+	{ 0x12630, 0x0 },
+	{ 0x12730, 0x0 },
+	{ 0x12830, 0x0 },
+	{ 0x13040, 0x0 },
+	{ 0x13140, 0x0 },
+	{ 0x13240, 0x0 },
+	{ 0x13340, 0x0 },
+	{ 0x13440, 0x0 },
+	{ 0x13540, 0x0 },
+	{ 0x13640, 0x0 },
+	{ 0x13740, 0x0 },
+	{ 0x13840, 0x0 },
+	{ 0x13030, 0x0 },
+	{ 0x13130, 0x0 },
+	{ 0x13230, 0x0 },
+	{ 0x13330, 0x0 },
+	{ 0x13430, 0x0 },
+	{ 0x13530, 0x0 },
+	{ 0x13630, 0x0 },
+	{ 0x13730, 0x0 },
+	{ 0x13830, 0x0 },
+};
+
+/* P0 message block paremeter for training firmware */
+struct dram_cfg_param ddr3l_fsp0_cfg[] = {
+	{ 0xd0000, 0x0 },
+	{ 0x54000, 0x0 },
+	{ 0x54001, 0x0 },
+	{ 0x54002, 0x0 },
+	{ 0x54003, 0x640 },
+	{ 0x54004, 0x2 },
+	{ 0x54005, 0x0 },
+	{ 0x54006, 0x140 },
+	{ 0x54007, 0x2000 },
+	{ 0x54008, 0x303 },
+	{ 0x54009, 0x200 },
+	{ 0x5400a, 0x0 },
+	{ 0x5400b, 0x31f },
+	{ 0x5400c, 0xc8 },
+	{ 0x5400d, 0x0 },
+	{ 0x5400e, 0x0 },
+	{ 0x5400f, 0x0 },
+	{ 0x54010, 0x0 },
+	{ 0x54011, 0x0 },
+	{ 0x54012, 0x1 },
+	{ 0x5402f, 0xd70 },
+	{ 0x54030, 0x4 },
+	{ 0x54031, 0x18 },
+	{ 0x5403a, 0x1221 },
+	{ 0x5403b, 0x4884 },
+	{ 0xd0000, 0x1 },
+};
+
+/* P1 message block paremeter for training firmware */
+struct dram_cfg_param ddr3l_fsp1_cfg[] = {
+	{ 0xd0000, 0x0 },
+	{ 0x54000, 0x0 },
+	{ 0x54001, 0x0 },
+	{ 0x54002, 0x1 },
+	{ 0x54003, 0x214 },
+	{ 0x54004, 0x2 },
+	{ 0x54005, 0x0 },
+	{ 0x54006, 0x140 },
+	{ 0x54007, 0x2000 },
+	{ 0x54008, 0x303 },
+	{ 0x54009, 0x200 },
+	{ 0x5400a, 0x0 },
+	{ 0x5400b, 0x21f },
+	{ 0x5400c, 0xc8 },
+	{ 0x5400d, 0x0 },
+	{ 0x5400e, 0x0 },
+	{ 0x5400f, 0x0 },
+	{ 0x54010, 0x0 },
+	{ 0x54011, 0x0 },
+	{ 0x54012, 0x1 },
+	{ 0x5402f, 0x930 },
+	{ 0x54030, 0x4 },
+	{ 0x54031, 0x8 },
+	{ 0x5403a, 0x1221 },
+	{ 0x5403b, 0x4884 },
+	{ 0xd0000, 0x1 },
+};
+
+/* P2 message block paremeter for training firmware */
+struct dram_cfg_param ddr3l_fsp2_cfg[] = {
+	{ 0xd0000, 0x0 },
+	{ 0x54000, 0x0 },
+	{ 0x54001, 0x0 },
+	{ 0x54002, 0x2 },
+	{ 0x54003, 0x14c },
+	{ 0x54004, 0x2 },
+	{ 0x54005, 0x0 },
+	{ 0x54006, 0x140 },
+	{ 0x54007, 0x2000 },
+	{ 0x54008, 0x303 },
+	{ 0x54009, 0x200 },
+	{ 0x5400a, 0x0 },
+	{ 0x5400b, 0x21f },
+	{ 0x5400c, 0xc8 },
+	{ 0x5400d, 0x0 },
+	{ 0x5400e, 0x0 },
+	{ 0x5400f, 0x0 },
+	{ 0x54010, 0x0 },
+	{ 0x54011, 0x0 },
+	{ 0x54012, 0x1 },
+	{ 0x5402f, 0x520 },
+	{ 0x54030, 0x4 },
+	{ 0x54031, 0x0 },
+	{ 0x5403a, 0x1221 },
+	{ 0x5403b, 0x4884 },
+	{ 0xd0000, 0x1 },
+};
+
+/* DRAM PHY init engine image */
+struct dram_cfg_param ddr3l_phy_pie[] = {
+	{ 0xd0000, 0x0 }, /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+	{ 0x90000, 0x10 }, /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s0 */
+	{ 0x90001, 0x400 }, /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s1 */
+	{ 0x90002, 0x10e }, /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s2 */
+	{ 0x90003, 0x0 }, /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s0 */
+	{ 0x90004, 0x0 }, /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s1 */
+	{ 0x90005, 0x8 }, /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s2 */
+	{ 0x90029, 0xb }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s0 */
+	{ 0x9002a, 0x480 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s1 */
+	{ 0x9002b, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s2 */
+	{ 0x9002c, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s0 */
+	{ 0x9002d, 0x448 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s1 */
+	{ 0x9002e, 0x139 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s2 */
+	{ 0x9002f, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s0 */
+	{ 0x90030, 0x478 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s1 */
+	{ 0x90031, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s2 */
+	{ 0x90032, 0x2 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s0 */
+	{ 0x90033, 0x10 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s1 */
+	{ 0x90034, 0x139 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s2 */
+	{ 0x90035, 0xf }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s0 */
+	{ 0x90036, 0x7c0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s1 */
+	{ 0x90037, 0x139 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s2 */
+	{ 0x90038, 0x44 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s0 */
+	{ 0x90039, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s1 */
+	{ 0x9003a, 0x159 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s2 */
+	{ 0x9003b, 0x14f }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s0 */
+	{ 0x9003c, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s1 */
+	{ 0x9003d, 0x159 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s2 */
+	{ 0x9003e, 0x47 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s0 */
+	{ 0x9003f, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s1 */
+	{ 0x90040, 0x149 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s2 */
+	{ 0x90041, 0x4f }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s0 */
+	{ 0x90042, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s1 */
+	{ 0x90043, 0x179 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s2 */
+	{ 0x90044, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s0 */
+	{ 0x90045, 0xe0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s1 */
+	{ 0x90046, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s2 */
+	{ 0x90047, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s0 */
+	{ 0x90048, 0x7c8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s1 */
+	{ 0x90049, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s2 */
+	{ 0x9004a, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s0 */
+	{ 0x9004b, 0x1 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s1 */
+	{ 0x9004c, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s2 */
+	{ 0x9004d, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s0 */
+	{ 0x9004e, 0x45a }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s1 */
+	{ 0x9004f, 0x9 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s2 */
+	{ 0x90050, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s0 */
+	{ 0x90051, 0x448 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s1 */
+	{ 0x90052, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s2 */
+	{ 0x90053, 0x40 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s0 */
+	{ 0x90054, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s1 */
+	{ 0x90055, 0x179 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s2 */
+	{ 0x90056, 0x1 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s0 */
+	{ 0x90057, 0x618 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s1 */
+	{ 0x90058, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s2 */
+	{ 0x90059, 0x40c0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s0 */
+	{ 0x9005a, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s1 */
+	{ 0x9005b, 0x149 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s2 */
+	{ 0x9005c, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s0 */
+	{ 0x9005d, 0x4 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s1 */
+	{ 0x9005e, 0x48 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s2 */
+	{ 0x9005f, 0x4040 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s0 */
+	{ 0x90060, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s1 */
+	{ 0x90061, 0x149 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s2 */
+	{ 0x90062, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s0 */
+	{ 0x90063, 0x4 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s1 */
+	{ 0x90064, 0x48 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s2 */
+	{ 0x90065, 0x40 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s0 */
+	{ 0x90066, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s1 */
+	{ 0x90067, 0x149 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s2 */
+	{ 0x90068, 0x10 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s0 */
+	{ 0x90069, 0x4 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s1 */
+	{ 0x9006a, 0x18 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s2 */
+	{ 0x9006b, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s0 */
+	{ 0x9006c, 0x4 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s1 */
+	{ 0x9006d, 0x78 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s2 */
+	{ 0x9006e, 0x549 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s0 */
+	{ 0x9006f, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s1 */
+	{ 0x90070, 0x159 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s2 */
+	{ 0x90071, 0xd49 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s0 */
+	{ 0x90072, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s1 */
+	{ 0x90073, 0x159 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s2 */
+	{ 0x90074, 0x94a }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s0 */
+	{ 0x90075, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s1 */
+	{ 0x90076, 0x159 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s2 */
+	{ 0x90077, 0x441 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s0 */
+	{ 0x90078, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s1 */
+	{ 0x90079, 0x149 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s2 */
+	{ 0x9007a, 0x42 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s0 */
+	{ 0x9007b, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s1 */
+	{ 0x9007c, 0x149 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s2 */
+	{ 0x9007d, 0x1 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s0 */
+	{ 0x9007e, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s1 */
+	{ 0x9007f, 0x149 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s2 */
+	{ 0x90080, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s0 */
+	{ 0x90081, 0xe0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s1 */
+	{ 0x90082, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s2 */
+	{ 0x90083, 0xa }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s0 */
+	{ 0x90084, 0x10 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s1 */
+	{ 0x90085, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s2 */
+	{ 0x90086, 0x9 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s0 */
+	{ 0x90087, 0x3c0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s1 */
+	{ 0x90088, 0x149 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s2 */
+	{ 0x90089, 0x9 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s0 */
+	{ 0x9008a, 0x3c0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s1 */
+	{ 0x9008b, 0x159 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s2 */
+	{ 0x9008c, 0x18 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s0 */
+	{ 0x9008d, 0x10 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s1 */
+	{ 0x9008e, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s2 */
+	{ 0x9008f, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s0 */
+	{ 0x90090, 0x3c0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s1 */
+	{ 0x90091, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s2 */
+	{ 0x90092, 0x18 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s0 */
+	{ 0x90093, 0x4 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s1 */
+	{ 0x90094, 0x48 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s2 */
+	{ 0x90095, 0x18 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s0 */
+	{ 0x90096, 0x4 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s1 */
+	{ 0x90097, 0x58 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s2 */
+	{ 0x90098, 0xa }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s0 */
+	{ 0x90099, 0x10 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s1 */
+	{ 0x9009a, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s2 */
+	{ 0x9009b, 0x2 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s0 */
+	{ 0x9009c, 0x10 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s1 */
+	{ 0x9009d, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s2 */
+	{ 0x9009e, 0x7 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s0 */
+	{ 0x9009f, 0x7c0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s1 */
+	{ 0x900a0, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s2 */
+	{ 0x900a1, 0x10 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s0 */
+	{ 0x900a2, 0x10 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s1 */
+	{ 0x900a3, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s2 */
+	{ 0x900a4, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s0 */
+	{ 0x900a5, 0x8140 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s1 */
+	{ 0x900a6, 0x10c }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s2 */
+	{ 0x900a7, 0x10 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s0 */
+	{ 0x900a8, 0x8138 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s1 */
+	{ 0x900a9, 0x10c }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s2 */
+	{ 0x900aa, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s0 */
+	{ 0x900ab, 0x7c8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s1 */
+	{ 0x900ac, 0x101 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s2 */
+	{ 0x900ad, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s0 */
+	{ 0x900ae, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s1 */
+	{ 0x900af, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s2 */
+	{ 0x900b0, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s0 */
+	{ 0x900b1, 0x448 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s1 */
+	{ 0x900b2, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s2 */
+	{ 0x900b3, 0xf }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s0 */
+	{ 0x900b4, 0x7c0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s1 */
+	{ 0x900b5, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s2 */
+	{ 0x900b6, 0x47 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s0 */
+	{ 0x900b7, 0x630 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s1 */
+	{ 0x900b8, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s2 */
+	{ 0x900b9, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s0 */
+	{ 0x900ba, 0x618 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s1 */
+	{ 0x900bb, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s2 */
+	{ 0x900bc, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s0 */
+	{ 0x900bd, 0xe0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s1 */
+	{ 0x900be, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s2 */
+	{ 0x900bf, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s0 */
+	{ 0x900c0, 0x7c8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s1 */
+	{ 0x900c1, 0x109 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s2 */
+	{ 0x900c2, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s0 */
+	{ 0x900c3, 0x8140 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s1 */
+	{ 0x900c4, 0x10c }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s2 */
+	{ 0x900c5, 0x0 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s0 */
+	{ 0x900c6, 0x1 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s1 */
+	{ 0x900c7, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s2 */
+	{ 0x900c8, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s0 */
+	{ 0x900c9, 0x4 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s1 */
+	{ 0x900ca, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s2 */
+	{ 0x900cb, 0x8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s0 */
+	{ 0x900cc, 0x7c8 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s1 */
+	{ 0x900cd, 0x101 }, /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s2 */
+	{ 0x90006, 0x0 }, /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s0 */
+	{ 0x90007, 0x0 }, /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s1 */
+	{ 0x90008, 0x8 }, /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s2 */
+	{ 0x90009, 0x0 }, /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s0 */
+	{ 0x9000a, 0x0 }, /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s1 */
+	{ 0x9000b, 0x0 }, /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s2 */
+	{ 0xd00e7, 0x400 }, /*  DWC_DDRPHYA_APBONLY0_SequencerOverride */
+	{ 0x90017, 0x0 }, /*  DWC_DDRPHYA_INITENG0_StartVector0b0 */
+	{ 0x90026, 0x2c }, /*  DWC_DDRPHYA_INITENG0_StartVector0b15 */
+	{ 0x2000b, 0x32 }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p0 */
+	{ 0x2000c, 0x64 }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p0 */
+	{ 0x2000d, 0x3e8 }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p0 */
+	{ 0x2000e, 0x2c }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p0 */
+	{ 0x12000b, 0x10 }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p1 */
+	{ 0x12000c, 0x21 }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p1 */
+	{ 0x12000d, 0x14c }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p1 */
+	{ 0x12000e, 0x10 }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p1 */
+	{ 0x22000b, 0xa }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p2 */
+	{ 0x22000c, 0x14 }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p2 */
+	{ 0x22000d, 0xcf }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p2 */
+	{ 0x22000e, 0x10 }, /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p2 */
+	{ 0x9000c, 0x0 }, /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag0 */
+	{ 0x9000d, 0x173 }, /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag1 */
+	{ 0x9000e, 0x60 }, /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag2 */
+	{ 0x9000f, 0x6110 }, /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag3 */
+	{ 0x90010, 0x2152 }, /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag4 */
+	{ 0x90011, 0xdfbd }, /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag5 */
+	{ 0x90012, 0xffff }, /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag6 */
+	{ 0x90013, 0x6152 }, /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag7 */
+	{ 0xc0080, 0x0 }, /*  DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
+	{ 0xd0000, 0x1 }, /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+};
+
+struct dram_fsp_msg ddr3l_dram_fsp_msg[] = {
+	{
+		/* P0 2400mts 1D */
+		.drate = 1600,
+		.fw_type = FW_1D_IMAGE,
+		.fsp_cfg = ddr3l_fsp0_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr3l_fsp0_cfg),
+	},
+#if 0
+	{
+		/* P1 1066mts 1D */
+		.drate = 1066,
+		.fw_type = FW_1D_IMAGE,
+		.fsp_cfg = ddr3l_fsp1_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr3l_fsp1_cfg),
+	},
+	{
+		/* P2 667mts 1D */
+		.drate = 667,
+		.fw_type = FW_1D_IMAGE,
+		.fsp_cfg = ddr3l_fsp2_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr3l_fsp2_cfg),
+	},
+#endif
+};
+
+/* ddr3l timing config params on VAL board */
+struct dram_timing_info dram_timing = {
+	.ddrc_cfg = ddr3l_ddrc_cfg,
+	.ddrc_cfg_num = ARRAY_SIZE(ddr3l_ddrc_cfg),
+	.ddrphy_cfg = ddr3l_ddrphy_cfg,
+	.ddrphy_cfg_num = ARRAY_SIZE(ddr3l_ddrphy_cfg),
+	.fsp_msg = ddr3l_dram_fsp_msg,
+	.fsp_msg_num = ARRAY_SIZE(ddr3l_dram_fsp_msg),
+	.ddrphy_trained_csr = ddr3l_ddrphy_trained_csr,
+	.ddrphy_trained_csr_num = ARRAY_SIZE(ddr3l_ddrphy_trained_csr),
+	.ddrphy_pie = ddr3l_phy_pie,
+	.ddrphy_pie_num = ARRAY_SIZE(ddr3l_phy_pie),
+};
diff --git a/board/karo/tx8m/qs8m.c b/board/karo/tx8m/qs8m.c
new file mode 100644
index 0000000..af412dc
--- /dev/null
+++ b/board/karo/tx8m/qs8m.c
@@ -0,0 +1,872 @@
+/*
+ * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <console.h>
+#include <errno.h>
+#include <fsl_esdhc.h>
+#include <fsl_wdog.h>
+#include <i2c.h>
+#include <imx_mipi_dsi_bridge.h>
+#include <led.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <mipi_dsi_panel.h>
+#include <mmc.h>
+#include <netdev.h>
+#include <sec_mipi_dsim.h>
+#include <spl.h>
+#include <thermal.h>
+#include <asm-generic/gpio.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx8mm_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/armv8/mmu.h>
+#include <asm/mach-imx/dma.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/video.h>
+#include <dm/uclass.h>
+#include "../common/karo.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_HYS |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_usdhc1_pads[] = {
+	IMX8MM_PAD_SD1_CLK_USDHC1_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_CMD_USDHC1_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA0_USDHC1_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA1_USDHC1_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA2_USDHC1_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA3_USDHC1_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA4_USDHC1_DATA4 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA5_USDHC1_DATA5 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA6_USDHC1_DATA6 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA7_USDHC1_DATA7 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_STROBE_USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
+	IMX8MM_PAD_SD1_RESET_B_USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc2_pads[] = {
+	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CD_B_GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc3_pads[] = {
+	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA02_GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
+};
+
+static struct tx8m_esdhc_cfg {
+	struct fsl_esdhc_cfg cfg;
+	int clk;
+	const iomux_v3_cfg_t *pads;
+	size_t num_pads;
+	int cd_gpio;
+} tx8mm_sdhc_cfgs[] = {
+	{
+		.cfg = {
+			.esdhc_base = USDHC1_BASE_ADDR,
+			.max_bus_width = 8,
+		},
+		.clk = MXC_ESDHC_CLK,
+		.pads = tx8mm_usdhc1_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc1_pads),
+		.cd_gpio = -EINVAL,
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC2_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC2_CLK,
+		.pads = tx8mm_usdhc2_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc2_pads),
+		.cd_gpio = IMX_GPIO_NR(2, 12),
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC3_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC3_CLK,
+		.pads = tx8mm_usdhc3_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc3_pads),
+		.cd_gpio = IMX_GPIO_NR(3, 8),
+	},
+};
+
+static inline struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(tx8mm_sdhc_cfgs); i++) {
+		struct tx8m_esdhc_cfg *cfg = &tx8mm_sdhc_cfgs[i];
+
+		if (priv->esdhc_base == cfg->cfg.esdhc_base)
+			return cfg;
+	}
+	return NULL;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
+
+	if (cfg == NULL) {
+		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
+		return 0;
+	}
+	if (cfg->cd_gpio < 0) {
+		debug("%s@%d: 1\n", __func__, __LINE__);
+		return 1;
+	}
+	debug("%s@%d: %d\n", __func__, __LINE__,
+	      !gpio_get_value(cfg->cd_gpio));
+	return !gpio_get_value(cfg->cd_gpio);
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (eMMC)
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+
+	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		struct mmc *mmc;
+		struct tx8m_esdhc_cfg *cfg;
+
+		if (i >= ARRAY_SIZE(tx8mm_sdhc_cfgs)) {
+			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
+			       CONFIG_SYS_FSL_USDHC_NUM,
+			       ARRAY_SIZE(tx8mm_sdhc_cfgs));
+			return -EINVAL;
+		}
+
+		cfg = &tx8mm_sdhc_cfgs[i];
+		if (cfg->cd_gpio >= 0) {
+			gpio_request(cfg->cd_gpio, "MMC CD");
+			gpio_direction_input(cfg->cd_gpio);
+		}
+		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
+		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
+
+		debug("%s@%d: Initialising MMC dev %zu @ %08llx clock=%u\n", __func__, __LINE__,
+		      i, cfg->cfg.esdhc_base, cfg->cfg.sdhc_clk);
+		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
+		if (ret) {
+			printf("Failed to initialize MMC%zu: %d\n", i, ret);
+			continue;
+		}
+
+		mmc = find_mmc_device(i);
+		if (mmc == NULL) {
+			printf("mmc device %zi not found\n", i);
+			continue;
+		}
+		if (board_mmc_getcd(mmc)) {
+			ret = mmc_init(mmc);
+			if (ret && ret != -EOPNOTSUPP)
+				printf("%s@%d: mmc_init(mmc%zi) failed: %d\n",
+				       __func__, __LINE__, i, ret);
+		} else {
+			debug("No Medium found in MMC slot %zi\n", i);
+		}
+	}
+	return 0;
+}
+#endif /* DM_MMC */
+
+#ifdef CONFIG_OF_BOARD_SETUP
+#include <asm/setup.h>
+#include <asm/bootm.h>
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	struct tag_serialnr serno;
+	char serno_str[64 / 4 + 1];
+
+	get_board_serial(&serno);
+	snprintf(serno_str, sizeof(serno_str), "%08x%08x",
+		 serno.high, serno.low);
+
+	printf("serial-number: %s\n", serno_str);
+
+	fdt_setprop(blob, 0, "serial-number", serno_str, strlen(serno_str));
+	fsl_fdt_fixup_dr_usb(blob, bd);
+	return 0;
+}
+#endif /* OF_BOARD_SETUP */
+
+#ifdef CONFIG_FEC_MXC
+#define MDIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_DSE6 |	\
+					     PAD_CTL_PE |	\
+					     PAD_CTL_PUE)
+
+#define FEC_IN_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL2)
+
+#define FEC_OUT_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_fec_pads[] = {
+	IMX8MM_PAD_ENET_MDC_ENET1_MDC | MDIO_PAD_CTRL, /* 0x146 */
+	IMX8MM_PAD_ENET_MDIO_ENET1_MDIO | MDIO_PAD_CTRL,
+	IMX8MM_PAD_ENET_TD2_ENET1_TX_CLK | MUX_MODE_SION | FEC_IN_PAD_CTRL, /* 0x40000016 */
+	IMX8MM_PAD_ENET_TD0_ENET1_RGMII_TD0 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MM_PAD_ENET_TD1_ENET1_RGMII_TD1 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MM_PAD_ENET_RD0_ENET1_RGMII_RD0 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RD1_ENET1_RGMII_RD1 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RXC_ENET1_RX_ER | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RX_CTL_ENET1_RGMII_RX_CTL | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_TX_CTL_ENET1_RGMII_TX_CTL | FEC_OUT_PAD_CTRL, /* 0x16 */
+};
+
+static int tx8mm_etnphy_init(void)
+{
+	int ret;
+	struct gpio_desc enet0_pwr;
+	struct gpio_desc enet0_rst;
+
+	ret = dm_gpio_lookup_name("gpio1_23", &enet0_pwr);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_lookup_name("gpio1_29", &enet0_rst);
+	if (ret) {
+		printf("Failed to lookup ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_pwr, "ENET0_PWR");
+	if (ret) {
+		printf("Failed to request ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_rst, "ENET0_RST");
+	if (ret) {
+		printf("Failed to request ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	dm_gpio_set_dir_flags(&enet0_rst, GPIOD_IS_OUT);
+	dm_gpio_set_dir_flags(&enet0_pwr, GPIOD_IS_OUT);
+	dm_gpio_set_value(&enet0_rst, 0);
+	dm_gpio_set_value(&enet0_pwr, 1);
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_fec_pads,
+					 ARRAY_SIZE(tx8mm_fec_pads));
+
+	mdelay(25);
+	dm_gpio_set_value(&enet0_rst, 1);
+	mdelay(10);
+	return 0;
+}
+
+static int tx8mm_setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *iomuxc_gpr_regs =
+		(void *)IOMUXC_GPR_BASE_ADDR;
+	unsigned char mac[6];
+
+	set_clk_enet(ENET_50MHZ);
+
+	/* Use 50M anatop REF_CLK1 for ENET1, not from external */
+	setbits_le32(&iomuxc_gpr_regs->gpr[1],
+		     IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK);
+
+	imx_get_mac_from_fuse(0, mac);
+	printf("MAC addr: %pM\n", mac);
+
+	return tx8mm_etnphy_init();
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#else
+static inline int tx8mm_setup_fec(void)
+{
+	return 0;
+}
+#endif /* FEX_MXC */
+
+int dram_init(void)
+{
+	/* rom_pointer[1] contains the size of RAM occupied by TEE */
+	if (rom_pointer[1])
+		gd->ram_size = PHYS_SDRAM_SIZE - ALIGN(rom_pointer[1], PAGE_SIZE);
+	else
+		gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+int board_fix_fdt(void *blob)
+{
+	return 0;
+}
+
+#define GPIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_gpio_pads[] = {
+	IMX8MM_PAD_SD2_RESET_B_GPIO2_IO19 | GPIO_PAD_CTRL,
+};
+
+#ifdef CONFIG_SHOW_ACTIVITY
+enum {
+	LED_STATE_INIT = -1,
+	LED_STATE_OFF,
+	LED_STATE_ON,
+	LED_STATE_DISABLED,
+};
+
+static int led_state = LED_STATE_DISABLED;
+static bool tx8m_temp_check_enabled = true;
+static struct udevice *leddev;
+static struct udevice *thermaldev;
+
+#define TEMPERATURE_HOT		80
+#define TEMPERATURE_MIN		-40
+
+static inline int calc_blink_rate(void)
+{
+	int cpu_temp;
+	static int last_temp = INT_MAX;
+	static int avg_count;
+
+	if (!tx8m_temp_check_enabled)
+		return CONFIG_SYS_HZ;
+
+	if (!thermaldev || thermal_get_temp(thermaldev, &cpu_temp))
+		return CONFIG_SYS_HZ / 2;
+
+	if (last_temp == INT_MAX) {
+		last_temp = cpu_temp;
+	} else if (cpu_temp != last_temp) {
+		static int cpu_temps[4];
+
+		if (thermal_get_temp(thermaldev, &cpu_temps[avg_count]))
+			return CONFIG_SYS_HZ / 2;
+		if (++avg_count >= ARRAY_SIZE(cpu_temps)) {
+			int bad = -1;
+			int i;
+
+			for (i = 0; i < avg_count; i++) {
+				if (cpu_temp != cpu_temps[i])
+					bad = i;
+			}
+			if (bad < 0) {
+				debug("CPU temperature changed from %d to %d\n",
+				      last_temp, cpu_temp);
+				last_temp = cpu_temp;
+			} else {
+				debug("Spurious CPU temperature reading %d -> %d -> %d\n",
+				      cpu_temp, cpu_temps[bad], cpu_temps[i - 1]);
+			}
+			avg_count = 0;
+		}
+	} else {
+		avg_count = 0;
+	}
+	return CONFIG_SYS_HZ + CONFIG_SYS_HZ / 10 -
+		(last_temp - TEMPERATURE_MIN) * CONFIG_SYS_HZ /
+		(TEMPERATURE_HOT - TEMPERATURE_MIN);
+}
+
+void show_activity(int arg)
+{
+	static int blink_rate;
+	static ulong last;
+	int ret;
+
+	if (led_state == LED_STATE_DISABLED)
+		return;
+
+	if (led_state == LED_STATE_INIT) {
+		last = get_timer(0);
+		ret = led_set_state(leddev, LEDST_ON);
+		if (ret == 0)
+			led_state = LED_STATE_ON;
+		else
+			led_state = LED_STATE_DISABLED;
+		blink_rate = calc_blink_rate();
+	} else {
+		if (get_timer(last) > blink_rate) {
+			blink_rate = calc_blink_rate();
+			last = get_timer(0);
+			if (led_state == LED_STATE_ON) {
+				ret = led_set_state(leddev, LEDST_OFF);
+			} else {
+				ret = led_set_state(leddev, LEDST_ON);
+			}
+			if (ret == 0)
+				led_state = 1 - led_state;
+			else
+				led_state = LED_STATE_DISABLED;
+		}
+	}
+
+}
+
+static void tx8m_led_init(void)
+{
+	int ret;
+
+	ret = led_get_by_label("Heartbeat", &leddev);
+	if (ret) {
+		printf("Failed to find LED device: %d\n", ret);
+		return;
+	}
+
+	ret = uclass_get_device_by_name(UCLASS_THERMAL, "cpu-thermal",
+					&thermaldev);
+	if (ret)
+		printf("Failed to find THERMAL device: %d\n", ret);
+
+	led_state = LED_STATE_INIT;
+}
+#else
+static inline void tx8m_led_init(void)
+{
+	debug("%s@%d: \n", __func__, __LINE__);
+}
+#endif /* SHOW_ACTIVITY */
+
+int checkboard(void)
+{
+	printf("Board: Ka-Ro QS8M-MQ00\n");
+	return 0;
+}
+
+#ifdef CONFIG_DM_I2C
+static inline int tx8mm_i2c_init(void)
+{
+	int ret = 0;
+	int i;
+
+	for (i = 0; ret != -ENODEV; i++) {
+		struct udevice *i2c_dev;
+		u8 i2c_addr;
+
+		ret = uclass_get_device_by_seq(UCLASS_I2C, i, &i2c_dev);
+		if (ret == -ENODEV)
+			break;
+
+		for (i2c_addr = 0x07; i2c_addr < 0x78; i2c_addr++) {
+			struct udevice *chip;
+
+			ret = dm_i2c_probe(i2c_dev, i2c_addr, 0x0, &chip);
+			if (ret == 0) {
+				printf("Found an I2C device @ %u:%02x\n",
+				       i, i2c_addr);
+			} else if (ret != -EREMOTEIO) {
+				printf("Error %d accessing device %u:%02x\n",
+				       ret, i, i2c_addr);
+				break;
+			}
+		}
+	}
+	return ret;
+}
+#else
+static int tx8mm_i2c_init(void)
+{
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	int ret;
+	struct gpio_desc reset_out;
+
+	tx8mm_setup_fec();
+
+	//tx8mm_i2c_init();
+
+	ret = dm_gpio_lookup_name("gpio2_19", &reset_out);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+	ret = dm_gpio_request(&reset_out, "RESET_OUT");
+	if (ret) {
+		printf("Failed to request RESET_OUT GPIO: %d\n", ret);
+		return ret;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_gpio_pads,
+					 ARRAY_SIZE(tx8mm_gpio_pads));
+	tx8m_led_init();
+	return ret;
+}
+
+#ifdef CONFIG_BOARD_EARLY_INIT_R
+int board_early_init_r(void)
+{
+	return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+	int ret;
+	struct src *src_regs = (void *)SRC_BASE_ADDR;
+	struct watchdog_regs *wdog = (void *)WDOG1_BASE_ADDR;
+	u32 srsr = readl(&src_regs->srsr);
+	u16 wrsr = readw(&wdog->wrsr);
+	const char *fdt_file = env_get("fdt_file");
+
+	karo_env_cleanup();
+	if (srsr & 0x10 && !(wrsr & WRSR_SFTW))
+		env_set("wdreset", "1");
+	if (had_ctrlc())
+		env_set("safeboot", "1");
+	if (fdt_file) {
+		ret = karo_load_fdt(fdt_file);
+		if (ret)
+			printf("Failed to load FDT from '%s': %d\n",
+			       fdt_file, ret);
+	}
+
+	return 0;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 1;
+}
+
+void board_quiesce_devices(void)
+{
+}
+
+#ifdef CONFIG_VIDEO
+static const struct sec_mipi_dsim_plat_data imx8mm_mipi_dsim_plat_data = {
+	.version	= 0x1060200,
+	.max_data_lanes = 4,
+	.max_data_rate  = 1500000000ULL,
+	.reg_base = MIPI_DSI_BASE_ADDR,
+	.gpr_base = CSI_BASE_ADDR + 0x8000,
+};
+
+#define DSI_DDR_MODE 0
+
+struct mipi_dsi_client_dev dsi83_dev = {
+	.channel = 0,
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+	.name = "DSI83",
+};
+
+#define DISPLAY_MIX_SFT_RSTN_CSR	0x00
+#define DISPLAY_MIX_CLK_EN_CSR		0x04
+
+   /* 'DISP_MIX_SFT_RSTN_CSR' bit fields */
+#define BUS_RSTN_BLK_SYNC_SFT_EN	BIT(6)
+
+   /* 'DISP_MIX_CLK_EN_CSR' bit fields */
+#define LCDIF_PIXEL_CLK_SFT_EN		BIT(7)
+#define LCDIF_APB_CLK_SFT_EN		BIT(6)
+
+static void disp_mix_bus_rstn_reset(ulong gpr_base, bool reset)
+{
+	if (!reset)
+		/* release reset */
+		setbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
+			     BUS_RSTN_BLK_SYNC_SFT_EN);
+	else
+		/* hold reset */
+		clrbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
+			     BUS_RSTN_BLK_SYNC_SFT_EN);
+}
+
+static void disp_mix_lcdif_clks_enable(ulong gpr_base, bool enable)
+{
+	if (enable)
+		/* enable lcdif clks */
+		setbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
+			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
+	else
+		/* disable lcdif clks */
+		clrbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
+			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
+}
+
+#define LINE_LENGTH	1280
+#define H_FRONT_PORCH	64
+#define H_BACK_PORCH	4
+#define HSYNC_LEN	1
+#define VERT_SIZE	800
+#define V_FRONT_PORCH	40
+#define V_BACK_PORCH	1
+#define VSYNC_LEN	1
+#define VREFRESH	60
+
+#define BPP	24
+#define SYNC_DELAY	64
+#define HTOTAL		(HSYNC_LEN + H_BACK_PORCH + LINE_LENGTH + H_FRONT_PORCH)
+#define VTOTAL		(VSYNC_LEN + V_BACK_PORCH + VERT_SIZE + V_FRONT_PORCH)
+#define PCLK		(HTOTAL * VTOTAL * VREFRESH)
+#define DSI_CLK		(PCLK * BPP / 4 / (!!DSI_DDR_MODE + 1))
+#define DSI_CLK_DIV	((DSI_CLK + PCLK - 1) / PCLK)
+#define LVDS_CLK	(DSI_CLK / DSI_CLK_DIV)
+#define LVDS_CLK_DIV	((LVDS_CLK + 12500000) / 25000000 - 1)
+
+static struct dsi83_data {
+	u8 addr;
+	u8 val;
+	u8 mask;
+} dsi83_data[] = {
+	{ 0x09, 1, },
+	{ 0x0d, 0x00, 0x01, },
+	{ 0x10, 0x00, 0x18, }, // DSI lanes 0x00: 4 lanes; 0x08: 3 lanes
+	{ 0x10, 0x00, 0x01, }, // SOT_ERR_TOL_DIS
+	{ 0x11, 0xc0, 0xc0, }, // DSI DATA equalization
+	{ 0x11, 0x0c, 0x0c, }, // DSI clock equalization
+	{ 0x12, DSI_CLK / 1000000 / 5, }, // DSI clk range 8: 40..45MHz; 9: 45..50MHz; ...
+	{ 0x0a, 0x01, 0x01, },
+	{ 0x0a, LVDS_CLK_DIV << 1, 0x0e, },
+	{ 0x0b, 0x00, 0x03, },
+	{ 0x0b, (DSI_CLK_DIV - 1) << 3, 0x7c, },
+	{ 0x18, 0x60, 0xe0, }, // DE_NEG HS_NEG VS_NEG
+	{ 0x18, 0x08, 0x9, }, // CHA_24BPP_MODE CHA24BPP_FORMAT1
+	{ 0x20, LINE_LENGTH % 256, },
+	{ 0x21, LINE_LENGTH / 256, },
+	{ 0x24, VERT_SIZE % 256, },
+	{ 0x25, VERT_SIZE / 256, },
+	{ 0x28, SYNC_DELAY % 256, },
+	{ 0x29, SYNC_DELAY / 256, },
+	{ 0x2c, HSYNC_LEN % 256, },
+	{ 0x2d, HSYNC_LEN / 256, },
+	{ 0x30, VSYNC_LEN % 256, },
+	{ 0x31, VSYNC_LEN / 256, },
+	{ 0x34, H_BACK_PORCH + HSYNC_LEN, },
+	{ 0x36, V_BACK_PORCH + VSYNC_LEN, },
+	{ 0x38, H_FRONT_PORCH, },
+	{ 0x3a, V_FRONT_PORCH, },
+	//{ 0x3c, 0x10, 0x10, }, // enable CHA_TEST_PATTERN
+	{ 0x3c, 0x00, },
+	{ 0x0d, 0x01, 0x01, }, // enable PLL
+	{ 0xe5, 0xfd, 0xfd, }, // clear error status
+};
+
+#define DSI83_SLAVE_ADDR	0x2c
+
+static int dsi83_init(void)
+{
+	int ret;
+	struct udevice *dev;
+	struct udevice *chip;
+	u8 val;
+
+	debug("DSI clock: %u.%03uMHz dsi_clk_div=%u\n",
+	      DSI_CLK / 1000000, DSI_CLK / 1000 % 1000, DSI_CLK_DIV);
+	debug("LVDS clock: %u.%03uMHz lvds_clk_range=%u\n",
+	      LVDS_CLK / 1000000, LVDS_CLK / 1000 % 1000, LVDS_CLK_DIV);
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, 1, &dev);
+	if (ret) {
+		printf("%s: Failed to find I2C bus device: %d\n",
+		       __func__, ret);
+		return ret;
+	}
+	ret = dm_i2c_probe(dev, DSI83_SLAVE_ADDR, 0x0, &chip);
+	if (ret) {
+		printf("%s: I2C probe failed for slave addr %02x: %d\n",
+		       __func__, DSI83_SLAVE_ADDR, ret);
+		return ret;
+	}
+	for (size_t i = 0; i < ARRAY_SIZE(dsi83_data); i++) {
+		struct dsi83_data *p = &dsi83_data[i];
+
+		ret = dm_i2c_read(chip, p->addr, &val, 1);
+		if (ret) {
+			printf("%s: Failed to read reg %02x\n",
+			       __func__, p->val);
+			return ret;
+		}
+		debug("%s@%d: Read %02x from reg %02x\n",
+		      __func__, __LINE__, val, p->addr);
+		val = (val & ~p->mask) | p->val;
+		debug("%s@%d: Writing %02x to reg %02x\n",
+		      __func__, __LINE__, val, p->addr);
+		ret = dm_i2c_write(chip, p->addr, &val, 1);
+		if (ret) {
+			printf("%s: Failed to write %02x to reg %02x\n",
+			       __func__, p->val, p->addr);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static const iomux_v3_cfg_t tx8mm_lcd_pads[] = {
+	IMX8MM_PAD_GPIO1_IO01_GPIO1_IO1 | GPIO_PAD_CTRL,
+	IMX8MM_PAD_GPIO1_IO04_GPIO1_IO4 | GPIO_PAD_CTRL,
+};
+
+static void tx8m_backlight_enable(void)
+{
+	int ret;
+	struct gpio_desc backlight_control;
+	struct gpio_desc lcd_enable;
+
+	ret = dm_gpio_lookup_name("gpio1_1", &backlight_control);
+	if (ret == 0) {
+		ret = dm_gpio_request(&backlight_control, "BACKLIGHT_CONTROL");
+		if (ret == 0) {
+			dm_gpio_set_dir_flags(&backlight_control, GPIOD_IS_OUT);
+			dm_gpio_set_value(&backlight_control, 1);
+		} else {
+			printf("Failed to request BACKLIGHT_CONTROL GPIO: %d\n",
+			       ret);
+		}
+	} else {
+		printf("Failed to lookup BACKLIGHT_CONTROL GPIO: %d\n", ret);
+	}
+
+	ret = dm_gpio_lookup_name("gpio1_4", &lcd_enable);
+	if (ret == 0) {
+		ret = dm_gpio_request(&lcd_enable, "LCD_ENABLE");
+		if (ret == 0) {
+			dm_gpio_set_dir_flags(&lcd_enable, GPIOD_IS_OUT);
+			dm_gpio_set_value(&lcd_enable, 1);
+		} else {
+			printf("Failed to request LCD_ENABLE GPIO: %d\n", ret);
+		}
+	} else {
+		printf("Failed to lookup LCD_ENABLE GPIO: %d\n", ret);
+	}
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_lcd_pads,
+					 ARRAY_SIZE(tx8mm_lcd_pads));
+}
+
+#define FSL_SIP_GPC			0xC2000000
+#define FSL_SIP_CONFIG_GPC_PM_DOMAIN	0x3
+#define DISPMIX				9
+#define MIPI				10
+
+static void do_enable_mipi2lvds(struct display_info_t const *disp)
+{
+	/* enable the dispmix & mipi phy power domain */
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
+		     DISPMIX, true, 0);
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
+		     MIPI, true, 0);
+
+	/* Get lcdif out of reset */
+	disp_mix_bus_rstn_reset(imx8mm_mipi_dsim_plat_data.gpr_base, false);
+	disp_mix_lcdif_clks_enable(imx8mm_mipi_dsim_plat_data.gpr_base, true);
+
+	sec_mipi_dsim_setup(&imx8mm_mipi_dsim_plat_data);
+	imx_mipi_dsi_bridge_attach(&dsi83_dev);
+	dsi83_init();
+	tx8m_backlight_enable();
+}
+
+static struct display_info_t const panel_info[] = {
+	{
+		.bus = LCDIF_BASE_ADDR,
+		.pixfmt = BPP,
+		.enable	= do_enable_mipi2lvds,
+		.mode	= {
+			.name		= "MIPI2LVDS",
+			.refresh	= VREFRESH,
+			.xres		= LINE_LENGTH,
+			.yres		= VERT_SIZE,
+			.pixclock	= KHZ2PICOS(PCLK / 1000),
+			.left_margin	= H_BACK_PORCH,
+			.hsync_len	= HSYNC_LEN,
+			.right_margin	= H_FRONT_PORCH,
+			.upper_margin	= V_BACK_PORCH,
+			.vsync_len	= VSYNC_LEN,
+			.lower_margin	= V_FRONT_PORCH,
+			.sync		= FB_SYNC_EXT,
+			.vmode		= FB_VMODE_NONINTERLACED,
+		},
+	},
+};
+
+int board_video_skip(void)
+{
+	int ret;
+	const char *baseboard = env_get("baseboard");
+	const char *panel = env_get("panel");
+	size_t i;
+
+	if (had_ctrlc()) {
+		printf("<CTRL-C> detected; disabling display\n");
+		return 1;
+	}
+
+	if (!panel) {
+		printf("No LCD panel configured\n");
+		return 1;
+	}
+
+	if (!baseboard || strcmp(baseboard, "mipi-mb") != 0) {
+		printf("No Display support for '%s' baseboard\n",
+		       baseboard ?: "unspecified");
+		return 1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(panel_info); i++) {
+		const struct display_info_t *pi = &panel_info[i];
+
+		if (strcmp(panel, pi->mode.name) != 0)
+			continue;
+
+		ret = mxs_lcd_panel_setup(pi->mode,
+					  pi->pixfmt,
+					  pi->bus);
+		if (ret)
+			return ret;
+
+		if (pi->enable)
+			pi->enable(panel_info + i);
+
+		printf("Display: %s (%ux%u)\n", pi->mode.name,
+		       pi->mode.xres, pi->mode.yres);
+	}
+	return ret;
+}
+#endif
diff --git a/board/karo/tx8m/spl.c b/board/karo/tx8m/spl.c
new file mode 100644
index 0000000..122c43e
--- /dev/null
+++ b/board/karo/tx8m/spl.c
@@ -0,0 +1,430 @@
+/*
+ * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <fsl_esdhc.h>
+#include <spl.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx8mm_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#ifdef CONFIG_POWER
+#include <power/pmic.h>
+#include <power/bd71837.h>
+#endif
+#ifdef CONFIG_IMX8M_DRAM
+#include <asm/arch/imx8m_ddr.h>
+#else
+#include "ddr/ddr.h"
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void spl_dram_init(void)
+{
+#ifdef CONFIG_IMX8M_DRAM
+	ddr_init(&dram_timing);
+#else
+	ddr_init();
+#endif
+}
+
+#define I2C_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_HYS |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+struct i2c_pads_info i2c_pad_info[] = {
+	{
+		.scl = {
+			.i2c_mode = IMX8MM_PAD_I2C1_SCL_I2C1_SCL | I2C_PAD_CTRL,
+			.gpio_mode = IMX8MM_PAD_I2C1_SCL_GPIO5_IO14 | I2C_PAD_CTRL,
+			.gp = IMX_GPIO_NR(5, 14),
+		},
+		.sda = {
+			.i2c_mode = IMX8MM_PAD_I2C1_SDA_I2C1_SDA | I2C_PAD_CTRL,
+			.gpio_mode = IMX8MM_PAD_I2C1_SDA_GPIO5_IO15 | I2C_PAD_CTRL,
+			.gp = IMX_GPIO_NR(5, 15),
+		},
+	},
+};
+
+#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_HYS |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_usdhc1_pads[] = {
+	IMX8MM_PAD_SD1_CLK_USDHC1_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_CMD_USDHC1_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA0_USDHC1_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA1_USDHC1_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA2_USDHC1_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA3_USDHC1_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA4_USDHC1_DATA4 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA5_USDHC1_DATA5 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA6_USDHC1_DATA6 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA7_USDHC1_DATA7 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_STROBE_USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
+	IMX8MM_PAD_SD1_RESET_B_USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc2_pads[] = {
+	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CD_B_GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc3_pads[] = {
+	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA02_GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
+};
+
+static struct tx8m_esdhc_cfg {
+	struct fsl_esdhc_cfg cfg;
+	int clk;
+	const iomux_v3_cfg_t *pads;
+	size_t num_pads;
+	int cd_gpio;
+} tx8mm_sdhc_cfgs[] = {
+	{
+		.cfg = {
+			.esdhc_base = USDHC1_BASE_ADDR,
+			.max_bus_width = 8,
+		},
+		.clk = MXC_ESDHC_CLK,
+		.pads = tx8mm_usdhc1_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc1_pads),
+		.cd_gpio = -EINVAL,
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC2_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC2_CLK,
+		.pads = tx8mm_usdhc2_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc2_pads),
+		.cd_gpio = IMX_GPIO_NR(2, 12),
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC3_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC3_CLK,
+		.pads = tx8mm_usdhc3_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc3_pads),
+		.cd_gpio = IMX_GPIO_NR(3, 8),
+	},
+};
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (eMMC)
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+
+	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		struct mmc *mmc;
+		struct tx8m_esdhc_cfg *cfg;
+
+		if (i >= ARRAY_SIZE(tx8mm_sdhc_cfgs)) {
+			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
+			       CONFIG_SYS_FSL_USDHC_NUM,
+			       ARRAY_SIZE(tx8mm_sdhc_cfgs));
+			return -EINVAL;
+		}
+
+		cfg = &tx8mm_sdhc_cfgs[i];
+		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
+		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
+
+		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
+		if (ret) {
+			printf("Failed to initialize MMC%zu: %d\n", i, ret);
+			continue;
+		}
+
+		mmc = find_mmc_device(i);
+		if (mmc == NULL) {
+			printf("mmc device %zi not found\n", i);
+			continue;
+		}
+		if (board_mmc_getcd(mmc)) {
+			ret = mmc_init(mmc);
+			if (ret && ret != -EOPNOTSUPP)
+				printf("%s@%d: mmc_init(mmc%zi) failed: %d\n",
+				       __func__, __LINE__, i, ret);
+		} else {
+			debug("No Medium found in MMC slot %zi\n", i);
+		}
+	}
+	return 0;
+}
+
+static inline struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(tx8mm_sdhc_cfgs); i++) {
+		struct tx8m_esdhc_cfg *cfg = &tx8mm_sdhc_cfgs[i];
+
+		if (priv->esdhc_base == cfg->cfg.esdhc_base)
+			return cfg;
+	}
+	return NULL;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
+
+	if (cfg == NULL) {
+		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
+		return 0;
+	}
+	if (cfg->cd_gpio < 0) {
+		debug("%s@%d: 1\n", __func__, __LINE__);
+		return 1;
+	}
+	debug("%s@%d: %d\n", __func__, __LINE__,
+	      !gpio_get_value(cfg->cd_gpio));
+
+	return !gpio_get_value(cfg->cd_gpio);
+}
+
+#ifdef CONFIG_POWER
+
+#define I2C_PMIC	0
+#define PMIC_NAME	"BD71837"
+
+static inline int pmic_update_reg(struct pmic *p, uint reg, uint value,
+				  const char *reg_name)
+{
+	int ret;
+	u32 val;
+
+	ret = pmic_reg_read(p, reg, &val);
+	if (ret) {
+		printf("Failed to read register %s[%02x]: %d\n",
+		       reg_name, reg, ret);
+		return ret;
+	}
+	debug("Read %02x from reg %s[%02x]\n", val, reg_name, reg);
+	ret = pmic_reg_write(p, reg, value);
+	if (ret) {
+		printf("Failed to write %02x to register %s[%02x]: %d\n",
+		       value, reg_name, reg, ret);
+		return ret;
+	}
+	debug("Wrote %02x to reg %s[%02x]\n", value, reg_name, reg);
+	return ret;
+}
+
+#define pmic_reg_write(p, r, v)	pmic_update_reg(p, r, v, #r)
+
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+
+	ret = power_bd71837_init(I2C_PMIC);
+	if (ret) {
+		printf("power init failed: %d\n", ret);
+		return ret;
+	}
+
+	p = pmic_get(PMIC_NAME);
+	if (!p) {
+		printf("PMIC %s not registered\n", PMIC_NAME);
+		return -ENODEV;
+	}
+
+	ret = pmic_probe(p);
+	if (ret)
+		goto out;
+
+	/* decrease RESET key long push time from the default 10s to 10ms */
+	ret = pmic_reg_write(p, BD71837_PWRONCONFIG1, 0x0);
+	if (ret)
+		goto out;
+
+	/* unlock the PMIC regs */
+	ret = pmic_reg_write(p, BD71837_REGLOCK, 0x1);
+	if (ret)
+		goto out;
+
+	/* increase VDD_DRAM to 0.9v for 3Ghz DDR */
+	ret = pmic_reg_write(p, BD71837_BUCK5_VOLT, 0x2);
+	if (ret)
+		goto out;
+
+	/* increase NVCC_DRAM_1V35 to 1.35v for DDR3L */
+	ret = pmic_reg_write(p, BD71837_BUCK8_VOLT, 0x37);
+	if (ret)
+		goto out;
+
+	/* lock the PMIC regs */
+	ret = pmic_reg_write(p, BD71837_REGLOCK, 0x11);
+
+ out:
+#ifndef CONFIG_SPL_DISABLE_BANNER_PRINT
+	printf("PMIC:  %s %s\n", PMIC_NAME, ret ? "FAILED" : "OK");
+#endif
+	return 0;
+}
+#else
+static inline int power_init_board(void)
+{
+	return 0;
+}
+#endif /* CONFIG_POWER && CONFIG_KARO_TX8MM */
+
+#ifdef CONFIG_KARO_QS8M
+#define pmic_i2c_addr		0x34
+
+static const struct {
+	u8 reg;
+	u8 val;
+	u8 mask;
+} qs8m_pmic_data[] = {
+	{ 0x50, 0, },
+	{ 0x5c, 0, },
+};
+
+static void qs8m_pmic_setup(void)
+{
+	int ret;
+	size_t i;
+
+	ret = i2c_probe(pmic_i2c_addr);
+	if (ret) {
+		printf("Could not find PMIC @%02x: %d\n", pmic_i2c_addr, ret);
+		return;
+	}
+	for (i = 0; i < ARRAY_SIZE(qs8m_pmic_data); i++) {
+		printf("%s: setting reg %02x to %02x\n", __func__,
+		       qs8m_pmic_data[i].reg, qs8m_pmic_data[i].val);
+		ret = i2c_write(pmic_i2c_addr, qs8m_pmic_data[i].reg, 1,
+				(uchar *)&qs8m_pmic_data[i].val, 1);
+		if (ret)
+			printf("Failed to write %02x to PMIC @%02x reg %02x: %d\n",
+			       qs8m_pmic_data[i].val, pmic_i2c_addr,
+			       qs8m_pmic_data[i].reg, ret);
+	}
+}
+#else
+static inline void qs8m_pmic_setup(void)
+{
+}
+#endif
+
+void spl_board_init(void)
+{
+	if (!IS_ENABLED(CONFIG_SPL_DISABLE_BANNER_PRINT))
+		puts("Normal Boot\n");
+
+	qs8m_pmic_setup();
+}
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	debug("%s: %s\n", __func__, name);
+	return 0;
+}
+#endif
+
+#define UART_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL0 |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t uart_pads[] = {
+	IMX8MM_PAD_UART1_RXD_UART1_RX | UART_PAD_CTRL,
+	IMX8MM_PAD_UART1_TXD_UART1_TX | UART_PAD_CTRL,
+};
+
+static int tx8m_spl_iomux_setup(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
+debug("%s@%d:\n", __func__, __LINE__);
+
+	return 0;
+}
+
+#if !IS_ENABLED(CONFIG_DM_I2C)
+static void tx8m_spl_i2c_setup(void)
+{
+	size_t i;
+
+debug("%s@%d:\n", __func__, __LINE__);
+	for (i = 0; i < ARRAY_SIZE(i2c_pad_info); i++) {
+		setup_i2c(i, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info[i]);
+	}
+};
+#else
+static inline void tx8m_spl_i2c_setup(void)
+{
+}
+#endif
+
+void board_init_f(ulong dummy)
+{
+	int ret;
+
+	/* Clear global data */
+	memset((void *)gd, 0, sizeof(gd_t));
+
+	arch_cpu_init();
+
+	tx8m_spl_iomux_setup();
+
+	timer_init();
+
+	preloader_console_init();
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	ret = spl_init();
+	if (ret) {
+		debug("spl_init() failed: %d\n", ret);
+		hang();
+	}
+
+	enable_tzc380();
+
+	tx8m_spl_i2c_setup();
+	power_init_board();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	board_init_r(NULL, 0);
+}
diff --git a/board/karo/tx8m/tx8m.c b/board/karo/tx8m/tx8m.c
new file mode 100644
index 0000000..a8d5bc5
--- /dev/null
+++ b/board/karo/tx8m/tx8m.c
@@ -0,0 +1,887 @@
+/*
+ * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <console.h>
+#include <errno.h>
+#include <fsl_esdhc.h>
+#include <fsl_wdog.h>
+#include <imx_mipi_dsi_bridge.h>
+#include <led.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <mipi_dsi_panel.h>
+#include <mmc.h>
+#include <netdev.h>
+#include <sec_mipi_dsim.h>
+#include <spl.h>
+#include <thermal.h>
+#include <asm-generic/gpio.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx8mm_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/armv8/mmu.h>
+#include <asm/mach-imx/dma.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/video.h>
+#include <dm/uclass.h>
+#include <power/pmic.h>
+#include "../common/karo.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_HYS |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_usdhc1_pads[] = {
+	IMX8MM_PAD_SD1_CLK_USDHC1_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_CMD_USDHC1_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA0_USDHC1_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA1_USDHC1_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA2_USDHC1_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA3_USDHC1_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA4_USDHC1_DATA4 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA5_USDHC1_DATA5 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA6_USDHC1_DATA6 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA7_USDHC1_DATA7 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_STROBE_USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
+	IMX8MM_PAD_SD1_RESET_B_USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc2_pads[] = {
+	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CD_B_GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc3_pads[] = {
+	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA02_GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
+};
+
+static struct tx8m_esdhc_cfg {
+	struct fsl_esdhc_cfg cfg;
+	int clk;
+	const iomux_v3_cfg_t *pads;
+	size_t num_pads;
+	int cd_gpio;
+} tx8mm_sdhc_cfgs[] = {
+	{
+		.cfg = {
+			.esdhc_base = USDHC1_BASE_ADDR,
+			.max_bus_width = 8,
+		},
+		.clk = MXC_ESDHC_CLK,
+		.pads = tx8mm_usdhc1_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc1_pads),
+		.cd_gpio = -EINVAL,
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC2_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC2_CLK,
+		.pads = tx8mm_usdhc2_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc2_pads),
+		.cd_gpio = IMX_GPIO_NR(2, 12),
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC3_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC3_CLK,
+		.pads = tx8mm_usdhc3_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc3_pads),
+		.cd_gpio = IMX_GPIO_NR(3, 8),
+	},
+};
+
+static inline struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(tx8mm_sdhc_cfgs); i++) {
+		struct tx8m_esdhc_cfg *cfg = &tx8mm_sdhc_cfgs[i];
+
+		if (priv->esdhc_base == cfg->cfg.esdhc_base)
+			return cfg;
+	}
+	return NULL;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
+
+	if (cfg == NULL) {
+		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
+		return 0;
+	}
+	if (cfg->cd_gpio < 0) {
+		debug("%s@%d: 1\n", __func__, __LINE__);
+		return 1;
+	}
+	debug("%s@%d: %d\n", __func__, __LINE__,
+	      !gpio_get_value(cfg->cd_gpio));
+	return !gpio_get_value(cfg->cd_gpio);
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (eMMC)
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+
+	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		struct mmc *mmc;
+		struct tx8m_esdhc_cfg *cfg;
+
+		if (i >= ARRAY_SIZE(tx8mm_sdhc_cfgs)) {
+			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
+			       CONFIG_SYS_FSL_USDHC_NUM,
+			       ARRAY_SIZE(tx8mm_sdhc_cfgs));
+			return -EINVAL;
+		}
+
+		cfg = &tx8mm_sdhc_cfgs[i];
+		if (cfg->cd_gpio >= 0) {
+			gpio_request(cfg->cd_gpio, "MMC CD");
+			gpio_direction_input(cfg->cd_gpio);
+		}
+		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
+		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
+
+		debug("%s@%d: Initialising MMC dev %zu @ %08llx clock=%u\n", __func__, __LINE__,
+		      i, cfg->cfg.esdhc_base, cfg->cfg.sdhc_clk);
+		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
+		if (ret) {
+			printf("Failed to initialize MMC%zu: %d\n", i, ret);
+			continue;
+		}
+
+		mmc = find_mmc_device(i);
+		if (mmc == NULL) {
+			printf("mmc device %zi not found\n", i);
+			continue;
+		}
+		if (board_mmc_getcd(mmc)) {
+			ret = mmc_init(mmc);
+			if (ret && ret != -EOPNOTSUPP)
+				printf("%s@%d: mmc_init(mmc%zi) failed: %d\n",
+				       __func__, __LINE__, i, ret);
+		} else {
+			debug("No Medium found in MMC slot %zi\n", i);
+		}
+	}
+	return 0;
+}
+#endif /* DM_MMC */
+
+#ifdef CONFIG_OF_BOARD_SETUP
+#include <asm/setup.h>
+#include <asm/bootm.h>
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	struct tag_serialnr serno;
+	char serno_str[64 / 4 + 1];
+
+	get_board_serial(&serno);
+	snprintf(serno_str, sizeof(serno_str), "%08x%08x",
+		 serno.high, serno.low);
+
+	printf("serial-number: %s\n", serno_str);
+
+	fdt_setprop(blob, 0, "serial-number", serno_str, strlen(serno_str));
+	fsl_fdt_fixup_dr_usb(blob, bd);
+	return 0;
+}
+#endif /* OF_BOARD_SETUP */
+
+#ifdef CONFIG_FEC_MXC
+#define MDIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_DSE6 |	\
+					     PAD_CTL_PE |	\
+					     PAD_CTL_PUE)
+
+#define FEC_IN_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL2)
+
+#define FEC_OUT_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_fec_pads[] = {
+	IMX8MM_PAD_ENET_MDC_ENET1_MDC | MDIO_PAD_CTRL, /* 0x146 */
+	IMX8MM_PAD_ENET_MDIO_ENET1_MDIO | MDIO_PAD_CTRL,
+	IMX8MM_PAD_ENET_TD2_ENET1_TX_CLK | MUX_MODE_SION | FEC_IN_PAD_CTRL, /* 0x40000016 */
+	IMX8MM_PAD_ENET_TD0_ENET1_RGMII_TD0 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MM_PAD_ENET_TD1_ENET1_RGMII_TD1 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MM_PAD_ENET_RD0_ENET1_RGMII_RD0 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RD1_ENET1_RGMII_RD1 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RXC_ENET1_RX_ER | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RX_CTL_ENET1_RGMII_RX_CTL | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_TX_CTL_ENET1_RGMII_TX_CTL | FEC_OUT_PAD_CTRL, /* 0x16 */
+};
+
+#include <fuse.h>
+static int tx8mm_etnphy_init(void)
+{
+	int ret;
+	struct gpio_desc enet0_pwr;
+	struct gpio_desc enet0_rst;
+
+	ret = dm_gpio_lookup_name("gpio1_23", &enet0_pwr);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_lookup_name("gpio1_29", &enet0_rst);
+	if (ret) {
+		printf("Failed to lookup ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_pwr, "ENET0_PWR");
+	if (ret) {
+		printf("Failed to request ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_rst, "ENET0_RST");
+	if (ret) {
+		printf("Failed to request ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	dm_gpio_set_dir_flags(&enet0_rst, GPIOD_IS_OUT);
+	dm_gpio_set_dir_flags(&enet0_pwr, GPIOD_IS_OUT);
+	dm_gpio_set_value(&enet0_rst, 0);
+	dm_gpio_set_value(&enet0_pwr, 1);
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_fec_pads,
+					 ARRAY_SIZE(tx8mm_fec_pads));
+
+	mdelay(25);
+	dm_gpio_set_value(&enet0_rst, 1);
+	mdelay(10);
+	return 0;
+}
+
+static int tx8mm_setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *iomuxc_gpr_regs =
+		(void *)IOMUXC_GPR_BASE_ADDR;
+	unsigned char mac[6];
+
+	set_clk_enet(ENET_50MHZ);
+
+	/* Use 50M anatop REF_CLK1 for ENET1, not from external */
+	setbits_le32(&iomuxc_gpr_regs->gpr[1],
+		     IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK);
+
+	imx_get_mac_from_fuse(0, mac);
+	printf("MAC addr: %pM\n", mac);
+
+	return tx8mm_etnphy_init();
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#else
+static inline int tx8mm_setup_fec(void)
+{
+	return 0;
+}
+#endif /* FEX_MXC */
+
+int dram_init(void)
+{
+	/* rom_pointer[1] contains the size of RAM occupied by TEE */
+	if (rom_pointer[1])
+		gd->ram_size = PHYS_SDRAM_SIZE - ALIGN(rom_pointer[1], PAGE_SIZE);
+	else
+		gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+int board_fix_fdt(void *blob)
+{
+	return 0;
+}
+
+#define GPIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_gpio_pads[] = {
+	IMX8MM_PAD_SD2_RESET_B_GPIO2_IO19 | GPIO_PAD_CTRL,
+};
+
+#ifdef CONFIG_SHOW_ACTIVITY
+enum {
+	LED_STATE_INIT = -1,
+	LED_STATE_OFF,
+	LED_STATE_ON,
+	LED_STATE_DISABLED,
+};
+
+static int led_state = LED_STATE_DISABLED;
+static bool tx8m_temp_check_enabled = true;
+static struct udevice *leddev;
+static struct udevice *thermaldev;
+
+#define TEMPERATURE_HOT		80
+#define TEMPERATURE_MIN		-40
+
+static inline int calc_blink_rate(void)
+{
+	int cpu_temp;
+	static int last_temp = INT_MAX;
+	static int avg_count;
+
+	if (!tx8m_temp_check_enabled)
+		return CONFIG_SYS_HZ;
+
+	if (!thermaldev || thermal_get_temp(thermaldev, &cpu_temp))
+		return CONFIG_SYS_HZ / 2;
+
+	if (last_temp == INT_MAX) {
+		last_temp = cpu_temp;
+	} else if (cpu_temp != last_temp) {
+		static int cpu_temps[4];
+
+		if (thermal_get_temp(thermaldev, &cpu_temps[avg_count]))
+			return CONFIG_SYS_HZ / 2;
+		if (++avg_count >= ARRAY_SIZE(cpu_temps)) {
+			int bad = -1;
+			int i;
+
+			for (i = 0; i < avg_count; i++) {
+				if (cpu_temp != cpu_temps[i])
+					bad = i;
+			}
+			if (bad < 0) {
+				debug("CPU temperature changed from %d to %d\n",
+				      last_temp, cpu_temp);
+				last_temp = cpu_temp;
+			} else {
+				debug("Spurious CPU temperature reading %d -> %d -> %d\n",
+				      cpu_temp, cpu_temps[bad], cpu_temps[i - 1]);
+			}
+			avg_count = 0;
+		}
+	} else {
+		avg_count = 0;
+	}
+	return CONFIG_SYS_HZ + CONFIG_SYS_HZ / 10 -
+		(last_temp - TEMPERATURE_MIN) * CONFIG_SYS_HZ /
+		(TEMPERATURE_HOT - TEMPERATURE_MIN);
+}
+
+void show_activity(int arg)
+{
+	static int blink_rate;
+	static ulong last;
+	int ret;
+
+	if (led_state == LED_STATE_DISABLED)
+		return;
+
+	if (led_state == LED_STATE_INIT) {
+		last = get_timer(0);
+		ret = led_set_state(leddev, LEDST_ON);
+		if (ret == 0)
+			led_state = LED_STATE_ON;
+		else
+			led_state = LED_STATE_DISABLED;
+		blink_rate = calc_blink_rate();
+	} else {
+		if (get_timer(last) > blink_rate) {
+			blink_rate = calc_blink_rate();
+			last = get_timer(0);
+			if (led_state == LED_STATE_ON) {
+				ret = led_set_state(leddev, LEDST_OFF);
+			} else {
+				ret = led_set_state(leddev, LEDST_ON);
+			}
+			if (ret == 0)
+				led_state = 1 - led_state;
+			else
+				led_state = LED_STATE_DISABLED;
+		}
+	}
+
+}
+
+static void tx8m_led_init(void)
+{
+	int ret;
+
+	ret = led_get_by_label("Heartbeat", &leddev);
+	if (ret) {
+		printf("Failed to find LED device: %d\n", ret);
+		return;
+	}
+
+	ret = uclass_get_device_by_name(UCLASS_THERMAL, "cpu-thermal",
+					&thermaldev);
+	if (ret)
+		printf("Failed to find THERMAL device: %d\n", ret);
+
+	led_state = LED_STATE_INIT;
+}
+#else
+static inline void tx8m_led_init(void)
+{
+	debug("%s@%d: \n", __func__, __LINE__);
+}
+#endif /* SHOW_ACTIVITY */
+
+int checkboard(void)
+{
+#if defined(CONFIG_KARO_TX8MM) || defined(CONFIG_KARO_TX8MN)
+	if (is_imx8mm())
+		printf("Board: Ka-Ro TX8M-1610\n");
+	else if (is_imx8mn())
+		printf("Board: Ka-Ro TX8M-ND00\n");
+	else
+		printf("Board: <unsupported processor type>\n");
+#elif defined(CONFIG_KARO_QS8M)
+	if (is_imx8mm())
+		printf("Board: Ka-Ro QS8M-MQ00\n");
+	else
+		printf("Board: Ka-Ro QS8M-ND00\n");
+#else
+#error Unsupported module variant
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_DM_I2C
+static inline int tx8mm_i2c_init(void)
+{
+	int ret = 0;
+	int i;
+
+	for (i = 0; ret != -ENODEV; i++) {
+		struct udevice *i2c_dev;
+		u8 i2c_addr;
+
+		ret = uclass_get_device_by_seq(UCLASS_I2C, i, &i2c_dev);
+		if (ret == -ENODEV)
+			break;
+
+		for (i2c_addr = 0x07; i2c_addr < 0x78; i2c_addr++) {
+			struct udevice *chip;
+
+			ret = dm_i2c_probe(i2c_dev, i2c_addr, 0x0, &chip);
+			if (ret == 0) {
+				printf("Found an I2C device @ %u:%02x\n",
+				       i, i2c_addr);
+			} else if (ret != -EREMOTEIO) {
+				printf("Error %d accessing device %u:%02x\n",
+				       ret, i, i2c_addr);
+				break;
+			}
+		}
+	}
+	return ret;
+}
+#else
+static int tx8mm_i2c_init(void)
+{
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	int ret;
+	struct gpio_desc reset_out;
+
+	tx8mm_setup_fec();
+
+	//tx8mm_i2c_init();
+
+	ret = dm_gpio_lookup_name("gpio2_19", &reset_out);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+	ret = dm_gpio_request(&reset_out, "RESET_OUT");
+	if (ret) {
+		printf("Failed to request RESET_OUT GPIO: %d\n", ret);
+		return ret;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_gpio_pads,
+					 ARRAY_SIZE(tx8mm_gpio_pads));
+	tx8m_led_init();
+	return ret;
+}
+
+#ifdef CONFIG_BOARD_EARLY_INIT_R
+int board_early_init_r(void)
+{
+	return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+	int ret;
+	struct src *src_regs = (void *)SRC_BASE_ADDR;
+	struct watchdog_regs *wdog = (void *)WDOG1_BASE_ADDR;
+	u32 srsr = readl(&src_regs->srsr);
+	u16 wrsr = readw(&wdog->wrsr);
+	const char *fdt_file = env_get("fdt_file");
+
+	karo_env_cleanup();
+	if (srsr & 0x10 && !(wrsr & WRSR_SFTW))
+		env_set("wdreset", "1");
+	if (had_ctrlc())
+		env_set("safeboot", "1");
+	if (fdt_file) {
+		ret = karo_load_fdt(fdt_file);
+		if (ret)
+			printf("Failed to load FDT from '%s': %d\n",
+			       fdt_file, ret);
+	}
+	return 0;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 1;
+}
+
+void board_quiesce_devices(void)
+{
+}
+
+#ifdef CONFIG_VIDEO
+static const struct sec_mipi_dsim_plat_data imx8mm_mipi_dsim_plat_data = {
+	.version	= 0x1060200,
+	.max_data_lanes = 4,
+	.max_data_rate  = 1500000000ULL,
+	.reg_base = MIPI_DSI_BASE_ADDR,
+	.gpr_base = CSI_BASE_ADDR + 0x8000,
+};
+
+#define DSI_DDR_MODE 0
+
+struct mipi_dsi_client_dev dsi83_dev = {
+	.channel = 0,
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+	.name = "DSI83",
+};
+
+#define DISPLAY_MIX_SFT_RSTN_CSR	0x00
+#define DISPLAY_MIX_CLK_EN_CSR		0x04
+
+   /* 'DISP_MIX_SFT_RSTN_CSR' bit fields */
+#define BUS_RSTN_BLK_SYNC_SFT_EN	BIT(6)
+
+   /* 'DISP_MIX_CLK_EN_CSR' bit fields */
+#define LCDIF_PIXEL_CLK_SFT_EN		BIT(7)
+#define LCDIF_APB_CLK_SFT_EN		BIT(6)
+
+static void disp_mix_bus_rstn_reset(ulong gpr_base, bool reset)
+{
+	if (!reset)
+		/* release reset */
+		setbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
+			     BUS_RSTN_BLK_SYNC_SFT_EN);
+	else
+		/* hold reset */
+		clrbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
+			     BUS_RSTN_BLK_SYNC_SFT_EN);
+}
+
+static void disp_mix_lcdif_clks_enable(ulong gpr_base, bool enable)
+{
+	if (enable)
+		/* enable lcdif clks */
+		setbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
+			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
+	else
+		/* disable lcdif clks */
+		clrbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
+			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
+}
+
+#define LINE_LENGTH	1280
+#define H_FRONT_PORCH	64
+#define H_BACK_PORCH	4
+#define HSYNC_LEN	1
+#define VERT_SIZE	800
+#define V_FRONT_PORCH	40
+#define V_BACK_PORCH	1
+#define VSYNC_LEN	1
+#define VREFRESH	60
+
+#define BPP	24
+#define SYNC_DELAY	64
+#define HTOTAL		(HSYNC_LEN + H_BACK_PORCH + LINE_LENGTH + H_FRONT_PORCH)
+#define VTOTAL		(VSYNC_LEN + V_BACK_PORCH + VERT_SIZE + V_FRONT_PORCH)
+#define PCLK		(HTOTAL * VTOTAL * VREFRESH)
+#define DSI_CLK		(PCLK * BPP / 4 / (!!DSI_DDR_MODE + 1))
+#define DSI_CLK_DIV	((DSI_CLK + PCLK - 1) / PCLK)
+#define LVDS_CLK	(DSI_CLK / DSI_CLK_DIV)
+#define LVDS_CLK_DIV	((LVDS_CLK + 12500000) / 25000000 - 1)
+
+static struct dsi83_data {
+	u8 addr;
+	u8 val;
+	u8 mask;
+} dsi83_data[] = {
+	{ 0x09, 1, },
+	{ 0x0d, 0x00, 0x01, },
+	{ 0x10, 0x00, 0x18, }, // DSI lanes 0x00: 4 lanes; 0x08: 3 lanes
+	{ 0x10, 0x00, 0x01, }, // SOT_ERR_TOL_DIS
+	{ 0x11, 0xc0, 0xc0, }, // DSI DATA equalization
+	{ 0x11, 0x0c, 0x0c, }, // DSI clock equalization
+	{ 0x12, DSI_CLK / 1000000 / 5, }, // DSI clk range 8: 40..45MHz; 9: 45..50MHz; ...
+	{ 0x0a, 0x01, 0x01, },
+	{ 0x0a, LVDS_CLK_DIV << 1, 0x0e, },
+	{ 0x0b, 0x00, 0x03, },
+	{ 0x0b, (DSI_CLK_DIV - 1) << 3, 0x7c, },
+	{ 0x18, 0x60, 0xe0, }, // DE_NEG HS_NEG VS_NEG
+	{ 0x18, 0x08, 0x9, }, // CHA_24BPP_MODE CHA24BPP_FORMAT1
+	{ 0x20, LINE_LENGTH % 256, },
+	{ 0x21, LINE_LENGTH / 256, },
+	{ 0x24, VERT_SIZE % 256, },
+	{ 0x25, VERT_SIZE / 256, },
+	{ 0x28, SYNC_DELAY % 256, },
+	{ 0x29, SYNC_DELAY / 256, },
+	{ 0x2c, HSYNC_LEN % 256, },
+	{ 0x2d, HSYNC_LEN / 256, },
+	{ 0x30, VSYNC_LEN % 256, },
+	{ 0x31, VSYNC_LEN / 256, },
+	{ 0x34, H_BACK_PORCH + HSYNC_LEN, },
+	{ 0x36, V_BACK_PORCH + VSYNC_LEN, },
+	{ 0x38, H_FRONT_PORCH, },
+	{ 0x3a, V_FRONT_PORCH, },
+	//{ 0x3c, 0x10, 0x10, }, // enable CHA_TEST_PATTERN
+	{ 0x3c, 0x00, },
+	{ 0x0d, 0x01, 0x01, }, // enable PLL
+	{ 0xe5, 0xfd, 0xfd, }, // clear error status
+};
+
+#define DSI83_SLAVE_ADDR	0x2c
+
+static int dsi83_init(void)
+{
+	int ret;
+	struct udevice *dev;
+	struct udevice *chip;
+	u8 val;
+
+	debug("DSI clock: %u.%03uMHz dsi_clk_div=%u\n",
+	      DSI_CLK / 1000000, DSI_CLK / 1000 % 1000, DSI_CLK_DIV);
+	debug("LVDS clock: %u.%03uMHz lvds_clk_range=%u\n",
+	      LVDS_CLK / 1000000, LVDS_CLK / 1000 % 1000, LVDS_CLK_DIV);
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, 1, &dev);
+	if (ret) {
+		printf("%s: Failed to find I2C bus device: %d\n",
+		       __func__, ret);
+		return ret;
+	}
+	ret = dm_i2c_probe(dev, DSI83_SLAVE_ADDR, 0x0, &chip);
+	if (ret) {
+		printf("%s: I2C probe failed for slave addr %02x: %d\n",
+		       __func__, DSI83_SLAVE_ADDR, ret);
+		return ret;
+	}
+	for (size_t i = 0; i < ARRAY_SIZE(dsi83_data); i++) {
+		struct dsi83_data *p = &dsi83_data[i];
+
+		ret = dm_i2c_read(chip, p->addr, &val, 1);
+		if (ret) {
+			printf("%s: Failed to read reg %02x\n",
+			       __func__, p->val);
+			return ret;
+		}
+		debug("%s@%d: Read %02x from reg %02x\n",
+		      __func__, __LINE__, val, p->addr);
+		val = (val & ~p->mask) | p->val;
+		debug("%s@%d: Writing %02x to reg %02x\n",
+		      __func__, __LINE__, val, p->addr);
+		ret = dm_i2c_write(chip, p->addr, &val, 1);
+		if (ret) {
+			printf("%s: Failed to write %02x to reg %02x\n",
+			       __func__, p->val, p->addr);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static const iomux_v3_cfg_t tx8mm_lcd_pads[] = {
+	IMX8MM_PAD_GPIO1_IO01_GPIO1_IO1 | GPIO_PAD_CTRL,
+	IMX8MM_PAD_GPIO1_IO04_GPIO1_IO4 | GPIO_PAD_CTRL,
+};
+
+static void tx8m_backlight_enable(void)
+{
+	int ret;
+	struct gpio_desc backlight_control;
+	struct gpio_desc lcd_enable;
+
+	ret = dm_gpio_lookup_name("gpio1_1", &backlight_control);
+	if (ret == 0) {
+		ret = dm_gpio_request(&backlight_control, "BACKLIGHT_CONTROL");
+		if (ret == 0) {
+			dm_gpio_set_dir_flags(&backlight_control, GPIOD_IS_OUT);
+			dm_gpio_set_value(&backlight_control, 1);
+		} else {
+			printf("Failed to request BACKLIGHT_CONTROL GPIO: %d\n",
+			       ret);
+		}
+	} else {
+		printf("Failed to lookup BACKLIGHT_CONTROL GPIO: %d\n", ret);
+	}
+
+	ret = dm_gpio_lookup_name("gpio1_4", &lcd_enable);
+	if (ret == 0) {
+		ret = dm_gpio_request(&lcd_enable, "LCD_ENABLE");
+		if (ret == 0) {
+			dm_gpio_set_dir_flags(&lcd_enable, GPIOD_IS_OUT);
+			dm_gpio_set_value(&lcd_enable, 1);
+		} else {
+			printf("Failed to request LCD_ENABLE GPIO: %d\n", ret);
+		}
+	} else {
+		printf("Failed to lookup LCD_ENABLE GPIO: %d\n", ret);
+	}
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_lcd_pads,
+					 ARRAY_SIZE(tx8mm_lcd_pads));
+}
+
+#define FSL_SIP_GPC			0xC2000000
+#define FSL_SIP_CONFIG_GPC_PM_DOMAIN	0x3
+#define DISPMIX				9
+#define MIPI				10
+
+static void do_enable_mipi2lvds(struct display_info_t const *disp)
+{
+	/* enable the dispmix & mipi phy power domain */
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
+		     DISPMIX, true, 0);
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
+		     MIPI, true, 0);
+
+	/* Get lcdif out of reset */
+	disp_mix_bus_rstn_reset(imx8mm_mipi_dsim_plat_data.gpr_base, false);
+	disp_mix_lcdif_clks_enable(imx8mm_mipi_dsim_plat_data.gpr_base, true);
+
+	sec_mipi_dsim_setup(&imx8mm_mipi_dsim_plat_data);
+	imx_mipi_dsi_bridge_attach(&dsi83_dev);
+	dsi83_init();
+	tx8m_backlight_enable();
+}
+
+static struct display_info_t const panel_info[] = {
+	{
+		.bus = LCDIF_BASE_ADDR,
+		.pixfmt = BPP,
+		.enable	= do_enable_mipi2lvds,
+		.mode	= {
+			.name		= "MIPI2LVDS",
+			.refresh	= VREFRESH,
+			.xres		= LINE_LENGTH,
+			.yres		= VERT_SIZE,
+			.pixclock	= KHZ2PICOS(PCLK / 1000),
+			.left_margin	= H_BACK_PORCH,
+			.hsync_len	= HSYNC_LEN,
+			.right_margin	= H_FRONT_PORCH,
+			.upper_margin	= V_BACK_PORCH,
+			.vsync_len	= VSYNC_LEN,
+			.lower_margin	= V_FRONT_PORCH,
+			.sync		= FB_SYNC_EXT,
+			.vmode		= FB_VMODE_NONINTERLACED,
+		},
+	},
+};
+
+int board_video_skip(void)
+{
+	int ret;
+	const char *baseboard = env_get("baseboard");
+	const char *panel = env_get("panel");
+	size_t i;
+
+	if (had_ctrlc()) {
+		printf("<CTRL-C> detected; disabling display\n");
+		return 1;
+	}
+
+	if (!panel) {
+		printf("No LCD panel configured\n");
+		return 1;
+	}
+
+	if (!baseboard || strcmp(baseboard, "mipi-mb") != 0) {
+		printf("No Display support for '%s' baseboard\n",
+		       baseboard ?: "unspecified");
+		return 1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(panel_info); i++) {
+		const struct display_info_t *pi = &panel_info[i];
+
+		if (strcmp(panel, pi->mode.name) != 0)
+			continue;
+
+		ret = mxs_lcd_panel_setup(pi->mode,
+					  pi->pixfmt,
+					  pi->bus);
+		if (ret)
+			return ret;
+
+		if (pi->enable)
+			pi->enable(panel_info + i);
+
+		printf("Display: %s (%ux%u)\n", pi->mode.name,
+		       pi->mode.xres, pi->mode.yres);
+	}
+	return ret;
+}
+#endif
diff --git a/board/karo/tx8mm/Kconfig b/board/karo/tx8mm/Kconfig
deleted file mode 100644
index 1d6fecf..0000000
--- a/board/karo/tx8mm/Kconfig
+++ /dev/null
@@ -1,38 +0,0 @@
-if TARGET_TX8M
-
-config SYS_BOARD
-	default "tx8mm"
-
-config SYS_CONFIG_NAME
-	default "tx8mm"
-
-config SYS_VENDOR
-	default "karo"
-
-config TX8MM
-	bool
-	default y
-	select BOARD_LATE_INIT
-	imply FEC_MXC
-	select MII
-	select PHYLIB
-	select MXC_UART
-
-choice
-        prompt "U-Boot image variant"
-	default TX8MM_UBOOT
-
-config TX8MM_UBOOT
-        bool "Standard U-Boot image"
-
-config TX8MM_UBOOT_MFG
-        bool "U-Boot image for use with Freescale's MfGTool"
-        select UBOOT_IGNORE_ENV
-
-config TX8MM_UBOOT_NOENV
-        bool "U-Boot using only built-in environment"
-        select UBOOT_IGNORE_ENV
-
-endchoice
-
-endif
diff --git a/board/karo/tx8mm/Makefile b/board/karo/tx8mm/Makefile
deleted file mode 100644
index 3a5a9eb..0000000
--- a/board/karo/tx8mm/Makefile
+++ /dev/null
@@ -1,12 +0,0 @@
-#
-# Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
-#
-# SPDX-License-Identifier:      GPL-2.0+
-#
-
-ifdef CONFIG_SPL_BUILD
-obj-y += spl.o
-obj-y += ddr/
-else
-obj-y += tx8mm.o
-endif
diff --git a/board/karo/tx8mm/ddr/Makefile b/board/karo/tx8mm/ddr/Makefile
deleted file mode 100644
index 30b5b92..0000000
--- a/board/karo/tx8mm/ddr/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
-#
-# SPDX-License-Identifier:      GPL-2.0+
-#
-
-ifdef CONFIG_SPL_BUILD
-obj-y += helper.o wait_ddrphy_training_complete.o
-obj-$(CONFIG_TARGET_TX8M) += ddrphy_train.o ddr_init.o
-endif
diff --git a/board/karo/tx8mm/ddr/ddr.h b/board/karo/tx8mm/ddr/ddr.h
deleted file mode 100644
index 66cefce..0000000
--- a/board/karo/tx8mm/ddr/ddr.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier: GPL-2.0+
- * Common file for ddr code
- */
-
-#ifndef __M845S_DDR_H_
-#define __M845S_DDR_H_
-
-#ifdef DDR_DEBUG
-#define ddr_dbg(fmt, ...) printf("DDR: debug:" fmt, ##__VA_ARGS__)
-#else
-#define ddr_dbg(fmt, ...) do {} while (0)
-#endif
-
-/*******************************************************************
- Desc: user data type
-
- *******************************************************************/
-enum fw_type {
-	FW_1D_IMAGE,
-	FW_2D_IMAGE,
-};
-/*******************************************************************
- Desc: prototype
-
- *******************************************************************/
-void ddr_init(void);
-void ddr_load_train_code(enum fw_type type);
-void wait_ddrphy_training_complete(void);
-void dwc_ddrphy_phyinit_userCustom_E_setDfiClk(unsigned int pstate);
-void dwc_ddrphy_phyinit_userCustom_J_enterMissionMode(void);
-void dwc_ddrphy_phyinit_userCustom_customPostTrain(void);
-void dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy(void);
-void dwc_ddrphy_phyinit_userCustom_A_bringupPower(void);
-void dwc_ddrphy_phyinit_userCustom_overrideUserInput(void);
-void dwc_ddrphy_phyinit_userCustom_H_readMsgBlock(unsigned int run_2D);
-void dwc_ddrphy_phyinit_userCustom_G_waitFwDone(void);
-
-/*******************************************************************
- Desc: definition
-
- *******************************************************************/
-static inline void reg32_write(unsigned long addr, u32 val)
-{
-	writel(val, addr);
-}
-
-static inline uint32_t reg32_read(unsigned long addr)
-{
-	return readl(addr);
-}
-
-static inline void reg32setbit(unsigned long addr, u32 bit)
-{
-	setbits_le32(addr, (1 << bit));
-}
-#endif
diff --git a/board/karo/tx8mm/ddr/ddr3l/Makefile b/board/karo/tx8mm/ddr/ddr3l/Makefile
deleted file mode 100644
index dac4d50..0000000
--- a/board/karo/tx8mm/ddr/ddr3l/Makefile
+++ /dev/null
@@ -1,13 +0,0 @@
-#
-# Copyright 2018 NXP
-#
-# SPDX-License-Identifier:      GPL-2.0+
-#
-
-ifdef CONFIG_SPL_BUILD
-obj-y += ddr3_phyinit_task.o
-obj-y += ddr3_phyinit_train_sw_ffc_fw09.o
-obj-y += ddr3_sw_fast_freq_chg_fw09.o
-obj-y += restore_1d2d_trained_csr_ddr3_p012.o
-obj-y += save_1d2d_trained_csr_ddr3_p012.o
-endif
diff --git a/board/karo/tx8mm/ddr/ddr3l/anamix_common.h b/board/karo/tx8mm/ddr/ddr3l/anamix_common.h
deleted file mode 100644
index 2413fe1..0000000
--- a/board/karo/tx8mm/ddr/ddr3l/anamix_common.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier: GPL-2.0+
- */
-
-#ifndef ANAMIX_COMMON_TMP_H
-#define ANAMIX_COMMON_TMP_H
-
-/* ANAMIX Address Definitions */
-#define ANAMIX_PLL_BASE_ADDR		0x30360000
-#define ANAMIX_OSC_BASE_ADDR		0x30270000
-#define ANAMIX_TSN_BASE_ADDR		0x30260000
-
-/*  PLL TOP REG */
-#define AUDIO_PLL1_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x00)
-#define AUDIO_PLL1_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x04)
-#define AUDIO_PLL1_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x08)
-#define AUDIO_PLL1_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x0c)
-#define AUDIO_PLL1_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x10)
-#define AUDIO_PLL2_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x14)
-#define AUDIO_PLL2_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x18)
-#define AUDIO_PLL2_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x1c)
-#define AUDIO_PLL2_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x20)
-#define AUDIO_PLL2_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x24)
-#define VIDEO_PLL1_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x28)
-#define VIDEO_PLL1_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x2c)
-#define VIDEO_PLL1_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x30)
-#define VIDEO_PLL1_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x34)
-#define VIDEO_PLL1_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x38)
-#define VIDEO_PLL2_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x3c)
-#define VIDEO_PLL2_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x40)
-#define VIDEO_PLL2_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x44)
-#define VIDEO_PLL2_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x48)
-#define VIDEO_PLL2_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x4c)
-#define DRAM_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x50)
-#define DRAM_PLL_FDIV_CTL0_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x54)
-#define DRAM_PLL_FDIV_CTL1_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x58)
-#define DRAM_PLL_SSCG_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x5c)
-#define DRAM_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x60)
-#define GPU_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x64)
-#define GPU_PLL_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x68)
-#define GPU_PLL_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x6c)
-#define GPU_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x70)
-#define VPU_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x74)
-#define VPU_PLL_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x78)
-#define VPU_PLL_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x7c)
-#define VPU_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x80)
-#define ARM_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x84)
-#define ARM_PLL_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x88)
-#define ARM_PLL_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x8c)
-#define ARM_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x90)
-#define SYS_PLL1_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x94)
-#define SYS_PLL1_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x98)
-#define SYS_PLL1_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x9c)
-#define SYS_PLL1_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x100)
-#define SYS_PLL2_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x104)
-#define SYS_PLL2_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x108)
-#define SYS_PLL2_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x10c)
-#define SYS_PLL2_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x110)
-#define SYS_PLL3_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x114)
-#define SYS_PLL3_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x118)
-#define SYS_PLL3_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x11c)
-#define SYS_PLL3_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x120)
-#define ANAMIX_MISC_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x124)
-#define ANAMIX_CLK_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x128)
-
-/* TMP SNSR REG */
-#define TER_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x00)
-#define TSR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x04)
-#define TIER_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x08)
-#define TIDR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x0c)
-#define TMHTITR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x10)
-#define TMHTATR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x14)
-#define TMHTACTR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x18)
-#define TSCR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x1c)
-#define TRITSR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x20)
-#define TRATSR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x24)
-#define TASR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x28)
-#define TTMC_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x2c)
-
-/* OSC */
-#define SYS_OSCNML_CTL0_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x00)
-#define SYS_OSCNML_CTL1_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x04)
-#define HDMI_OSCNML_CTL0_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x8000)
-#define HDMI_OSCNML_CTL1_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x8004)
-
-#endif
diff --git a/board/karo/tx8mm/ddr/ddr3l/ddr3_define.h b/board/karo/tx8mm/ddr/ddr3l/ddr3_define.h
deleted file mode 100644
index e2ce727..0000000
--- a/board/karo/tx8mm/ddr/ddr3l/ddr3_define.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier: GPL-2.0+
- */
-
-#ifndef DDR3_DEFINE_H
-#define DDR3_DEFINE_H
-
-#include "../ddr.h"
-
-#define RUN_ON_SILICON
-
-#ifdef DDR3_1600MTS_SWFFC_RET
-	#define DDR3_SW_FFC
-#endif
-
-#define SAVE_DDRPHY_TRAIN_ADDR		0x180000
-#define DDR_CSD1_BASE_ADDR		0x40000000
-#define DDR_CSD2_BASE_ADDR		0x80000000
-
-#define ANAMIX_PLL_BASE_ADDR		0x30360000
-#define HW_DRAM_PLL_CFG0_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x60)
-#define HW_DRAM_PLL_CFG1_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x64)
-#define HW_DRAM_PLL_CFG2_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x68)
-#define GPC_PU_PWRHSK			0x303A01FC
-#define GPC_TOP_CONFIG_OFFSET		0x0000
-#define AIPS1_ARB_BASE_ADDR		0x30000000
-#define AIPS_TZ1_BASE_ADDR		AIPS1_ARB_BASE_ADDR
-#define AIPS1_OFF_BASE_ADDR		(AIPS_TZ1_BASE_ADDR + 0x200000)
-#define CCM_IPS_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x180000)
-#define CCM_SRC_CTRL_OFFSET		(CCM_IPS_BASE_ADDR + 0x800)
-#define CCM_SRC_CTRL(n)			(CCM_SRC_CTRL_OFFSET + 0x10 * (n))
-
-#define dwc_ddrphy_apb_wr(addr, data)	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * (addr), data)
-#define dwc_ddrphy_apb_rd(addr)		reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * (addr))
-#define	 reg32clrbit(addr, bitpos)	reg32_write((addr), reg32_read(addr) & ~(1 << (bitpos)))
-
-void restore_1d2d_trained_csr_ddr3_p012(unsigned int addr);
-void save_1d2d_trained_csr_ddr3_p012(unsigned int addr);
-void ddr3_phyinit_train_sw_ffc(unsigned int after_retention);
-
-#endif
diff --git a/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c b/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c
deleted file mode 100644
index fb1bfe4..0000000
--- a/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier: GPL-2.0+
- */
-
-#include <common.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/ddr.h>
-#include <asm/arch/clock.h>
-#include "ddr3_define.h"
-
-void dwc_ddrphy_phyinit_userCustom_E_setDfiClk (unsigned int pstate) {
-	if (pstate == 0) {
-		ddr_dbg("C: 1 ...\n");
-		dram_pll_init(DRAM_PLL_OUT_400M);
-	} else if (pstate == 1) {
-		ddr_dbg("C: 2 ...\n");
-		dram_pll_init(DRAM_PLL_OUT_266M);
-	} else if (pstate == 2) {
-		ddr_dbg("C: 3 ...\n");
-		dram_pll_init(DRAM_PLL_OUT_167M);
-	} else {
-		printf("C: no freq match\n");
-	}
-}
-
-void dwc_ddrphy_phyinit_userCustom_G_waitFwDone(void)
-{
-	wait_ddrphy_training_complete();
-}
-void dwc_ddrphy_phyinit_userCustom_overrideUserInput (void) {}
-void dwc_ddrphy_phyinit_userCustom_A_bringupPower (void) {}
-void dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy (void) {}
-void dwc_ddrphy_phyinit_userCustom_H_readMsgBlock(unsigned int Train2D) {}
-void dwc_ddrphy_phyinit_userCustom_customPostTrain(void) {}
-void dwc_ddrphy_phyinit_userCustom_J_enterMissionMode(void) {}
-
-void ddr3_mr_write(unsigned int mr, unsigned int data, unsigned int read, unsigned int rank)
-{
-	unsigned int tmp, mr_mirror, data_mirror;
-
-	/* 1. Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction. No */
-	/* writes should be performed to MRCTRL0 and MRCTRL1 if MRSTAT.mr_wr_busy = 1. */
-	do {
-		tmp = reg32_read(DDRC_MRSTAT(0));
-	} while (tmp & 0x1);
-
-	/* 2. Write the MRCTRL0.mr_type, MRCTRL0.mr_addr, MRCTRL0.mr_rank and (for MRWs) */
-	/* MRCTRL1.mr_data to define the MR transaction. */
-	/*  (A3, A4), (A5, A6), (A7, A8), (BA0, BA1),*/
-	tmp = reg32_read(DDRC_DIMMCTL(0));
-	if ((tmp & 0x2) && (rank == 0x2)) {
-	    mr_mirror = (mr & 0x4) | ((mr & 0x1) << 1) | ((mr & 0x2) >> 1);/* BA0, BA1 swap */
-		data_mirror = (data & 0xfe07) | ((data & 0x8) << 1) | ((data & 0x10) >> 1) | ((data & 0x20) << 1) | ((data & 0x40) >> 1) | ((data & 0x80) << 1) | ((data & 0x100) >> 1);
-	} else {
-	    mr_mirror = mr;
-	    data_mirror = data;
-	}
-
-	reg32_write(DDRC_MRCTRL0(0), read | (mr_mirror << 12) | (rank << 4));
-	reg32_write(DDRC_MRCTRL1(0), data_mirror);
-
-	/* 3. In a separate APB transaction, write the MRCTRL0.mr_wr to 1. This bit is self-clearing, and triggers */
-	/* the MR transaction. The uMCTL2 then asserts the MRSTAT.mr_wr_busy while it performs the MR */
-	/* transaction to SDRAM, and no further accesses can be initiated until it is deasserted. */
-	reg32setbit(DDRC_MRCTRL0(0), 31);
-	do {
-		tmp = reg32_read(DDRC_MRSTAT(0));
-	} while (tmp);
-
-}
diff --git a/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c b/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c
deleted file mode 100644
index 0cf71a7..0000000
--- a/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c
+++ /dev/null
@@ -1,1156 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier: GPL-2.0+
- */
-
-#include <common.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/ddr.h>
-#include <asm/arch/clock.h>
-#include "../ddr.h"
-#include "ddr3_define.h"
-
-void ddr3_phyinit_train_sw_ffc(unsigned int after_retention)
-{
-	/*  [dwc_ddrphy_phyinit_main] Start of dwc_ddrphy_phyinit_main() */
-	/*  [dwc_ddrphy_phyinit_sequence] Start of dwc_ddrphy_phyinit_sequence() */
-	/*  [dwc_ddrphy_phyinit_initStruct] Start of dwc_ddrphy_phyinit_initStruct() */
-	/*  [dwc_ddrphy_phyinit_initStruct] End of dwc_ddrphy_phyinit_initStruct() */
-	/*  [dwc_ddrphy_phyinit_setDefault] Start of dwc_ddrphy_phyinit_setDefault() */
-	/*  [dwc_ddrphy_phyinit_setDefault] End of dwc_ddrphy_phyinit_setDefault() */
-
-
-	/*  ############################################################## */
-	/*  */
-	/*   dwc_ddrphy_phyinit_userCustom_overrideUserInput is a user-editable function. */
-	/*   */
-	/*   See PhyInit App Note for detailed description and function usage */
-	/*  */
-	/*  ############################################################## */
-
-	dwc_ddrphy_phyinit_userCustom_overrideUserInput ();
-	/*  */
-	/*   [dwc_ddrphy_phyinit_userCustom_overrideUserInput] End of dwc_ddrphy_phyinit_userCustom_overrideUserInput() */
-
-
-	/*  ############################################################## */
-	/*   */
-	/*   Step (A) : Bring up VDD, VDDQ, and VAA */
-	/*   */
-	/*   See PhyInit App Note for detailed description and function usage */
-	/*   */
-	/*  ############################################################## */
-
-
-	dwc_ddrphy_phyinit_userCustom_A_bringupPower ();
-
-	/*  [dwc_ddrphy_phyinit_userCustom_A_bringupPower] End of dwc_ddrphy_phyinit_userCustom_A_bringupPower() */
-	/*  [dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy] Start of dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy() */
-	/*  */
-	/*  */
-	/*  ############################################################## */
-	/*   */
-	/*   Step (B) Start Clocks and Reset the PHY */
-	/*   */
-	/*   See PhyInit App Note for detailed description and function usage */
-	/*   */
-	/*  ############################################################## */
-	/*  */
-	/*  */
-	dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy ();
-
-	/*  [dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy] End of dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy() */
-	/*  */
-
-	/*  ############################################################## */
-	/*   */
-	/*   Step (C) Initialize PHY Configuration */
-	/*   */
-	/*   Load the required PHY configuration registers for the appropriate mode and memory configuration */
-	/*   */
-	/*  ############################################################## */
-	/*  */
-
-	/*   [phyinit_C_initPhyConfig] Start of dwc_ddrphy_phyinit_C_initPhyConfig() */
-	/*  */
-	/*  ############################################################## */
-	/*   TxPreDrvMode[2] = 0 */
-	/*  ############################################################## */
-	/*   [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxSlewRate::TxPreDrvMode to 0x3 */
-	/*   [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxSlewRate::TxPreP to 0xf */
-	/*   [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxSlewRate::TxPreN to 0xc */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for TxSlewRate::TxPreP and TxSlewRate::TxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x1005f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b0_p0 */
-	dwc_ddrphy_apb_wr(0x1015f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b1_p0 */
-	dwc_ddrphy_apb_wr(0x1105f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b0_p0 */
-	dwc_ddrphy_apb_wr(0x1115f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b1_p0 */
-	dwc_ddrphy_apb_wr(0x1205f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b0_p0 */
-	dwc_ddrphy_apb_wr(0x1215f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b1_p0 */
-	dwc_ddrphy_apb_wr(0x1305f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b0_p0 */
-	dwc_ddrphy_apb_wr(0x1315f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b1_p0 */
-	/*   [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxSlewRate::TxPreDrvMode to 0x3 */
-	/*   [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxSlewRate::TxPreP to 0xf */
-	/*   [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxSlewRate::TxPreN to 0xc */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for TxSlewRate::TxPreP and TxSlewRate::TxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x11005f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b0_p1 */
-	dwc_ddrphy_apb_wr(0x11015f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b1_p1 */
-	dwc_ddrphy_apb_wr(0x11105f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b0_p1 */
-	dwc_ddrphy_apb_wr(0x11115f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b1_p1 */
-	dwc_ddrphy_apb_wr(0x11205f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b0_p1 */
-	dwc_ddrphy_apb_wr(0x11215f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b1_p1 */
-	dwc_ddrphy_apb_wr(0x11305f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b0_p1 */
-	dwc_ddrphy_apb_wr(0x11315f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b1_p1 */
-	/*   [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxSlewRate::TxPreDrvMode to 0x3 */
-	/*   [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxSlewRate::TxPreP to 0xf */
-	/*   [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxSlewRate::TxPreN to 0xc */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for TxSlewRate::TxPreP and TxSlewRate::TxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x21005f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b0_p2 */
-	dwc_ddrphy_apb_wr(0x21015f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b1_p2 */
-	dwc_ddrphy_apb_wr(0x21105f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b0_p2 */
-	dwc_ddrphy_apb_wr(0x21115f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b1_p2 */
-	dwc_ddrphy_apb_wr(0x21205f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b0_p2 */
-	dwc_ddrphy_apb_wr(0x21215f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b1_p2 */
-	dwc_ddrphy_apb_wr(0x21305f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b0_p2 */
-	dwc_ddrphy_apb_wr(0x21315f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b1_p2 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=0 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=0 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=0 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x55, 0x365); /*  DWC_DDRPHYA_ANIB0_ATxSlewRate */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=1 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=1 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=1 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x1055, 0x365); /*  DWC_DDRPHYA_ANIB1_ATxSlewRate */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=2 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=2 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=2 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x2055, 0x365); /*  DWC_DDRPHYA_ANIB2_ATxSlewRate */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=3 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=3 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=3 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x3055, 0x365); /*  DWC_DDRPHYA_ANIB3_ATxSlewRate */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x0, ANIB=4 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=4 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=4 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x4055, 0x65); /*  DWC_DDRPHYA_ANIB4_ATxSlewRate */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x0, ANIB=5 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=5 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=5 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x5055, 0x65); /*  DWC_DDRPHYA_ANIB5_ATxSlewRate */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=6 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=6 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=6 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x6055, 0x365); /*  DWC_DDRPHYA_ANIB6_ATxSlewRate */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=7 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=7 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=7 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x7055, 0x365); /*  DWC_DDRPHYA_ANIB7_ATxSlewRate */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=8 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=8 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=8 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x8055, 0x365); /*  DWC_DDRPHYA_ANIB8_ATxSlewRate */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=9 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=9 */
-	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=9 */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
-	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
-
-	dwc_ddrphy_apb_wr(0x9055, 0x365); /*  DWC_DDRPHYA_ANIB9_ATxSlewRate */
-	dwc_ddrphy_apb_wr(0x200c5, 0xb); /*  DWC_DDRPHYA_MASTER0_PllCtrl2_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0,  Memclk=800MHz, Programming PllCtrl2 to b based on DfiClk frequency = 400. */
-	dwc_ddrphy_apb_wr(0x1200c5, 0x7); /*  DWC_DDRPHYA_MASTER0_PllCtrl2_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1,  Memclk=266MHz, Programming PllCtrl2 to 7 based on DfiClk frequency = 133. */
-	dwc_ddrphy_apb_wr(0x2200c5, 0x7); /*  DWC_DDRPHYA_MASTER0_PllCtrl2_p2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2,  Memclk=166MHz, Programming PllCtrl2 to 7 based on DfiClk frequency = 83. */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	/*  Program ARdPtrInitVal based on Frequency and PLL Bypass inputs */
-	/*  The values programmed here assume ideal properties of DfiClk */
-	/*  and Pclk including: */
-	/*  - DfiClk skew */
-	/*  - DfiClk jitter */
-	/*  - DfiClk PVT variations */
-	/*  - Pclk skew */
-	/*  - Pclk jitter */
-	/*  */
-	/*  PLL Bypassed mode: */
-	/*      For MemClk frequency > 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 2-6 */
-	/*      For MemClk frequency < 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 1-6 */
-	/*  */
-	/*  PLL Enabled mode: */
-	/*      For MemClk frequency > 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 1-6 */
-	/*      For MemClk frequency < 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 0-6 */
-	/*  */
-	/* ############################################################## */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming ARdPtrInitVal to 0x1 */
-	dwc_ddrphy_apb_wr(0x2002e, 0x1); /*  DWC_DDRPHYA_MASTER0_ARdPtrInitVal_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming ARdPtrInitVal to 0x1 */
-	dwc_ddrphy_apb_wr(0x12002e, 0x1); /*  DWC_DDRPHYA_MASTER0_ARdPtrInitVal_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming ARdPtrInitVal to 0x1 */
-	dwc_ddrphy_apb_wr(0x22002e, 0x1); /*  DWC_DDRPHYA_MASTER0_ARdPtrInitVal_p2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::TwoTckRxDqsPre to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::TwoTckTxDqsPre to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::PositionDfeInit to 0x2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::LP4TglTwoTckTxDqsPre to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::LP4PostambleExt to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::LP4SttcPreBridgeRxEn to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl to 0x8 */
-	dwc_ddrphy_apb_wr(0x20024, 0x8); /*  DWC_DDRPHYA_MASTER0_DqsPreambleControl_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DbyteDllModeCntrl to 0x0 */
-	dwc_ddrphy_apb_wr(0x2003a, 0x0); /*  DWC_DDRPHYA_MASTER0_DbyteDllModeCntrl */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::TwoTckRxDqsPre to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::TwoTckTxDqsPre to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::PositionDfeInit to 0x2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::LP4TglTwoTckTxDqsPre to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::LP4PostambleExt to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::LP4SttcPreBridgeRxEn to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl to 0x8 */
-	dwc_ddrphy_apb_wr(0x120024, 0x8); /*  DWC_DDRPHYA_MASTER0_DqsPreambleControl_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DbyteDllModeCntrl to 0x0 */
-	dwc_ddrphy_apb_wr(0x2003a, 0x0); /*  DWC_DDRPHYA_MASTER0_DbyteDllModeCntrl */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::TwoTckRxDqsPre to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::TwoTckTxDqsPre to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::PositionDfeInit to 0x2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::LP4TglTwoTckTxDqsPre to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::LP4PostambleExt to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::LP4SttcPreBridgeRxEn to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl to 0x8 */
-	dwc_ddrphy_apb_wr(0x220024, 0x8); /*  DWC_DDRPHYA_MASTER0_DqsPreambleControl_p2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DbyteDllModeCntrl to 0x0 */
-	dwc_ddrphy_apb_wr(0x2003a, 0x0); /*  DWC_DDRPHYA_MASTER0_DbyteDllModeCntrl */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming ProcOdtTimeCtl to 0xa */
-	dwc_ddrphy_apb_wr(0x20056, 0xa); /*  DWC_DDRPHYA_MASTER0_ProcOdtTimeCtl_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming ProcOdtTimeCtl to 0xa */
-	dwc_ddrphy_apb_wr(0x120056, 0xa); /*  DWC_DDRPHYA_MASTER0_ProcOdtTimeCtl_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming ProcOdtTimeCtl to 0xa */
-	dwc_ddrphy_apb_wr(0x220056, 0xa); /*  DWC_DDRPHYA_MASTER0_ProcOdtTimeCtl_p2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxOdtDrvStren::ODTStrenP to 0x18 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxOdtDrvStren::ODTStrenN to 0x18 */
-	dwc_ddrphy_apb_wr(0x1004d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b0_p0 */
-	dwc_ddrphy_apb_wr(0x1014d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b1_p0 */
-	dwc_ddrphy_apb_wr(0x1104d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b0_p0 */
-	dwc_ddrphy_apb_wr(0x1114d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b1_p0 */
-	dwc_ddrphy_apb_wr(0x1204d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b0_p0 */
-	dwc_ddrphy_apb_wr(0x1214d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b1_p0 */
-	dwc_ddrphy_apb_wr(0x1304d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b0_p0 */
-	dwc_ddrphy_apb_wr(0x1314d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b1_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxOdtDrvStren::ODTStrenP to 0x18 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxOdtDrvStren::ODTStrenN to 0x18 */
-	dwc_ddrphy_apb_wr(0x11004d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b0_p1 */
-	dwc_ddrphy_apb_wr(0x11014d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b1_p1 */
-	dwc_ddrphy_apb_wr(0x11104d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b0_p1 */
-	dwc_ddrphy_apb_wr(0x11114d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b1_p1 */
-	dwc_ddrphy_apb_wr(0x11204d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b0_p1 */
-	dwc_ddrphy_apb_wr(0x11214d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b1_p1 */
-	dwc_ddrphy_apb_wr(0x11304d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b0_p1 */
-	dwc_ddrphy_apb_wr(0x11314d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b1_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxOdtDrvStren::ODTStrenP to 0x18 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxOdtDrvStren::ODTStrenN to 0x18 */
-	dwc_ddrphy_apb_wr(0x21004d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b0_p2 */
-	dwc_ddrphy_apb_wr(0x21014d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b1_p2 */
-	dwc_ddrphy_apb_wr(0x21104d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b0_p2 */
-	dwc_ddrphy_apb_wr(0x21114d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b1_p2 */
-	dwc_ddrphy_apb_wr(0x21204d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b0_p2 */
-	dwc_ddrphy_apb_wr(0x21214d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b1_p2 */
-	dwc_ddrphy_apb_wr(0x21304d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b0_p2 */
-	dwc_ddrphy_apb_wr(0x21314d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b1_p2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqP to 0x38 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqN to 0x38 */
-	dwc_ddrphy_apb_wr(0x10049, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b0_p0 */
-	dwc_ddrphy_apb_wr(0x10149, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b1_p0 */
-	dwc_ddrphy_apb_wr(0x11049, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b0_p0 */
-	dwc_ddrphy_apb_wr(0x11149, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b1_p0 */
-	dwc_ddrphy_apb_wr(0x12049, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b0_p0 */
-	dwc_ddrphy_apb_wr(0x12149, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b1_p0 */
-	dwc_ddrphy_apb_wr(0x13049, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b0_p0 */
-	dwc_ddrphy_apb_wr(0x13149, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b1_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqP to 0x38 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqN to 0x38 */
-	dwc_ddrphy_apb_wr(0x110049, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b0_p1 */
-	dwc_ddrphy_apb_wr(0x110149, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b1_p1 */
-	dwc_ddrphy_apb_wr(0x111049, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b0_p1 */
-	dwc_ddrphy_apb_wr(0x111149, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b1_p1 */
-	dwc_ddrphy_apb_wr(0x112049, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b0_p1 */
-	dwc_ddrphy_apb_wr(0x112149, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b1_p1 */
-	dwc_ddrphy_apb_wr(0x113049, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b0_p1 */
-	dwc_ddrphy_apb_wr(0x113149, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b1_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqP to 0x38 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqN to 0x38 */
-	dwc_ddrphy_apb_wr(0x210049, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b0_p2 */
-	dwc_ddrphy_apb_wr(0x210149, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b1_p2 */
-	dwc_ddrphy_apb_wr(0x211049, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b0_p2 */
-	dwc_ddrphy_apb_wr(0x211149, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b1_p2 */
-	dwc_ddrphy_apb_wr(0x212049, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b0_p2 */
-	dwc_ddrphy_apb_wr(0x212149, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b1_p2 */
-	dwc_ddrphy_apb_wr(0x213049, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b0_p2 */
-	dwc_ddrphy_apb_wr(0x213149, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b1_p2 */
-	/*  [phyinit_C_initPhyConfig] Programming ATxImpedance::ADrvStrenP to 0x3 */
-	/*  [phyinit_C_initPhyConfig] Programming ATxImpedance::ADrvStrenN to 0x3 */
-	dwc_ddrphy_apb_wr(0x43, 0x63); /*  DWC_DDRPHYA_ANIB0_ATxImpedance */
-	dwc_ddrphy_apb_wr(0x1043, 0x63); /*  DWC_DDRPHYA_ANIB1_ATxImpedance */
-	dwc_ddrphy_apb_wr(0x2043, 0x63); /*  DWC_DDRPHYA_ANIB2_ATxImpedance */
-	dwc_ddrphy_apb_wr(0x3043, 0x63); /*  DWC_DDRPHYA_ANIB3_ATxImpedance */
-	dwc_ddrphy_apb_wr(0x4043, 0x63); /*  DWC_DDRPHYA_ANIB4_ATxImpedance */
-	dwc_ddrphy_apb_wr(0x5043, 0x63); /*  DWC_DDRPHYA_ANIB5_ATxImpedance */
-	dwc_ddrphy_apb_wr(0x6043, 0x63); /*  DWC_DDRPHYA_ANIB6_ATxImpedance */
-	dwc_ddrphy_apb_wr(0x7043, 0x63); /*  DWC_DDRPHYA_ANIB7_ATxImpedance */
-	dwc_ddrphy_apb_wr(0x8043, 0x63); /*  DWC_DDRPHYA_ANIB8_ATxImpedance */
-	dwc_ddrphy_apb_wr(0x9043, 0x63); /*  DWC_DDRPHYA_ANIB9_ATxImpedance */
-	/*  [phyinit_C_initPhyConfig] Programming DfiMode to 0x5 */
-	dwc_ddrphy_apb_wr(0x20018, 0x5); /*  DWC_DDRPHYA_MASTER0_DfiMode */
-	/*  [phyinit_C_initPhyConfig] Programming DfiCAMode to 0x0 */
-	dwc_ddrphy_apb_wr(0x20075, 0x0); /*  DWC_DDRPHYA_MASTER0_DfiCAMode */
-	/*  [phyinit_C_initPhyConfig] Programming CalDrvStr0::CalDrvStrPd50 to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Programming CalDrvStr0::CalDrvStrPu50 to 0x0 */
-	dwc_ddrphy_apb_wr(0x20050, 0x0); /*  DWC_DDRPHYA_MASTER0_CalDrvStr0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming CalUclkInfo::CalUClkTicksPer1uS to 0x190 */
-	dwc_ddrphy_apb_wr(0x20008, 0x190); /*  DWC_DDRPHYA_MASTER0_CalUclkInfo_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming CalUclkInfo::CalUClkTicksPer1uS to 0x85 */
-	dwc_ddrphy_apb_wr(0x120008, 0x85); /*  DWC_DDRPHYA_MASTER0_CalUclkInfo_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming CalUclkInfo::CalUClkTicksPer1uS to 0x53 */
-	dwc_ddrphy_apb_wr(0x220008, 0x53); /*  DWC_DDRPHYA_MASTER0_CalUclkInfo_p2 */
-	/*  [phyinit_C_initPhyConfig] Programming CalRate::CalInterval to 0x9 */
-	/*  [phyinit_C_initPhyConfig] Programming CalRate::CalOnce to 0x0 */
-	dwc_ddrphy_apb_wr(0x20088, 0x9); /*  DWC_DDRPHYA_MASTER0_CalRate */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming VrefInGlobal::GlobalVrefInSel to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming VrefInGlobal::GlobalVrefInDAC to 0x1f */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming VrefInGlobal to 0xf8 */
-	dwc_ddrphy_apb_wr(0x200b2, 0xf8); /*  DWC_DDRPHYA_MASTER0_VrefInGlobal_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming DqDqsRcvCntrl::MajorModeDbyte to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming DqDqsRcvCntrl to 0x581 */
-	dwc_ddrphy_apb_wr(0x10043, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b0_p0 */
-	dwc_ddrphy_apb_wr(0x10143, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b1_p0 */
-	dwc_ddrphy_apb_wr(0x11043, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b0_p0 */
-	dwc_ddrphy_apb_wr(0x11143, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b1_p0 */
-	dwc_ddrphy_apb_wr(0x12043, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b0_p0 */
-	dwc_ddrphy_apb_wr(0x12143, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b1_p0 */
-	dwc_ddrphy_apb_wr(0x13043, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b0_p0 */
-	dwc_ddrphy_apb_wr(0x13143, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b1_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming VrefInGlobal::GlobalVrefInSel to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming VrefInGlobal::GlobalVrefInDAC to 0x1f */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming VrefInGlobal to 0xf8 */
-	dwc_ddrphy_apb_wr(0x1200b2, 0xf8); /*  DWC_DDRPHYA_MASTER0_VrefInGlobal_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming DqDqsRcvCntrl::MajorModeDbyte to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming DqDqsRcvCntrl to 0x581 */
-	dwc_ddrphy_apb_wr(0x110043, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b0_p1 */
-	dwc_ddrphy_apb_wr(0x110143, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b1_p1 */
-	dwc_ddrphy_apb_wr(0x111043, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b0_p1 */
-	dwc_ddrphy_apb_wr(0x111143, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b1_p1 */
-	dwc_ddrphy_apb_wr(0x112043, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b0_p1 */
-	dwc_ddrphy_apb_wr(0x112143, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b1_p1 */
-	dwc_ddrphy_apb_wr(0x113043, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b0_p1 */
-	dwc_ddrphy_apb_wr(0x113143, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b1_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming VrefInGlobal::GlobalVrefInSel to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming VrefInGlobal::GlobalVrefInDAC to 0x1f */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming VrefInGlobal to 0xf8 */
-	dwc_ddrphy_apb_wr(0x2200b2, 0xf8); /*  DWC_DDRPHYA_MASTER0_VrefInGlobal_p2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming DqDqsRcvCntrl::MajorModeDbyte to 0x0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming DqDqsRcvCntrl to 0x581 */
-	dwc_ddrphy_apb_wr(0x210043, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b0_p2 */
-	dwc_ddrphy_apb_wr(0x210143, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b1_p2 */
-	dwc_ddrphy_apb_wr(0x211043, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b0_p2 */
-	dwc_ddrphy_apb_wr(0x211143, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b1_p2 */
-	dwc_ddrphy_apb_wr(0x212043, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b0_p2 */
-	dwc_ddrphy_apb_wr(0x212143, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b1_p2 */
-	dwc_ddrphy_apb_wr(0x213043, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b0_p2 */
-	dwc_ddrphy_apb_wr(0x213143, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b1_p2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DfiFreqRatio_p0 to 0x1 */
-	dwc_ddrphy_apb_wr(0x200fa, 0x1); /*  DWC_DDRPHYA_MASTER0_DfiFreqRatio_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DfiFreqRatio_p1 to 0x1 */
-	dwc_ddrphy_apb_wr(0x1200fa, 0x1); /*  DWC_DDRPHYA_MASTER0_DfiFreqRatio_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DfiFreqRatio_p2 to 0x1 */
-	dwc_ddrphy_apb_wr(0x2200fa, 0x1); /*  DWC_DDRPHYA_MASTER0_DfiFreqRatio_p2 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TristateModeCA::DisDynAdrTri_p0 to 0x1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TristateModeCA::DDR2TMode_p0 to 0x0 */
-	dwc_ddrphy_apb_wr(0x20019, 0x5); /*  DWC_DDRPHYA_MASTER0_TristateModeCA_p0 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TristateModeCA::DisDynAdrTri_p1 to 0x1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TristateModeCA::DDR2TMode_p1 to 0x0 */
-	dwc_ddrphy_apb_wr(0x120019, 0x5); /*  DWC_DDRPHYA_MASTER0_TristateModeCA_p1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TristateModeCA::DisDynAdrTri_p2 to 0x1 */
-	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TristateModeCA::DDR2TMode_p2 to 0x0 */
-	dwc_ddrphy_apb_wr(0x220019, 0x5); /*  DWC_DDRPHYA_MASTER0_TristateModeCA_p2 */
-	/*  [phyinit_C_initPhyConfig] Programming DfiFreqXlat* */
-	dwc_ddrphy_apb_wr(0x200f0, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat0 */
-	dwc_ddrphy_apb_wr(0x200f1, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat1 */
-	dwc_ddrphy_apb_wr(0x200f2, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat2 */
-	dwc_ddrphy_apb_wr(0x200f3, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat3 */
-	dwc_ddrphy_apb_wr(0x200f4, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat4 */
-	dwc_ddrphy_apb_wr(0x200f5, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat5 */
-	dwc_ddrphy_apb_wr(0x200f6, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat6 */
-	dwc_ddrphy_apb_wr(0x200f7, 0xf000); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat7 */
-	/*  [phyinit_C_initPhyConfig] Programming MasterX4Config::X4TG to 0x0 */
-	dwc_ddrphy_apb_wr(0x20025, 0x0); /*  DWC_DDRPHYA_MASTER0_MasterX4Config */
-	/*  [phyinit_C_initPhyConfig] End of dwc_ddrphy_phyinit_C_initPhyConfig() */
-	/*  */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	/*  dwc_ddrphy_phyihunit_userCustom_customPreTrain is a user-editable function. */
-	/*  */
-	/*  See PhyInit App Note for detailed description and function usage */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	/*  [phyinit_userCustom_customPreTrain] Start of dwc_ddrphy_phyinit_userCustom_customPreTrain() */
-	/*  [phyinit_userCustom_customPreTrain] End of dwc_ddrphy_phyinit_userCustom_customPreTrain() */
-	/*  [dwc_ddrphy_phyinit_D_loadIMEM, 1D] Start of dwc_ddrphy_phyinit_D_loadIMEM (Train2D=0) */
-	/*  */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	/*  (D) Load the 1D IMEM image */
-	/*  */
-	/*  This function loads the training firmware IMEM image into the SRAM. */
-	/*  See PhyInit App Note for detailed description and function usage */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	/*  */
-	/*  [dwc_ddrphy_phyinit_D_loadIMEM, 1D] Programming MemResetL to 0x2 */
-	if (!after_retention) {
-		dwc_ddrphy_apb_wr(0x20060, 0x2);
-
-		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_imem.incv */
-
-		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
-		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x50000 size 0x4000 */
-		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x4000 */
-		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
-		/*       This allows the firmware unrestricted access to the configuration CSRs. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  [dwc_ddrphy_phyinit_D_loadIMEM, 1D] End of dwc_ddrphy_phyinit_D_loadIMEM() */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  Step (E) Set the PHY input clocks to the desired frequency for pstate 0 */
-		/*  */
-		/*  See PhyInit App Note for detailed description and function usage */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		dwc_ddrphy_phyinit_userCustom_E_setDfiClk (0);
-
-		/*  */
-		/*  [dwc_ddrphy_phyinit_userCustom_E_setDfiClk] End of dwc_ddrphy_phyinit_userCustom_E_setDfiClk() */
-		/*  [phyinit_F_loadDMEM, 1D] Start of dwc_ddrphy_phyinit_F_loadDMEM (pstate=0, Train2D=0) */
-
-		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  for test on silicon, load 1D dmem/imem here */
-#ifdef CONFIG_SPL_VSI_FW_LOADING
-		load_train_1d_code();
-#else
-		ddr_load_train_code(FW_1D_IMAGE);
-#endif
-		ddr_dbg("start 1d train\n");
-
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  (F) Load the 1D DMEM image and write the 1D Message Block parameters for the training firmware */
-		/*  */
-		/*  See PhyInit App Note for detailed description and function usage */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_dmem.incv */
-
-		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
-		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x54000 size 0x36a */
-#ifdef RUN_ON_SILICON
-		dwc_ddrphy_apb_wr(0x54000, 0x0);
-#else
-		dwc_ddrphy_apb_wr(0x54000, 0x600);
-#endif
-		dwc_ddrphy_apb_wr(0x54001, 0x0);
-		dwc_ddrphy_apb_wr(0x54002, 0x0);
-		dwc_ddrphy_apb_wr(0x54003, 0x640);
-		dwc_ddrphy_apb_wr(0x54004, 0x2);
-		dwc_ddrphy_apb_wr(0x54005, 0x0);
-		dwc_ddrphy_apb_wr(0x54006, 0x140);
-		dwc_ddrphy_apb_wr(0x54007, 0x2000);
-#ifdef DDR_ONE_RANK
-		dwc_ddrphy_apb_wr(0x54008, 0x101);
-		dwc_ddrphy_apb_wr(0x54009, 0x0);
-#else
-		dwc_ddrphy_apb_wr(0x54008, 0x303);
-		dwc_ddrphy_apb_wr(0x54009, 0x200);
-#endif
-		dwc_ddrphy_apb_wr(0x5400a, 0x0);
-#ifdef RUN_ON_SILICON
-		dwc_ddrphy_apb_wr(0x5400b, 0x31f);
-#else
-		dwc_ddrphy_apb_wr(0x5400b, 0x1);
-#endif
-		dwc_ddrphy_apb_wr(0x5400c, 0xc8);
-		dwc_ddrphy_apb_wr(0x5400d, 0x0);
-		dwc_ddrphy_apb_wr(0x5400e, 0x0);
-		dwc_ddrphy_apb_wr(0x5400f, 0x0);
-		dwc_ddrphy_apb_wr(0x54010, 0x0);
-		dwc_ddrphy_apb_wr(0x54011, 0x0);
-		dwc_ddrphy_apb_wr(0x54012, 0x1);
-		dwc_ddrphy_apb_wr(0x5402f, 0xd70);
-		dwc_ddrphy_apb_wr(0x54030, 0x4);
-		dwc_ddrphy_apb_wr(0x54031, 0x18);
-		dwc_ddrphy_apb_wr(0x5403a, 0x1221);
-		dwc_ddrphy_apb_wr(0x5403b, 0x4884);
-		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x36a */
-		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
-		/*       This allows the firmware unrestricted access to the configuration CSRs. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  [phyinit_F_loadDMEM, 1D] End of dwc_ddrphy_phyinit_F_loadDMEM() */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  (G) Execute the Training Firmware */
-		/*  */
-		/*  See PhyInit App Note for detailed description and function usage */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  */
-		/*  1.  Reset the firmware microcontroller by writing the MicroReset CSR to set the StallToMicro and */
-		/*      ResetToMicro fields to 1 (all other fields should be zero). */
-		/*      Then rewrite the CSR so that only the StallToMicro remains set (all other fields should be zero). */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		dwc_ddrphy_apb_wr(0xd0099, 0x9); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		/*  */
-		/*  2. Begin execution of the training firmware by setting the MicroReset CSR to 4'b0000. */
-		dwc_ddrphy_apb_wr(0xd0099, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		/*  */
-		/*  3.   Wait for the training firmware to complete by following the procedure in "uCtrl Initialization and Mailbox Messaging" */
-		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] Wait for the training firmware to complete.  Implement timeout fucntion or follow the procedure in "3.4 Running the firmware" of the Training Firmware Application Note to poll the Mailbox message. */
-		dwc_ddrphy_phyinit_userCustom_G_waitFwDone ();
-
-		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] End of dwc_ddrphy_phyinit_userCustom_G_waitFwDone() */
-		/*  4.   Halt the microcontroller." */
-		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		/*  [dwc_ddrphy_phyinit_G_execFW] End of dwc_ddrphy_phyinit_G_execFW () */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  (H) Read the Message Block results */
-		/*  */
-		/*  The procedure is as follows: */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  */
-		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  */
-		/*  2. Read the Firmware Message Block to obtain the results from the training. */
-		/*  This can be accomplished by issuing APB read commands to the DMEM addresses. */
-		/*  Example: */
-		/*  if (Train2D) */
-		/*  { */
-		/*    _read_2d_message_block_outputs_ */
-		/*  } */
-		/*  else */
-		/*  { */
-		/*    _read_1d_message_block_outputs_ */
-		/*  } */
-		dwc_ddrphy_phyinit_userCustom_H_readMsgBlock (0);
-
-		/*  [dwc_ddrphy_phyinit_userCustom_H_readMsgBlock] End of dwc_ddrphy_phyinit_userCustom_H_readMsgBlock () */
-		/*  3.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  4.	If training is required at another frequency, repeat the operations starting at step (E). */
-		/*  [dwc_ddrphy_phyinit_H_readMsgBlock] End of dwc_ddrphy_phyinit_H_readMsgBlock() */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  Step (E) Set the PHY input clocks to the desired frequency for pstate 1 */
-		/*  */
-		/*  See PhyInit App Note for detailed description and function usage */
-		/*  */
-		/* ############################################################## */
-		/*  */
-#ifdef DDR3_SW_FFC
-		dwc_ddrphy_phyinit_userCustom_E_setDfiClk (1);
-
-		/*  */
-		/*  [dwc_ddrphy_phyinit_userCustom_E_setDfiClk] End of dwc_ddrphy_phyinit_userCustom_E_setDfiClk() */
-		/*  [phyinit_F_loadDMEM, 1D] Start of dwc_ddrphy_phyinit_F_loadDMEM (pstate=1, Train2D=0) */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  (F) Load the 1D DMEM image and write the 1D Message Block parameters for the training firmware */
-		/*  */
-		/*  See PhyInit App Note for detailed description and function usage */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_dmem.incv */
-
-		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
-		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x54000 size 0x36a */
-#ifdef RUN_ON_SILICON
-		dwc_ddrphy_apb_wr(0x54000, 0x0);
-#else
-		dwc_ddrphy_apb_wr(0x54000, 0x600);
-#endif
-		dwc_ddrphy_apb_wr(0x54001, 0x0);
-		dwc_ddrphy_apb_wr(0x54002, 0x1);
-		dwc_ddrphy_apb_wr(0x54003, 0x214);
-		dwc_ddrphy_apb_wr(0x54004, 0x2);
-		dwc_ddrphy_apb_wr(0x54005, 0x0);
-		dwc_ddrphy_apb_wr(0x54006, 0x140);
-		dwc_ddrphy_apb_wr(0x54007, 0x2000);
-#ifdef DDR_ONE_RANK
-		dwc_ddrphy_apb_wr(0x54008, 0x101);
-		dwc_ddrphy_apb_wr(0x54009, 0x0);
-#else
-		dwc_ddrphy_apb_wr(0x54008, 0x303);
-		dwc_ddrphy_apb_wr(0x54009, 0x200);
-#endif
-		dwc_ddrphy_apb_wr(0x5400a, 0x0);
-#ifdef RUN_ON_SILICON
-		dwc_ddrphy_apb_wr(0x5400b, 0x21f);
-#else
-		dwc_ddrphy_apb_wr(0x5400b, 0x1);
-#endif
-		dwc_ddrphy_apb_wr(0x5400c, 0xc8);
-		dwc_ddrphy_apb_wr(0x5400d, 0x0);
-		dwc_ddrphy_apb_wr(0x5400e, 0x0);
-		dwc_ddrphy_apb_wr(0x5400f, 0x0);
-		dwc_ddrphy_apb_wr(0x54010, 0x0);
-		dwc_ddrphy_apb_wr(0x54011, 0x0);
-		dwc_ddrphy_apb_wr(0x54012, 0x1);
-		dwc_ddrphy_apb_wr(0x5402f, 0x930);
-		dwc_ddrphy_apb_wr(0x54030, 0x4);
-		dwc_ddrphy_apb_wr(0x54031, 0x8);
-		dwc_ddrphy_apb_wr(0x5403a, 0x1221);
-		dwc_ddrphy_apb_wr(0x5403b, 0x4884);
-		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x36a */
-		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
-		/*       This allows the firmware unrestricted access to the configuration CSRs. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  [phyinit_F_loadDMEM, 1D] End of dwc_ddrphy_phyinit_F_loadDMEM() */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  (G) Execute the Training Firmware */
-		/*  */
-		/*  See PhyInit App Note for detailed description and function usage */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  */
-		/*  1.  Reset the firmware microcontroller by writing the MicroReset CSR to set the StallToMicro and */
-		/*      ResetToMicro fields to 1 (all other fields should be zero). */
-		/*      Then rewrite the CSR so that only the StallToMicro remains set (all other fields should be zero). */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		dwc_ddrphy_apb_wr(0xd0099, 0x9); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		/*  */
-		/*  2. Begin execution of the training firmware by setting the MicroReset CSR to 4'b0000. */
-		dwc_ddrphy_apb_wr(0xd0099, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		/*  */
-		/*  3.   Wait for the training firmware to complete by following the procedure in "uCtrl Initialization and Mailbox Messaging" */
-		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] Wait for the training firmware to complete.  Implement timeout fucntion or follow the procedure in "3.4 Running the firmware" of the Training Firmware Application Note to poll the Mailbox message. */
-		dwc_ddrphy_phyinit_userCustom_G_waitFwDone ();
-
-		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] End of dwc_ddrphy_phyinit_userCustom_G_waitFwDone() */
-		/*  4.   Halt the microcontroller." */
-		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		/*  [dwc_ddrphy_phyinit_G_execFW] End of dwc_ddrphy_phyinit_G_execFW () */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  (H) Read the Message Block results */
-		/*  */
-		/*  The procedure is as follows: */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  */
-		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  */
-		/*  2. Read the Firmware Message Block to obtain the results from the training. */
-		/*  This can be accomplished by issuing APB read commands to the DMEM addresses. */
-		/*  Example: */
-		/*  if (Train2D) */
-		/*  { */
-		/*    _read_2d_message_block_outputs_ */
-		/*  } */
-		/*  else */
-		/*  { */
-		/*    _read_1d_message_block_outputs_ */
-		/*  } */
-		dwc_ddrphy_phyinit_userCustom_H_readMsgBlock (0);
-
-		/*  [dwc_ddrphy_phyinit_userCustom_H_readMsgBlock] End of dwc_ddrphy_phyinit_userCustom_H_readMsgBlock () */
-		/*  3.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  4.	If training is required at another frequency, repeat the operations starting at step (E). */
-		/*  [dwc_ddrphy_phyinit_H_readMsgBlock] End of dwc_ddrphy_phyinit_H_readMsgBlock() */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  Step (E) Set the PHY input clocks to the desired frequency for pstate 2 */
-		/*  */
-		/*  See PhyInit App Note for detailed description and function usage */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		dwc_ddrphy_phyinit_userCustom_E_setDfiClk (2);
-
-		/*  */
-		/*  [dwc_ddrphy_phyinit_userCustom_E_setDfiClk] End of dwc_ddrphy_phyinit_userCustom_E_setDfiClk() */
-		/*  [phyinit_F_loadDMEM, 1D] Start of dwc_ddrphy_phyinit_F_loadDMEM (pstate=2, Train2D=0) */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  (F) Load the 1D DMEM image and write the 1D Message Block parameters for the training firmware */
-		/*  */
-		/*  See PhyInit App Note for detailed description and function usage */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_dmem.incv */
-
-		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
-		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x54000 size 0x36a */
-#ifdef RUN_ON_SILICON
-		dwc_ddrphy_apb_wr(0x54000, 0x0);
-#else
-		dwc_ddrphy_apb_wr(0x54000, 0x600);
-#endif
-		dwc_ddrphy_apb_wr(0x54001, 0x0);
-		dwc_ddrphy_apb_wr(0x54002, 0x2);
-		dwc_ddrphy_apb_wr(0x54003, 0x14c);
-		dwc_ddrphy_apb_wr(0x54004, 0x2);
-		dwc_ddrphy_apb_wr(0x54005, 0x0);
-		dwc_ddrphy_apb_wr(0x54006, 0x140);
-		dwc_ddrphy_apb_wr(0x54007, 0x2000);
-#ifdef DDR_ONE_RANK
-		dwc_ddrphy_apb_wr(0x54008, 0x101);
-		dwc_ddrphy_apb_wr(0x54009, 0x0);
-#else
-		dwc_ddrphy_apb_wr(0x54008, 0x303);
-		dwc_ddrphy_apb_wr(0x54009, 0x200);
-#endif
-		dwc_ddrphy_apb_wr(0x5400a, 0x0);
-#ifdef RUN_ON_SILICON
-		dwc_ddrphy_apb_wr(0x5400b, 0x21f);
-#else
-		dwc_ddrphy_apb_wr(0x5400b, 0x1);
-#endif
-		dwc_ddrphy_apb_wr(0x5400c, 0xc8);
-		dwc_ddrphy_apb_wr(0x5400d, 0x0);
-		dwc_ddrphy_apb_wr(0x5400e, 0x0);
-		dwc_ddrphy_apb_wr(0x5400f, 0x0);
-		dwc_ddrphy_apb_wr(0x54010, 0x0);
-		dwc_ddrphy_apb_wr(0x54011, 0x0);
-		dwc_ddrphy_apb_wr(0x54012, 0x1);
-		dwc_ddrphy_apb_wr(0x5402f, 0x520);
-		dwc_ddrphy_apb_wr(0x54030, 0x4);
-		dwc_ddrphy_apb_wr(0x54031, 0x0);
-		dwc_ddrphy_apb_wr(0x5403a, 0x1221);
-		dwc_ddrphy_apb_wr(0x5403b, 0x4884);
-		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x36a */
-		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
-		/*       This allows the firmware unrestricted access to the configuration CSRs. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  [phyinit_F_loadDMEM, 1D] End of dwc_ddrphy_phyinit_F_loadDMEM() */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  (G) Execute the Training Firmware */
-		/*  */
-		/*  See PhyInit App Note for detailed description and function usage */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  */
-		/*  1.  Reset the firmware microcontroller by writing the MicroReset CSR to set the StallToMicro and */
-		/*      ResetToMicro fields to 1 (all other fields should be zero). */
-		/*      Then rewrite the CSR so that only the StallToMicro remains set (all other fields should be zero). */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		dwc_ddrphy_apb_wr(0xd0099, 0x9); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		/*  */
-		/*  2. Begin execution of the training firmware by setting the MicroReset CSR to 4'b0000. */
-		dwc_ddrphy_apb_wr(0xd0099, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		/*  */
-		/*  3.   Wait for the training firmware to complete by following the procedure in "uCtrl Initialization and Mailbox Messaging" */
-		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] Wait for the training firmware to complete.  Implement timeout fucntion or follow the procedure in "3.4 Running the firmware" of the Training Firmware Application Note to poll the Mailbox message. */
-		dwc_ddrphy_phyinit_userCustom_G_waitFwDone ();
-
-		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] End of dwc_ddrphy_phyinit_userCustom_G_waitFwDone() */
-		/*  4.   Halt the microcontroller." */
-		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
-		/*  [dwc_ddrphy_phyinit_G_execFW] End of dwc_ddrphy_phyinit_G_execFW () */
-		/*  */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  (H) Read the Message Block results */
-		/*  */
-		/*  The procedure is as follows: */
-		/*  */
-		/* ############################################################## */
-		/*  */
-		/*  */
-		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  */
-		/*  2. Read the Firmware Message Block to obtain the results from the training. */
-		/*  This can be accomplished by issuing APB read commands to the DMEM addresses. */
-		/*  Example: */
-		/*  if (Train2D) */
-		/*  { */
-		/*    _read_2d_message_block_outputs_ */
-		/*  } */
-		/*  else */
-		/*  { */
-		/*    _read_1d_message_block_outputs_ */
-		/*  } */
-		dwc_ddrphy_phyinit_userCustom_H_readMsgBlock (0);
-
-		/*  [dwc_ddrphy_phyinit_userCustom_H_readMsgBlock] End of dwc_ddrphy_phyinit_userCustom_H_readMsgBlock () */
-		/*  3.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
-		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-		/*  4.	If training is required at another frequency, repeat the operations starting at step (E). */
-		/*  [dwc_ddrphy_phyinit_H_readMsgBlock] End of dwc_ddrphy_phyinit_H_readMsgBlock() */
-		/*  [phyinit_I_loadPIEImage] Start of dwc_ddrphy_phyinit_I_loadPIEImage() */
-#endif /*  DDR3_SW_FFC */
-		ddr_dbg("1D training done!!!!\n");
-	} /* !after_retention */else {/* after_retention */
-		/* restore_1d2d_trained_csr_ddr3_p0(SAVE_DDRPHY_TRAIN_ADDR); */
-		restore_1d2d_trained_csr_ddr3_p012(SAVE_DDRPHY_TRAIN_ADDR);
-	} /* after_retention */
-	/*  */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	/*  (I) Load PHY Init Engine Image */
-	/*  */
-	/*  Load the PHY Initialization Engine memory with the provided initialization sequence. */
-	/*  See PhyInit App Note for detailed description and function usage */
-	/*  */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	/*  */
-	/*  Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
-	/*  This allows the memory controller unrestricted access to the configuration CSRs. */
-	dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-	/*  [phyinit_I_loadPIEImage] Programming PIE Production Code */
-	dwc_ddrphy_apb_wr(0x90000, 0x10); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s0 */
-	dwc_ddrphy_apb_wr(0x90001, 0x400); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s1 */
-	dwc_ddrphy_apb_wr(0x90002, 0x10e); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s2 */
-	dwc_ddrphy_apb_wr(0x90003, 0x0); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s0 */
-	dwc_ddrphy_apb_wr(0x90004, 0x0); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s1 */
-	dwc_ddrphy_apb_wr(0x90005, 0x8); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s2 */
-	dwc_ddrphy_apb_wr(0x90029, 0xb); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s0 */
-	dwc_ddrphy_apb_wr(0x9002a, 0x480); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s1 */
-	dwc_ddrphy_apb_wr(0x9002b, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s2 */
-	dwc_ddrphy_apb_wr(0x9002c, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s0 */
-	dwc_ddrphy_apb_wr(0x9002d, 0x448); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s1 */
-	dwc_ddrphy_apb_wr(0x9002e, 0x139); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s2 */
-	dwc_ddrphy_apb_wr(0x9002f, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s0 */
-	dwc_ddrphy_apb_wr(0x90030, 0x478); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s1 */
-	dwc_ddrphy_apb_wr(0x90031, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s2 */
-	dwc_ddrphy_apb_wr(0x90032, 0x2); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s0 */
-	dwc_ddrphy_apb_wr(0x90033, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s1 */
-	dwc_ddrphy_apb_wr(0x90034, 0x139); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s2 */
-	dwc_ddrphy_apb_wr(0x90035, 0xf); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s0 */
-	dwc_ddrphy_apb_wr(0x90036, 0x7c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s1 */
-	dwc_ddrphy_apb_wr(0x90037, 0x139); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s2 */
-	dwc_ddrphy_apb_wr(0x90038, 0x44); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s0 */
-	dwc_ddrphy_apb_wr(0x90039, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s1 */
-	dwc_ddrphy_apb_wr(0x9003a, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s2 */
-	dwc_ddrphy_apb_wr(0x9003b, 0x14f); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s0 */
-	dwc_ddrphy_apb_wr(0x9003c, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s1 */
-	dwc_ddrphy_apb_wr(0x9003d, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s2 */
-	dwc_ddrphy_apb_wr(0x9003e, 0x47); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s0 */
-	dwc_ddrphy_apb_wr(0x9003f, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s1 */
-	dwc_ddrphy_apb_wr(0x90040, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s2 */
-	dwc_ddrphy_apb_wr(0x90041, 0x4f); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s0 */
-	dwc_ddrphy_apb_wr(0x90042, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s1 */
-	dwc_ddrphy_apb_wr(0x90043, 0x179); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s2 */
-	dwc_ddrphy_apb_wr(0x90044, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s0 */
-	dwc_ddrphy_apb_wr(0x90045, 0xe0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s1 */
-	dwc_ddrphy_apb_wr(0x90046, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s2 */
-	dwc_ddrphy_apb_wr(0x90047, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s0 */
-	dwc_ddrphy_apb_wr(0x90048, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s1 */
-	dwc_ddrphy_apb_wr(0x90049, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s2 */
-	dwc_ddrphy_apb_wr(0x9004a, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s0 */
-	dwc_ddrphy_apb_wr(0x9004b, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s1 */
-	dwc_ddrphy_apb_wr(0x9004c, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s2 */
-	dwc_ddrphy_apb_wr(0x9004d, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s0 */
-	dwc_ddrphy_apb_wr(0x9004e, 0x45a); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s1 */
-	dwc_ddrphy_apb_wr(0x9004f, 0x9); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s2 */
-	dwc_ddrphy_apb_wr(0x90050, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s0 */
-	dwc_ddrphy_apb_wr(0x90051, 0x448); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s1 */
-	dwc_ddrphy_apb_wr(0x90052, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s2 */
-	dwc_ddrphy_apb_wr(0x90053, 0x40); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s0 */
-	dwc_ddrphy_apb_wr(0x90054, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s1 */
-	dwc_ddrphy_apb_wr(0x90055, 0x179); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s2 */
-	dwc_ddrphy_apb_wr(0x90056, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s0 */
-	dwc_ddrphy_apb_wr(0x90057, 0x618); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s1 */
-	dwc_ddrphy_apb_wr(0x90058, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s2 */
-	dwc_ddrphy_apb_wr(0x90059, 0x40c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s0 */
-	dwc_ddrphy_apb_wr(0x9005a, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s1 */
-	dwc_ddrphy_apb_wr(0x9005b, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s2 */
-	dwc_ddrphy_apb_wr(0x9005c, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s0 */
-	dwc_ddrphy_apb_wr(0x9005d, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s1 */
-	dwc_ddrphy_apb_wr(0x9005e, 0x48); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s2 */
-	dwc_ddrphy_apb_wr(0x9005f, 0x4040); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s0 */
-	dwc_ddrphy_apb_wr(0x90060, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s1 */
-	dwc_ddrphy_apb_wr(0x90061, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s2 */
-	dwc_ddrphy_apb_wr(0x90062, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s0 */
-	dwc_ddrphy_apb_wr(0x90063, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s1 */
-	dwc_ddrphy_apb_wr(0x90064, 0x48); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s2 */
-	dwc_ddrphy_apb_wr(0x90065, 0x40); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s0 */
-	dwc_ddrphy_apb_wr(0x90066, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s1 */
-	dwc_ddrphy_apb_wr(0x90067, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s2 */
-	dwc_ddrphy_apb_wr(0x90068, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s0 */
-	dwc_ddrphy_apb_wr(0x90069, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s1 */
-	dwc_ddrphy_apb_wr(0x9006a, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s2 */
-	dwc_ddrphy_apb_wr(0x9006b, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s0 */
-	dwc_ddrphy_apb_wr(0x9006c, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s1 */
-	dwc_ddrphy_apb_wr(0x9006d, 0x78); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s2 */
-	dwc_ddrphy_apb_wr(0x9006e, 0x549); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s0 */
-	dwc_ddrphy_apb_wr(0x9006f, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s1 */
-	dwc_ddrphy_apb_wr(0x90070, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s2 */
-	dwc_ddrphy_apb_wr(0x90071, 0xd49); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s0 */
-	dwc_ddrphy_apb_wr(0x90072, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s1 */
-	dwc_ddrphy_apb_wr(0x90073, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s2 */
-	dwc_ddrphy_apb_wr(0x90074, 0x94a); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s0 */
-	dwc_ddrphy_apb_wr(0x90075, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s1 */
-	dwc_ddrphy_apb_wr(0x90076, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s2 */
-	dwc_ddrphy_apb_wr(0x90077, 0x441); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s0 */
-	dwc_ddrphy_apb_wr(0x90078, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s1 */
-	dwc_ddrphy_apb_wr(0x90079, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s2 */
-	dwc_ddrphy_apb_wr(0x9007a, 0x42); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s0 */
-	dwc_ddrphy_apb_wr(0x9007b, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s1 */
-	dwc_ddrphy_apb_wr(0x9007c, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s2 */
-	dwc_ddrphy_apb_wr(0x9007d, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s0 */
-	dwc_ddrphy_apb_wr(0x9007e, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s1 */
-	dwc_ddrphy_apb_wr(0x9007f, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s2 */
-	dwc_ddrphy_apb_wr(0x90080, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s0 */
-	dwc_ddrphy_apb_wr(0x90081, 0xe0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s1 */
-	dwc_ddrphy_apb_wr(0x90082, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s2 */
-	dwc_ddrphy_apb_wr(0x90083, 0xa); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s0 */
-	dwc_ddrphy_apb_wr(0x90084, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s1 */
-	dwc_ddrphy_apb_wr(0x90085, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s2 */
-	dwc_ddrphy_apb_wr(0x90086, 0x9); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s0 */
-	dwc_ddrphy_apb_wr(0x90087, 0x3c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s1 */
-	dwc_ddrphy_apb_wr(0x90088, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s2 */
-	dwc_ddrphy_apb_wr(0x90089, 0x9); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s0 */
-	dwc_ddrphy_apb_wr(0x9008a, 0x3c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s1 */
-	dwc_ddrphy_apb_wr(0x9008b, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s2 */
-	dwc_ddrphy_apb_wr(0x9008c, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s0 */
-	dwc_ddrphy_apb_wr(0x9008d, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s1 */
-	dwc_ddrphy_apb_wr(0x9008e, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s2 */
-	dwc_ddrphy_apb_wr(0x9008f, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s0 */
-	dwc_ddrphy_apb_wr(0x90090, 0x3c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s1 */
-	dwc_ddrphy_apb_wr(0x90091, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s2 */
-	dwc_ddrphy_apb_wr(0x90092, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s0 */
-	dwc_ddrphy_apb_wr(0x90093, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s1 */
-	dwc_ddrphy_apb_wr(0x90094, 0x48); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s2 */
-	dwc_ddrphy_apb_wr(0x90095, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s0 */
-	dwc_ddrphy_apb_wr(0x90096, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s1 */
-	dwc_ddrphy_apb_wr(0x90097, 0x58); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s2 */
-	dwc_ddrphy_apb_wr(0x90098, 0xa); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s0 */
-	dwc_ddrphy_apb_wr(0x90099, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s1 */
-	dwc_ddrphy_apb_wr(0x9009a, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s2 */
-	dwc_ddrphy_apb_wr(0x9009b, 0x2); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s0 */
-	dwc_ddrphy_apb_wr(0x9009c, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s1 */
-	dwc_ddrphy_apb_wr(0x9009d, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s2 */
-	dwc_ddrphy_apb_wr(0x9009e, 0x7); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s0 */
-	dwc_ddrphy_apb_wr(0x9009f, 0x7c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s1 */
-	dwc_ddrphy_apb_wr(0x900a0, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s2 */
-	dwc_ddrphy_apb_wr(0x900a1, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s0 */
-	dwc_ddrphy_apb_wr(0x900a2, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s1 */
-	dwc_ddrphy_apb_wr(0x900a3, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s2 */
-	dwc_ddrphy_apb_wr(0x900a4, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s0 */
-	dwc_ddrphy_apb_wr(0x900a5, 0x8140); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s1 */
-	dwc_ddrphy_apb_wr(0x900a6, 0x10c); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s2 */
-	dwc_ddrphy_apb_wr(0x900a7, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s0 */
-	dwc_ddrphy_apb_wr(0x900a8, 0x8138); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s1 */
-	dwc_ddrphy_apb_wr(0x900a9, 0x10c); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s2 */
-	dwc_ddrphy_apb_wr(0x900aa, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s0 */
-	dwc_ddrphy_apb_wr(0x900ab, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s1 */
-	dwc_ddrphy_apb_wr(0x900ac, 0x101); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s2 */
-	dwc_ddrphy_apb_wr(0x900ad, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s0 */
-	dwc_ddrphy_apb_wr(0x900ae, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s1 */
-	dwc_ddrphy_apb_wr(0x900af, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s2 */
-	dwc_ddrphy_apb_wr(0x900b0, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s0 */
-	dwc_ddrphy_apb_wr(0x900b1, 0x448); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s1 */
-	dwc_ddrphy_apb_wr(0x900b2, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s2 */
-	dwc_ddrphy_apb_wr(0x900b3, 0xf); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s0 */
-	dwc_ddrphy_apb_wr(0x900b4, 0x7c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s1 */
-	dwc_ddrphy_apb_wr(0x900b5, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s2 */
-	dwc_ddrphy_apb_wr(0x900b6, 0x47); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s0 */
-	dwc_ddrphy_apb_wr(0x900b7, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s1 */
-	dwc_ddrphy_apb_wr(0x900b8, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s2 */
-	dwc_ddrphy_apb_wr(0x900b9, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s0 */
-	dwc_ddrphy_apb_wr(0x900ba, 0x618); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s1 */
-	dwc_ddrphy_apb_wr(0x900bb, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s2 */
-	dwc_ddrphy_apb_wr(0x900bc, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s0 */
-	dwc_ddrphy_apb_wr(0x900bd, 0xe0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s1 */
-	dwc_ddrphy_apb_wr(0x900be, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s2 */
-	dwc_ddrphy_apb_wr(0x900bf, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s0 */
-	dwc_ddrphy_apb_wr(0x900c0, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s1 */
-	dwc_ddrphy_apb_wr(0x900c1, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s2 */
-	dwc_ddrphy_apb_wr(0x900c2, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s0 */
-	dwc_ddrphy_apb_wr(0x900c3, 0x8140); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s1 */
-	dwc_ddrphy_apb_wr(0x900c4, 0x10c); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s2 */
-	dwc_ddrphy_apb_wr(0x900c5, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s0 */
-	dwc_ddrphy_apb_wr(0x900c6, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s1 */
-	dwc_ddrphy_apb_wr(0x900c7, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s2 */
-	dwc_ddrphy_apb_wr(0x900c8, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s0 */
-	dwc_ddrphy_apb_wr(0x900c9, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s1 */
-	dwc_ddrphy_apb_wr(0x900ca, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s2 */
-	dwc_ddrphy_apb_wr(0x900cb, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s0 */
-	dwc_ddrphy_apb_wr(0x900cc, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s1 */
-	dwc_ddrphy_apb_wr(0x900cd, 0x101); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s2 */
-	dwc_ddrphy_apb_wr(0x90006, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s0 */
-	dwc_ddrphy_apb_wr(0x90007, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s1 */
-	dwc_ddrphy_apb_wr(0x90008, 0x8); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s2 */
-	dwc_ddrphy_apb_wr(0x90009, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s0 */
-	dwc_ddrphy_apb_wr(0x9000a, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s1 */
-	dwc_ddrphy_apb_wr(0x9000b, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s2 */
-	dwc_ddrphy_apb_wr(0xd00e7, 0x400); /*  DWC_DDRPHYA_APBONLY0_SequencerOverride */
-	dwc_ddrphy_apb_wr(0x90017, 0x0); /*  DWC_DDRPHYA_INITENG0_StartVector0b0 */
-	dwc_ddrphy_apb_wr(0x90026, 0x2c); /*  DWC_DDRPHYA_INITENG0_StartVector0b15 */
-	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY0 to 0x32 */
-	dwc_ddrphy_apb_wr(0x2000b, 0x32); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p0 */
-	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY1 to 0x64 */
-	dwc_ddrphy_apb_wr(0x2000c, 0x64); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p0 */
-	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY2 to 0x3e8 */
-	dwc_ddrphy_apb_wr(0x2000d, 0x3e8); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p0 */
-	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY3 to 0x2c */
-	dwc_ddrphy_apb_wr(0x2000e, 0x2c); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p0 */
-	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY0 to 0x10 */
-	dwc_ddrphy_apb_wr(0x12000b, 0x10); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p1 */
-	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY1 to 0x21 */
-	dwc_ddrphy_apb_wr(0x12000c, 0x21); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p1 */
-	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY2 to 0x14c */
-	dwc_ddrphy_apb_wr(0x12000d, 0x14c); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p1 */
-	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY3 to 0x10 */
-	dwc_ddrphy_apb_wr(0x12000e, 0x10); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p1 */
-	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY0 to 0xa */
-	dwc_ddrphy_apb_wr(0x22000b, 0xa); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p2 */
-	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY1 to 0x14 */
-	dwc_ddrphy_apb_wr(0x22000c, 0x14); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p2 */
-	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY2 to 0xcf */
-	dwc_ddrphy_apb_wr(0x22000d, 0xcf); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p2 */
-	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY3 to 0x10 */
-	dwc_ddrphy_apb_wr(0x22000e, 0x10); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p2 */
-	dwc_ddrphy_apb_wr(0x9000c, 0x0); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag0 */
-	dwc_ddrphy_apb_wr(0x9000d, 0x173); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag1 */
-	dwc_ddrphy_apb_wr(0x9000e, 0x60); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag2 */
-	dwc_ddrphy_apb_wr(0x9000f, 0x6110); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag3 */
-	dwc_ddrphy_apb_wr(0x90010, 0x2152); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag4 */
-	dwc_ddrphy_apb_wr(0x90011, 0xdfbd); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag5 */
-	dwc_ddrphy_apb_wr(0x90012, 0xffff); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag6 */
-	dwc_ddrphy_apb_wr(0x90013, 0x6152); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag7 */
-	/*  Disabling Ucclk (PMU) and Hclk (training hardware) */
-	dwc_ddrphy_apb_wr(0xc0080, 0x0); /*  DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
-	/*  Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
-	dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-	/*  [phyinit_I_loadPIEImage] End of dwc_ddrphy_phyinit_I_loadPIEImage() */
-	/*  */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	/*  dwc_ddrphy_phyinit_userCustom_customPostTrain is a user-editable function. */
-	/*  */
-	/*  See PhyInit App Note for detailed description and function usage */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	dwc_ddrphy_phyinit_userCustom_customPostTrain ();
-
-	/*  [dwc_ddrphy_phyinit_userCustom_customPostTrain] End of dwc_ddrphy_phyinit_userCustom_customPostTrain() */
-	/*  [dwc_ddrphy_phyinit_userCustom_J_enterMissionMode] Start of dwc_ddrphy_phyinit_userCustom_J_enterMissionMode() */
-	/*  */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	/*  (J) Initialize the PHY to Mission Mode through DFI Initialization */
-	/*  */
-	/*  Initialize the PHY to mission mode as follows: */
-	/*  */
-	/*  1. Set the PHY input clocks to the desired frequency. */
-	/*  2. Initialize the PHY to mission mode by performing DFI Initialization. */
-	/*     Please see the DFI specification for more information. See the DFI frequency bus encoding in section <XXX>. */
-	/*  Note: The PHY training firmware initializes the DRAM state. if skip */
-	/*  training is used, the DRAM state is not initialized. */
-	/*  */
-	/* ############################################################## */
-	/*  */
-	dwc_ddrphy_phyinit_userCustom_J_enterMissionMode ();
-
-	/*  */
-	/*  [dwc_ddrphy_phyinit_userCustom_J_enterMissionMode] End of dwc_ddrphy_phyinit_userCustom_J_enterMissionMode() */
-	/*  [dwc_ddrphy_phyinit_sequence] End of dwc_ddrphy_phyinit_sequence() */
-	/*  [dwc_ddrphy_phyinit_main] End of dwc_ddrphy_phyinit_main() */
-
-	/* ---------------------------------------------------------------------- */
-	/*   save 1d2d training CSR */
-	/* ---------------------------------------------------------------------- */
-	if (!after_retention) {
-		save_1d2d_trained_csr_ddr3_p012(SAVE_DDRPHY_TRAIN_ADDR);
-	}
-}
diff --git a/board/karo/tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c b/board/karo/tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c
deleted file mode 100644
index e3875f5..0000000
--- a/board/karo/tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier: GPL-2.0+
- */
-
-#include <common.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/ddr.h>
-#include <asm/arch/clock.h>
-#include "anamix_common.h"
-#include "ddr3_define.h"
-
-void umctl2_cfg(void)
-{
-#ifdef DDR_ONE_RANK
-	reg32_write(DDRC_MSTR(0), 0x81040001);
-#else
-	reg32_write(DDRC_MSTR(0), 0x83040001);
-#endif
-
-	reg32_write(DDRC_PWRCTL(0), 0x000000a8);
-	reg32_write(DDRC_PWRTMG(0), 0x00532203);
-
-	reg32_write(DDRC_RFSHCTL0(0), 0x00203020);
-	reg32_write(DDRC_RFSHCTL1(0), 0x0001000d);
-	reg32_write(DDRC_RFSHCTL3(0), 0x00000000);
-	reg32_write(DDRC_RFSHTMG(0), 0x0061008c);
-	reg32_write(DDRC_CRCPARCTL0(0), 0x00000000);
-	reg32_write(DDRC_CRCPARCTL1(0), 0x00000000);
-	reg32_write(DDRC_INIT0(0), 0xc0030002);
-	reg32_write(DDRC_INIT1(0), 0x0001000b);
-	reg32_write(DDRC_INIT2(0), 0x00006303);
-	reg32_write(DDRC_INIT3(0), 0x0d700004);/* MR1, MR0 */
-	reg32_write(DDRC_INIT4(0), 0x00180000);/* MR2 */
-	reg32_write(DDRC_INIT5(0), 0x00090071);
-	reg32_write(DDRC_INIT6(0), 0x00000000);
-	reg32_write(DDRC_INIT7(0), 0x00000000);
-	reg32_write(DDRC_DIMMCTL(0), 0x00000032); /* [1] dimm_addr_mirr_en, it will effect the MRS if use umctl2 to initi dram. */
-	reg32_write(DDRC_RANKCTL(0), 0x00000ee5);
-	reg32_write(DDRC_DRAMTMG0(0), 0x0c101a0e);
-	reg32_write(DDRC_DRAMTMG1(0), 0x000a0314);
-	reg32_write(DDRC_DRAMTMG2(0), 0x04060509);
-	reg32_write(DDRC_DRAMTMG3(0), 0x00002006);
-	reg32_write(DDRC_DRAMTMG4(0), 0x06020306);
-	reg32_write(DDRC_DRAMTMG5(0), 0x0b060202);
-	reg32_write(DDRC_DRAMTMG6(0), 0x060a0009);
-	reg32_write(DDRC_DRAMTMG7(0), 0x0000060b);
-	reg32_write(DDRC_DRAMTMG8(0), 0x01017c0a);
-	reg32_write(DDRC_DRAMTMG9(0), 0x4000000e);
-	reg32_write(DDRC_DRAMTMG10(0), 0x00070803);
-	reg32_write(DDRC_DRAMTMG11(0), 0x0101000b);
-	reg32_write(DDRC_DRAMTMG12(0), 0x00000000);
-	reg32_write(DDRC_DRAMTMG13(0), 0x5d000000);
-	reg32_write(DDRC_DRAMTMG14(0), 0x00000b39);
-	reg32_write(DDRC_DRAMTMG15(0), 0x80000000);
-	reg32_write(DDRC_DRAMTMG17(0), 0x00f1006a);
-	reg32_write(DDRC_ZQCTL0(0), 0x50800020);
-	reg32_write(DDRC_ZQCTL1(0), 0x00000070);
-	reg32_write(DDRC_ZQCTL2(0), 0x00000000);
-	reg32_write(DDRC_DFITMG0(0), 0x03868203);
-	reg32_write(DDRC_DFITMG1(0), 0x00020103);
-	reg32_write(DDRC_DFILPCFG0(0), 0x07713021);
-	reg32_write(DDRC_DFILPCFG1(0), 0x00000010);
-	reg32_write(DDRC_DFIUPD0(0), 0xe0400018);
-	reg32_write(DDRC_DFIUPD1(0), 0x0005003c);
-	reg32_write(DDRC_DFIUPD2(0), 0x80000000);
-	reg32_write(DDRC_DFIMISC(0), 0x00000011);
-	reg32_write(DDRC_DFITMG2(0), 0x00000603);
-	reg32_write(DDRC_DFITMG3(0), 0x00000001);
-	reg32_write(DDRC_DBICTL(0), 0x00000001);
-	reg32_write(DDRC_DFIPHYMSTR(0), 0x00000000);
-
-	/*  My test mapping in this test case, for 8Gb,(two 4Gb, x16 DDR3) (col addr:10 bits  row addr: 15 bits  bank addr: 3bits  2 ranks) */
-	/*  MEMC_BURST_LENGTH = 8 */
-	/* ----------------------------------------------------------------------------------------------------------------------------------- */
-	/*  AXI add: 31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13   12  11  10  9   8   7   6   5   4   3   2   1   0 (MEM_DATWIDTH=64) */
-	/*  AXI add: 30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12   11  10  9   8   7   6   5   4   3   2   1   0     (MEM_DATWIDTH=32) *** */
-	/*  AXI add: 29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11   10  9   8   7   6   5   4   3   2   1   0         (MEM_DATWIDTH=16) */
-	/* ----------------------------------------------------------------------------------------------------------------------------------- */
-	/*  HIF add: 28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0   -   -   - */
-	/* ----------------------------------------------------------------------------------------------------------------------------------- */
-	/*  **** for Full DQ bus width (X32) **** */
-	/*           cs  r14 r13 r12 r11 r10 r9  r8  r7  r6  r5  r4  r3  r2  r1  r0  b2  b1  b0  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 */
-	/* Int base  6   20  19  18  17  16  15  14  13  12  11  10  9   8   7   6   4   3   2    9   8  7   6   5    4   3   2   - */
-	/* p Value   22  7   7   7   7   7   7   7   7   7    7   7  7   7   7   7   8   8   8    0   0  0   0   0    0   0   0   - */
-	/* ----------------------------------------------------------------------------------------------------------------------------------- */
-
-	reg32_write(DDRC_ADDRMAP0(0), 0x00000016); /* [4:0] cs-bit0: 6+22=28; [12:8] cs-bit1: 7+0 */
-	reg32_write(DDRC_ADDRMAP1(0), 0x00080808); /* [5:0] bank b0: 2+8; [13:8] b1: P3+8 ; [21:16] b2: 4+8 */
-	reg32_write(DDRC_ADDRMAP2(0), 0x00000000); /* [3:0] col-b2: 2;  [11:8] col-b3: 3; [19:16] col-b4: 4 ; [27:24] col-b5: 5 */
-	reg32_write(DDRC_ADDRMAP3(0), 0x00000000); /* [3:0] col-b6: 6;  [11:8] col-b7: 7; [19:16] col-b8: 8 ; [27:24] col-b9: 9 */
-	reg32_write(DDRC_ADDRMAP4(0), 0x00001f1f); /* col-b10, col-b11 not used */
-	reg32_write(DDRC_ADDRMAP5(0), 0x07070707); /* [3:0] row-b0: 6;  [11:8] row-b1: 7; [19:16] row-b2_b10 ; [27:24] row-b11: 17 */
-	reg32_write(DDRC_ADDRMAP6(0), 0x0f070707); /* [3:0] row-b12:18; [11:8] row-b13: 19; [19:16] row-b14:20 */
-	reg32_write(DDRC_ADDRMAP7(0), 0x00000f0f);
-	reg32_write(DDRC_ADDRMAP8(0), 0x00000000); /* [5:0] bg-b0; [13:8]bg-b1 */
-	reg32_write(DDRC_ADDRMAP9(0), 0x0a020b06); /*  it's valid only when ADDRMAP5.addrmap_row_b2_10 is set to value 15 */
-	reg32_write(DDRC_ADDRMAP10(0), 0x0a0a0a0a);/*  it's valid only when ADDRMAP5.addrmap_row_b2_10 is set to value 15 */
-	reg32_write(DDRC_ADDRMAP11(0), 0x00000000);
-
-
-	reg32_write(DDRC_ODTCFG(0), 0x041d0f5c);
-	reg32_write(DDRC_ODTMAP(0), 0x00000201);
-	reg32_write(DDRC_SCHED(0), 0x7ab50b07);
-	reg32_write(DDRC_SCHED1(0), 0x00000022);
-	reg32_write(DDRC_PERFHPR1(0), 0x7b00665e);
-	reg32_write(DDRC_PERFLPR1(0), 0x2b00c4e1);
-	reg32_write(DDRC_PERFWR1(0), 0xb700c9fe);
-	reg32_write(DDRC_DBG0(0), 0x00000017);
-	reg32_write(DDRC_DBG1(0), 0x00000000);
-	reg32_write(DDRC_DBGCMD(0), 0x00000000);
-	reg32_write(DDRC_SWCTL(0), 0x00000001);
-	reg32_write(DDRC_POISONCFG(0), 0x00010000);
-	reg32_write(DDRC_PCCFG(0), 0x00000100);
-	reg32_write(DDRC_PCFGR_0(0), 0x00003051);
-	reg32_write(DDRC_PCFGW_0(0), 0x000061d2);
-	reg32_write(DDRC_PCTRL_0(0), 0x00000001);
-	reg32_write(DDRC_PCFGQOS0_0(0), 0x02100b04);
-	reg32_write(DDRC_PCFGQOS1_0(0), 0x003f0353);
-	reg32_write(DDRC_PCFGWQOS0_0(0), 0x00000002);
-	reg32_write(DDRC_PCFGWQOS1_0(0), 0x000005fd);
-}
-
-void umctl2_freq1_cfg(void)
-{
-	reg32_write(DDRC_FREQ1_RFSHCTL0(0), 0x00d19034);
-	reg32_write(DDRC_FREQ1_RFSHTMG(0), 0x0040805e);
-	reg32_write(DDRC_FREQ1_INIT3(0), 0x09300004);
-	reg32_write(DDRC_FREQ1_INIT4(0), 0x00080000);
-	reg32_write(DDRC_FREQ1_INIT6(0), 0x00000000);
-	reg32_write(DDRC_FREQ1_INIT7(0), 0x00000000);
-	reg32_write(DDRC_FREQ1_DRAMTMG0(0), 0x090e110a);
-	reg32_write(DDRC_FREQ1_DRAMTMG1(0), 0x0007020e);
-	reg32_write(DDRC_FREQ1_DRAMTMG2(0), 0x03040407);
-	reg32_write(DDRC_FREQ1_DRAMTMG3(0), 0x00002006);
-	reg32_write(DDRC_FREQ1_DRAMTMG4(0), 0x04020304); /*  tRP=6 --> 7 */
-	reg32_write(DDRC_FREQ1_DRAMTMG5(0), 0x09030202);
-	reg32_write(DDRC_FREQ1_DRAMTMG6(0), 0x0c020000);
-	reg32_write(DDRC_FREQ1_DRAMTMG7(0), 0x00000309);
-	reg32_write(DDRC_FREQ1_DRAMTMG8(0), 0x01010a06);
-	reg32_write(DDRC_FREQ1_DRAMTMG9(0), 0x00000003);
-	reg32_write(DDRC_FREQ1_DRAMTMG10(0), 0x00090906);
-	reg32_write(DDRC_FREQ1_DRAMTMG11(0), 0x01010011);
-	reg32_write(DDRC_FREQ1_DRAMTMG12(0), 0x00000000);
-	reg32_write(DDRC_FREQ1_DRAMTMG13(0), 0x40000000);
-	reg32_write(DDRC_FREQ1_DRAMTMG14(0), 0x000000f3);
-	reg32_write(DDRC_FREQ1_DRAMTMG15(0), 0x80000000);
-	reg32_write(DDRC_FREQ1_DRAMTMG17(0), 0x001a0046);
-	reg32_write(DDRC_FREQ1_ZQCTL0(0),  0x50800020);
-	reg32_write(DDRC_FREQ1_DFITMG0(0), 0x03828201);
-	reg32_write(DDRC_FREQ1_DFITMG1(0), 0x00020103);
-	reg32_write(DDRC_FREQ1_DFITMG2(0), 0x00000201);
-	reg32_write(DDRC_FREQ1_DFITMG3(0), 0x00000001);
-	reg32_write(DDRC_FREQ1_ODTCFG(0),  0x0a1a0768);
-
-}
-
-void umctl2_freq2_cfg(void)
-{
-	reg32_write(DDRC_FREQ2_RFSHCTL0(0), 0x00208014);
-	reg32_write(DDRC_FREQ2_RFSHTMG(0), 0x00308046);
-	reg32_write(DDRC_FREQ2_INIT3(0), 0x05200004);
-	reg32_write(DDRC_FREQ2_INIT4(0), 0x00000000);
-	reg32_write(DDRC_FREQ2_INIT6(0), 0x00000000);
-	reg32_write(DDRC_FREQ2_INIT7(0), 0x00000000);
-	reg32_write(DDRC_FREQ2_DRAMTMG0(0), 0x070a0c07);
-	reg32_write(DDRC_FREQ2_DRAMTMG1(0), 0x0005020b);
-	reg32_write(DDRC_FREQ2_DRAMTMG2(0), 0x03030407);
-	reg32_write(DDRC_FREQ2_DRAMTMG3(0), 0x00002006);
-	reg32_write(DDRC_FREQ2_DRAMTMG4(0), 0x03020204);
-	reg32_write(DDRC_FREQ2_DRAMTMG5(0), 0x04070302);
-	reg32_write(DDRC_FREQ2_DRAMTMG6(0), 0x07080000);
-	reg32_write(DDRC_FREQ2_DRAMTMG7(0), 0x00000704);
-	reg32_write(DDRC_FREQ2_DRAMTMG8(0), 0x02026804);
-	reg32_write(DDRC_FREQ2_DRAMTMG9(0), 0x40000006);
-	reg32_write(DDRC_FREQ2_DRAMTMG10(0), 0x000c0b08);
-	reg32_write(DDRC_FREQ2_DRAMTMG11(0), 0x01010015);
-	reg32_write(DDRC_FREQ2_DRAMTMG12(0), 0x00000000);
-	reg32_write(DDRC_FREQ2_DRAMTMG13(0), 0x51000000);
-	reg32_write(DDRC_FREQ2_DRAMTMG14(0), 0x000002a0);
-	reg32_write(DDRC_FREQ2_DRAMTMG15(0), 0x00000000);
-	reg32_write(DDRC_FREQ2_DRAMTMG17(0), 0x008c0039);
-	reg32_write(DDRC_FREQ2_ZQCTL0(0), 0x50800020);
-	reg32_write(DDRC_FREQ2_DFITMG0(0), 0x03818200);
-	reg32_write(DDRC_FREQ2_DFITMG1(0), 0x00020103);
-	reg32_write(DDRC_FREQ2_DFITMG2(0), 0x00000100);
-	reg32_write(DDRC_FREQ2_DFITMG3(0), 0x00000001);
-	reg32_write(DDRC_FREQ2_ODTCFG(0), 0x04050800);
-
-}
-
-void ddr3_pub_train(void)
-{
-	volatile unsigned int tmp_t;
-
-	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F00003F); /*  assert [0]ddr1_preset_n, [1]ddr1_core_reset_n, [2]ddr1_phy_reset, [3]ddr1_phy_pwrokin_n, [4]src_system_rst_b! */
-	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F00000F); /*  deassert [4]src_system_rst_b! */
-
-	/* change the clock source of dram_apb_clk_root */
-	clock_set_target_val(DRAM_APB_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(4) | CLK_ROOT_PRE_DIV(CLK_ROOT_PRE_DIV4)); /* to source 4 --800MHz/4 */
-
-	dram_pll_init(DRAM_PLL_OUT_400M);
-	ddr_dbg("C: dram pll init finished\n");
-
-	reg32_write(0x303A00EC, 0x0000ffff); /* PGC_CPU_MAPPING */
-	reg32setbit(0x303A00F8, 5);/* PU_PGC_SW_PUP_REQ */
-
-	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F000006); /*  release [0]ddr1_preset_n, [3]ddr1_phy_pwrokin_n */
-
-	reg32_write(DDRC_DBG1(0), 0x00000001);
-	reg32_write(DDRC_PWRCTL(0), 0x00000001);
-
-	while (0 != (0x3 & reg32_read(DDRC_STAT(0))))
-		;
-
-	ddr_dbg("C: cfg umctl2 regs ...\n");
-	umctl2_cfg();
-#ifdef DDR3_SW_FFC
-	umctl2_freq1_cfg();
-	umctl2_freq2_cfg();
-#endif
-
-	reg32_write(DDRC_RFSHCTL3(0), 0x00000011);
-	/* RESET: <ctn> DEASSERTED */
-	/* RESET: <a Port 0  DEASSERTED(0) */
-	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F000000); /*  release all reset */
-
-	reg32_write(DDRC_DBG1(0), 0x00000000);
-	reg32_write(DDRC_PWRCTL(0), 0x00000a8);
-	reg32_write(DDRC_SWCTL(0), 0x00000000);
-
-	reg32_write(DDRC_DFIMISC(0), 0x00000000);
-
-	ddr_dbg("C: phy training ...\n");
-	ddr3_phyinit_train_sw_ffc(0);
-
-	do {
-		tmp_t = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x00020097);
-		ddr_dbg("C: Waiting CalBusy value = 0\n");
-	} while (tmp_t != 0);
-
-	reg32_write(DDRC_DFIMISC(0), 0x00000020);
-
-	/*  wait DFISTAT.dfi_init_complete to 1 */
-	while (0 == (0x1 & reg32_read(DDRC_DFISTAT(0))))
-		;
-
-	/*  clear DFIMISC.dfi_init_complete_en */
-	reg32_write(DDRC_DFIMISC(0), 0x00000000);
-	/*  set DFIMISC.dfi_init_complete_en again */
-	reg32_write(DDRC_DFIMISC(0), 0x00000001);
-	reg32_write(DDRC_PWRCTL(0), 0x0000088);
-
-	/*  set SWCTL.sw_done to enable quasi-dynamic register programming outside reset. */
-	reg32_write(DDRC_SWCTL(0), 0x00000001);
-	/* wait SWSTAT.sw_done_ack to 1 */
-	while (0 == (0x1 & reg32_read(DDRC_SWSTAT(0))))
-		;
-
-	/* wait STAT to normal state */
-	while (0x1 != (0x3 & reg32_read(DDRC_STAT(0))))
-		;
-
-	reg32_write(DDRC_PWRCTL(0), 0x0000088);
-
-	reg32_write(DDRC_PCTRL_0(0), 0x00000001);
-	reg32_write(DDRC_RFSHCTL3(0), 0x00000010); /*  dis_auto-refresh is set to 0 */
-
- }
-
-void ddr_init(void)
-{
-	/* initialize DDR4-2400 (umctl2@800MHz) */
-	ddr3_pub_train();
-}
diff --git a/board/karo/tx8mm/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c b/board/karo/tx8mm/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c
deleted file mode 100644
index f01ed9f..0000000
--- a/board/karo/tx8mm/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c
+++ /dev/null
@@ -1,969 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier: GPL-2.0+
- */
-
-#include <common.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/ddr.h>
-#include <asm/arch/clock.h>
-#include "../ddr.h"
-#include "ddr3_define.h"
-
-static const unsigned int restore_csr[] = {
-	0x200b2,
-	0x1200b2,
-	0x2200b2,
-	0x200cb,
-#ifdef RUN_ON_SILICON
-	0x10043,
-	0x110043,
-	0x210043,
-	0x10143,
-	0x110143,
-	0x210143,
-	0x11043,
-	0x111043,
-	0x211043,
-	0x11143,
-	0x111143,
-	0x211143,
-	0x12043,
-	0x112043,
-	0x212043,
-	0x12143,
-	0x112143,
-	0x212143,
-	0x13043,
-	0x113043,
-	0x213043,
-	0x13143,
-	0x113143,
-	0x213143,
-	0x80,
-	0x100080,
-	0x200080,
-	0x1080,
-	0x101080,
-	0x201080,
-	0x2080,
-	0x102080,
-	0x202080,
-	0x3080,
-	0x103080,
-	0x203080,
-	0x4080,
-	0x104080,
-	0x204080,
-	0x5080,
-	0x105080,
-	0x205080,
-	0x6080,
-	0x106080,
-	0x206080,
-	0x7080,
-	0x107080,
-	0x207080,
-	0x8080,
-	0x108080,
-	0x208080,
-	0x9080,
-	0x109080,
-	0x209080,
-	0x10080,
-	0x110080,
-	0x210080,
-	0x10180,
-	0x110180,
-	0x210180,
-	0x10081,
-	0x110081,
-	0x210081,
-	0x10181,
-	0x110181,
-	0x210181,
-	0x10082,
-	0x110082,
-	0x210082,
-	0x10182,
-	0x110182,
-	0x210182,
-	0x10083,
-	0x110083,
-	0x210083,
-	0x10183,
-	0x110183,
-	0x210183,
-	0x11080,
-	0x111080,
-	0x211080,
-	0x11180,
-	0x111180,
-	0x211180,
-	0x11081,
-	0x111081,
-	0x211081,
-	0x11181,
-	0x111181,
-	0x211181,
-	0x11082,
-	0x111082,
-	0x211082,
-	0x11182,
-	0x111182,
-	0x211182,
-	0x11083,
-	0x111083,
-	0x211083,
-	0x11183,
-	0x111183,
-	0x211183,
-	0x12080,
-	0x112080,
-	0x212080,
-	0x12180,
-	0x112180,
-	0x212180,
-	0x12081,
-	0x112081,
-	0x212081,
-	0x12181,
-	0x112181,
-	0x212181,
-	0x12082,
-	0x112082,
-	0x212082,
-	0x12182,
-	0x112182,
-	0x212182,
-	0x12083,
-	0x112083,
-	0x212083,
-	0x12183,
-	0x112183,
-	0x212183,
-	0x13080,
-	0x113080,
-	0x213080,
-	0x13180,
-	0x113180,
-	0x213180,
-	0x13081,
-	0x113081,
-	0x213081,
-	0x13181,
-	0x113181,
-	0x213181,
-	0x13082,
-	0x113082,
-	0x213082,
-	0x13182,
-	0x113182,
-	0x213182,
-	0x13083,
-	0x113083,
-	0x213083,
-	0x13183,
-	0x113183,
-	0x213183,
-	0x100d0,
-	0x1100d0,
-	0x2100d0,
-	0x101d0,
-	0x1101d0,
-	0x2101d0,
-	0x100d1,
-	0x1100d1,
-	0x2100d1,
-	0x101d1,
-	0x1101d1,
-	0x2101d1,
-	0x100d2,
-	0x1100d2,
-	0x2100d2,
-	0x101d2,
-	0x1101d2,
-	0x2101d2,
-	0x100d3,
-	0x1100d3,
-	0x2100d3,
-	0x101d3,
-	0x1101d3,
-	0x2101d3,
-	0x110d0,
-	0x1110d0,
-	0x2110d0,
-	0x111d0,
-	0x1111d0,
-	0x2111d0,
-	0x110d1,
-	0x1110d1,
-	0x2110d1,
-	0x111d1,
-	0x1111d1,
-	0x2111d1,
-	0x110d2,
-	0x1110d2,
-	0x2110d2,
-	0x111d2,
-	0x1111d2,
-	0x2111d2,
-	0x110d3,
-	0x1110d3,
-	0x2110d3,
-	0x111d3,
-	0x1111d3,
-	0x2111d3,
-	0x120d0,
-	0x1120d0,
-	0x2120d0,
-	0x121d0,
-	0x1121d0,
-	0x2121d0,
-	0x120d1,
-	0x1120d1,
-	0x2120d1,
-	0x121d1,
-	0x1121d1,
-	0x2121d1,
-	0x120d2,
-	0x1120d2,
-	0x2120d2,
-	0x121d2,
-	0x1121d2,
-	0x2121d2,
-	0x120d3,
-	0x1120d3,
-	0x2120d3,
-	0x121d3,
-	0x1121d3,
-	0x2121d3,
-	0x130d0,
-	0x1130d0,
-	0x2130d0,
-	0x131d0,
-	0x1131d0,
-	0x2131d0,
-	0x130d1,
-	0x1130d1,
-	0x2130d1,
-	0x131d1,
-	0x1131d1,
-	0x2131d1,
-	0x130d2,
-	0x1130d2,
-	0x2130d2,
-	0x131d2,
-	0x1131d2,
-	0x2131d2,
-	0x130d3,
-	0x1130d3,
-	0x2130d3,
-	0x131d3,
-	0x1131d3,
-	0x2131d3,
-	0x10068,
-	0x10168,
-	0x10268,
-	0x10368,
-	0x10468,
-	0x10568,
-	0x10668,
-	0x10768,
-	0x10868,
-	0x10069,
-	0x10169,
-	0x10269,
-	0x10369,
-	0x10469,
-	0x10569,
-	0x10669,
-	0x10769,
-	0x10869,
-	0x1006a,
-	0x1016a,
-	0x1026a,
-	0x1036a,
-	0x1046a,
-	0x1056a,
-	0x1066a,
-	0x1076a,
-	0x1086a,
-	0x1006b,
-	0x1016b,
-	0x1026b,
-	0x1036b,
-	0x1046b,
-	0x1056b,
-	0x1066b,
-	0x1076b,
-	0x1086b,
-	0x11068,
-	0x11168,
-	0x11268,
-	0x11368,
-	0x11468,
-	0x11568,
-	0x11668,
-	0x11768,
-	0x11868,
-	0x11069,
-	0x11169,
-	0x11269,
-	0x11369,
-	0x11469,
-	0x11569,
-	0x11669,
-	0x11769,
-	0x11869,
-	0x1106a,
-	0x1116a,
-	0x1126a,
-	0x1136a,
-	0x1146a,
-	0x1156a,
-	0x1166a,
-	0x1176a,
-	0x1186a,
-	0x1106b,
-	0x1116b,
-	0x1126b,
-	0x1136b,
-	0x1146b,
-	0x1156b,
-	0x1166b,
-	0x1176b,
-	0x1186b,
-	0x12068,
-	0x12168,
-	0x12268,
-	0x12368,
-	0x12468,
-	0x12568,
-	0x12668,
-	0x12768,
-	0x12868,
-	0x12069,
-	0x12169,
-	0x12269,
-	0x12369,
-	0x12469,
-	0x12569,
-	0x12669,
-	0x12769,
-	0x12869,
-	0x1206a,
-	0x1216a,
-	0x1226a,
-	0x1236a,
-	0x1246a,
-	0x1256a,
-	0x1266a,
-	0x1276a,
-	0x1286a,
-	0x1206b,
-	0x1216b,
-	0x1226b,
-	0x1236b,
-	0x1246b,
-	0x1256b,
-	0x1266b,
-	0x1276b,
-	0x1286b,
-	0x13068,
-	0x13168,
-	0x13268,
-	0x13368,
-	0x13468,
-	0x13568,
-	0x13668,
-	0x13768,
-	0x13868,
-	0x13069,
-	0x13169,
-	0x13269,
-	0x13369,
-	0x13469,
-	0x13569,
-	0x13669,
-	0x13769,
-	0x13869,
-	0x1306a,
-	0x1316a,
-	0x1326a,
-	0x1336a,
-	0x1346a,
-	0x1356a,
-	0x1366a,
-	0x1376a,
-	0x1386a,
-	0x1306b,
-	0x1316b,
-	0x1326b,
-	0x1336b,
-	0x1346b,
-	0x1356b,
-	0x1366b,
-	0x1376b,
-	0x1386b,
-	0x1008c,
-	0x11008c,
-	0x21008c,
-	0x1018c,
-	0x11018c,
-	0x21018c,
-	0x1008d,
-	0x11008d,
-	0x21008d,
-	0x1018d,
-	0x11018d,
-	0x21018d,
-	0x1008e,
-	0x11008e,
-	0x21008e,
-	0x1018e,
-	0x11018e,
-	0x21018e,
-	0x1008f,
-	0x11008f,
-	0x21008f,
-	0x1018f,
-	0x11018f,
-	0x21018f,
-	0x1108c,
-	0x11108c,
-	0x21108c,
-	0x1118c,
-	0x11118c,
-	0x21118c,
-	0x1108d,
-	0x11108d,
-	0x21108d,
-	0x1118d,
-	0x11118d,
-	0x21118d,
-	0x1108e,
-	0x11108e,
-	0x21108e,
-	0x1118e,
-	0x11118e,
-	0x21118e,
-	0x1108f,
-	0x11108f,
-	0x21108f,
-	0x1118f,
-	0x11118f,
-	0x21118f,
-	0x1208c,
-	0x11208c,
-	0x21208c,
-	0x1218c,
-	0x11218c,
-	0x21218c,
-	0x1208d,
-	0x11208d,
-	0x21208d,
-	0x1218d,
-	0x11218d,
-	0x21218d,
-	0x1208e,
-	0x11208e,
-	0x21208e,
-	0x1218e,
-	0x11218e,
-	0x21218e,
-	0x1208f,
-	0x11208f,
-	0x21208f,
-	0x1218f,
-	0x11218f,
-	0x21218f,
-	0x1308c,
-	0x11308c,
-	0x21308c,
-	0x1318c,
-	0x11318c,
-	0x21318c,
-	0x1308d,
-	0x11308d,
-	0x21308d,
-	0x1318d,
-	0x11318d,
-	0x21318d,
-	0x1308e,
-	0x11308e,
-	0x21308e,
-	0x1318e,
-	0x11318e,
-	0x21318e,
-	0x1308f,
-	0x11308f,
-	0x21308f,
-	0x1318f,
-	0x11318f,
-	0x21318f,
-	0x100c0,
-	0x1100c0,
-	0x2100c0,
-	0x101c0,
-	0x1101c0,
-	0x2101c0,
-	0x102c0,
-	0x1102c0,
-	0x2102c0,
-	0x103c0,
-	0x1103c0,
-	0x2103c0,
-	0x104c0,
-	0x1104c0,
-	0x2104c0,
-	0x105c0,
-	0x1105c0,
-	0x2105c0,
-	0x106c0,
-	0x1106c0,
-	0x2106c0,
-	0x107c0,
-	0x1107c0,
-	0x2107c0,
-	0x108c0,
-	0x1108c0,
-	0x2108c0,
-	0x100c1,
-	0x1100c1,
-	0x2100c1,
-	0x101c1,
-	0x1101c1,
-	0x2101c1,
-	0x102c1,
-	0x1102c1,
-	0x2102c1,
-	0x103c1,
-	0x1103c1,
-	0x2103c1,
-	0x104c1,
-	0x1104c1,
-	0x2104c1,
-	0x105c1,
-	0x1105c1,
-	0x2105c1,
-	0x106c1,
-	0x1106c1,
-	0x2106c1,
-	0x107c1,
-	0x1107c1,
-	0x2107c1,
-	0x108c1,
-	0x1108c1,
-	0x2108c1,
-	0x100c2,
-	0x1100c2,
-	0x2100c2,
-	0x101c2,
-	0x1101c2,
-	0x2101c2,
-	0x102c2,
-	0x1102c2,
-	0x2102c2,
-	0x103c2,
-	0x1103c2,
-	0x2103c2,
-	0x104c2,
-	0x1104c2,
-	0x2104c2,
-	0x105c2,
-	0x1105c2,
-	0x2105c2,
-	0x106c2,
-	0x1106c2,
-	0x2106c2,
-	0x107c2,
-	0x1107c2,
-	0x2107c2,
-	0x108c2,
-	0x1108c2,
-	0x2108c2,
-	0x100c3,
-	0x1100c3,
-	0x2100c3,
-	0x101c3,
-	0x1101c3,
-	0x2101c3,
-	0x102c3,
-	0x1102c3,
-	0x2102c3,
-	0x103c3,
-	0x1103c3,
-	0x2103c3,
-	0x104c3,
-	0x1104c3,
-	0x2104c3,
-	0x105c3,
-	0x1105c3,
-	0x2105c3,
-	0x106c3,
-	0x1106c3,
-	0x2106c3,
-	0x107c3,
-	0x1107c3,
-	0x2107c3,
-	0x108c3,
-	0x1108c3,
-	0x2108c3,
-	0x110c0,
-	0x1110c0,
-	0x2110c0,
-	0x111c0,
-	0x1111c0,
-	0x2111c0,
-	0x112c0,
-	0x1112c0,
-	0x2112c0,
-	0x113c0,
-	0x1113c0,
-	0x2113c0,
-	0x114c0,
-	0x1114c0,
-	0x2114c0,
-	0x115c0,
-	0x1115c0,
-	0x2115c0,
-	0x116c0,
-	0x1116c0,
-	0x2116c0,
-	0x117c0,
-	0x1117c0,
-	0x2117c0,
-	0x118c0,
-	0x1118c0,
-	0x2118c0,
-	0x110c1,
-	0x1110c1,
-	0x2110c1,
-	0x111c1,
-	0x1111c1,
-	0x2111c1,
-	0x112c1,
-	0x1112c1,
-	0x2112c1,
-	0x113c1,
-	0x1113c1,
-	0x2113c1,
-	0x114c1,
-	0x1114c1,
-	0x2114c1,
-	0x115c1,
-	0x1115c1,
-	0x2115c1,
-	0x116c1,
-	0x1116c1,
-	0x2116c1,
-	0x117c1,
-	0x1117c1,
-	0x2117c1,
-	0x118c1,
-	0x1118c1,
-	0x2118c1,
-	0x110c2,
-	0x1110c2,
-	0x2110c2,
-	0x111c2,
-	0x1111c2,
-	0x2111c2,
-	0x112c2,
-	0x1112c2,
-	0x2112c2,
-	0x113c2,
-	0x1113c2,
-	0x2113c2,
-	0x114c2,
-	0x1114c2,
-	0x2114c2,
-	0x115c2,
-	0x1115c2,
-	0x2115c2,
-	0x116c2,
-	0x1116c2,
-	0x2116c2,
-	0x117c2,
-	0x1117c2,
-	0x2117c2,
-	0x118c2,
-	0x1118c2,
-	0x2118c2,
-	0x110c3,
-	0x1110c3,
-	0x2110c3,
-	0x111c3,
-	0x1111c3,
-	0x2111c3,
-	0x112c3,
-	0x1112c3,
-	0x2112c3,
-	0x113c3,
-	0x1113c3,
-	0x2113c3,
-	0x114c3,
-	0x1114c3,
-	0x2114c3,
-	0x115c3,
-	0x1115c3,
-	0x2115c3,
-	0x116c3,
-	0x1116c3,
-	0x2116c3,
-	0x117c3,
-	0x1117c3,
-	0x2117c3,
-	0x118c3,
-	0x1118c3,
-	0x2118c3,
-	0x120c0,
-	0x1120c0,
-	0x2120c0,
-	0x121c0,
-	0x1121c0,
-	0x2121c0,
-	0x122c0,
-	0x1122c0,
-	0x2122c0,
-	0x123c0,
-	0x1123c0,
-	0x2123c0,
-	0x124c0,
-	0x1124c0,
-	0x2124c0,
-	0x125c0,
-	0x1125c0,
-	0x2125c0,
-	0x126c0,
-	0x1126c0,
-	0x2126c0,
-	0x127c0,
-	0x1127c0,
-	0x2127c0,
-	0x128c0,
-	0x1128c0,
-	0x2128c0,
-	0x120c1,
-	0x1120c1,
-	0x2120c1,
-	0x121c1,
-	0x1121c1,
-	0x2121c1,
-	0x122c1,
-	0x1122c1,
-	0x2122c1,
-	0x123c1,
-	0x1123c1,
-	0x2123c1,
-	0x124c1,
-	0x1124c1,
-	0x2124c1,
-	0x125c1,
-	0x1125c1,
-	0x2125c1,
-	0x126c1,
-	0x1126c1,
-	0x2126c1,
-	0x127c1,
-	0x1127c1,
-	0x2127c1,
-	0x128c1,
-	0x1128c1,
-	0x2128c1,
-	0x120c2,
-	0x1120c2,
-	0x2120c2,
-	0x121c2,
-	0x1121c2,
-	0x2121c2,
-	0x122c2,
-	0x1122c2,
-	0x2122c2,
-	0x123c2,
-	0x1123c2,
-	0x2123c2,
-	0x124c2,
-	0x1124c2,
-	0x2124c2,
-	0x125c2,
-	0x1125c2,
-	0x2125c2,
-	0x126c2,
-	0x1126c2,
-	0x2126c2,
-	0x127c2,
-	0x1127c2,
-	0x2127c2,
-	0x128c2,
-	0x1128c2,
-	0x2128c2,
-	0x120c3,
-	0x1120c3,
-	0x2120c3,
-	0x121c3,
-	0x1121c3,
-	0x2121c3,
-	0x122c3,
-	0x1122c3,
-	0x2122c3,
-	0x123c3,
-	0x1123c3,
-	0x2123c3,
-	0x124c3,
-	0x1124c3,
-	0x2124c3,
-	0x125c3,
-	0x1125c3,
-	0x2125c3,
-	0x126c3,
-	0x1126c3,
-	0x2126c3,
-	0x127c3,
-	0x1127c3,
-	0x2127c3,
-	0x128c3,
-	0x1128c3,
-	0x2128c3,
-	0x130c0,
-	0x1130c0,
-	0x2130c0,
-	0x131c0,
-	0x1131c0,
-	0x2131c0,
-	0x132c0,
-	0x1132c0,
-	0x2132c0,
-	0x133c0,
-	0x1133c0,
-	0x2133c0,
-	0x134c0,
-	0x1134c0,
-	0x2134c0,
-	0x135c0,
-	0x1135c0,
-	0x2135c0,
-	0x136c0,
-	0x1136c0,
-	0x2136c0,
-	0x137c0,
-	0x1137c0,
-	0x2137c0,
-	0x138c0,
-	0x1138c0,
-	0x2138c0,
-	0x130c1,
-	0x1130c1,
-	0x2130c1,
-	0x131c1,
-	0x1131c1,
-	0x2131c1,
-	0x132c1,
-	0x1132c1,
-	0x2132c1,
-	0x133c1,
-	0x1133c1,
-	0x2133c1,
-	0x134c1,
-	0x1134c1,
-	0x2134c1,
-	0x135c1,
-	0x1135c1,
-	0x2135c1,
-	0x136c1,
-	0x1136c1,
-	0x2136c1,
-	0x137c1,
-	0x1137c1,
-	0x2137c1,
-	0x138c1,
-	0x1138c1,
-	0x2138c1,
-	0x130c2,
-	0x1130c2,
-	0x2130c2,
-	0x131c2,
-	0x1131c2,
-	0x2131c2,
-	0x132c2,
-	0x1132c2,
-	0x2132c2,
-	0x133c2,
-	0x1133c2,
-	0x2133c2,
-	0x134c2,
-	0x1134c2,
-	0x2134c2,
-	0x135c2,
-	0x1135c2,
-	0x2135c2,
-	0x136c2,
-	0x1136c2,
-	0x2136c2,
-	0x137c2,
-	0x1137c2,
-	0x2137c2,
-	0x138c2,
-	0x1138c2,
-	0x2138c2,
-	0x130c3,
-	0x1130c3,
-	0x2130c3,
-	0x131c3,
-	0x1131c3,
-	0x2131c3,
-	0x132c3,
-	0x1132c3,
-	0x2132c3,
-	0x133c3,
-	0x1133c3,
-	0x2133c3,
-	0x134c3,
-	0x1134c3,
-	0x2134c3,
-	0x135c3,
-	0x1135c3,
-	0x2135c3,
-	0x136c3,
-	0x1136c3,
-	0x2136c3,
-	0x137c3,
-	0x1137c3,
-	0x2137c3,
-	0x138c3,
-	0x1138c3,
-	0x2138c3,
-	0x10020,
-	0x110020,
-	0x210020,
-	0x11020,
-	0x111020,
-	0x211020,
-	0x12020,
-	0x112020,
-	0x212020,
-	0x13020,
-	0x113020,
-#endif
-	0x213020,
-	0x2007d,
-	0x12007d,
-	0x22007d,
-	0
-};
-
-void restore_1d2d_trained_csr_ddr3_p012(unsigned int addr)
-{
-	unsigned int i;
-
-	dwc_ddrphy_apb_wr(0xd0000, 0x0); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-	for (i = 0; restore_csr[i] != 0; i++) {
-		dwc_ddrphy_apb_wr(restore_csr[i], reg32_read(addr + (i << 2)));
-	}
-	dwc_ddrphy_apb_wr(0xd0000, 0x1); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-
-	ddr_dbg("restore 1d2d training registers done \n");
-}
diff --git a/board/karo/tx8mm/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c b/board/karo/tx8mm/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c
deleted file mode 100644
index 4ea62bb..0000000
--- a/board/karo/tx8mm/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c
+++ /dev/null
@@ -1,971 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier: GPL-2.0+
- */
-
-#include <common.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/ddr.h>
-#include <asm/arch/clock.h>
-#include "../ddr.h"
-#include "ddr3_define.h"
-
-static const unsigned int save_csr[] = {
-	0x200b2,
-	0x1200b2,
-	0x2200b2,
-	0x200cb,
-#ifdef RUN_ON_SILICON
-	0x10043,
-	0x110043,
-	0x210043,
-	0x10143,
-	0x110143,
-	0x210143,
-	0x11043,
-	0x111043,
-	0x211043,
-	0x11143,
-	0x111143,
-	0x211143,
-	0x12043,
-	0x112043,
-	0x212043,
-	0x12143,
-	0x112143,
-	0x212143,
-	0x13043,
-	0x113043,
-	0x213043,
-	0x13143,
-	0x113143,
-	0x213143,
-	0x80,
-	0x100080,
-	0x200080,
-	0x1080,
-	0x101080,
-	0x201080,
-	0x2080,
-	0x102080,
-	0x202080,
-	0x3080,
-	0x103080,
-	0x203080,
-	0x4080,
-	0x104080,
-	0x204080,
-	0x5080,
-	0x105080,
-	0x205080,
-	0x6080,
-	0x106080,
-	0x206080,
-	0x7080,
-	0x107080,
-	0x207080,
-	0x8080,
-	0x108080,
-	0x208080,
-	0x9080,
-	0x109080,
-	0x209080,
-	0x10080,
-	0x110080,
-	0x210080,
-	0x10180,
-	0x110180,
-	0x210180,
-	0x10081,
-	0x110081,
-	0x210081,
-	0x10181,
-	0x110181,
-	0x210181,
-	0x10082,
-	0x110082,
-	0x210082,
-	0x10182,
-	0x110182,
-	0x210182,
-	0x10083,
-	0x110083,
-	0x210083,
-	0x10183,
-	0x110183,
-	0x210183,
-	0x11080,
-	0x111080,
-	0x211080,
-	0x11180,
-	0x111180,
-	0x211180,
-	0x11081,
-	0x111081,
-	0x211081,
-	0x11181,
-	0x111181,
-	0x211181,
-	0x11082,
-	0x111082,
-	0x211082,
-	0x11182,
-	0x111182,
-	0x211182,
-	0x11083,
-	0x111083,
-	0x211083,
-	0x11183,
-	0x111183,
-	0x211183,
-	0x12080,
-	0x112080,
-	0x212080,
-	0x12180,
-	0x112180,
-	0x212180,
-	0x12081,
-	0x112081,
-	0x212081,
-	0x12181,
-	0x112181,
-	0x212181,
-	0x12082,
-	0x112082,
-	0x212082,
-	0x12182,
-	0x112182,
-	0x212182,
-	0x12083,
-	0x112083,
-	0x212083,
-	0x12183,
-	0x112183,
-	0x212183,
-	0x13080,
-	0x113080,
-	0x213080,
-	0x13180,
-	0x113180,
-	0x213180,
-	0x13081,
-	0x113081,
-	0x213081,
-	0x13181,
-	0x113181,
-	0x213181,
-	0x13082,
-	0x113082,
-	0x213082,
-	0x13182,
-	0x113182,
-	0x213182,
-	0x13083,
-	0x113083,
-	0x213083,
-	0x13183,
-	0x113183,
-	0x213183,
-	0x100d0,
-	0x1100d0,
-	0x2100d0,
-	0x101d0,
-	0x1101d0,
-	0x2101d0,
-	0x100d1,
-	0x1100d1,
-	0x2100d1,
-	0x101d1,
-	0x1101d1,
-	0x2101d1,
-	0x100d2,
-	0x1100d2,
-	0x2100d2,
-	0x101d2,
-	0x1101d2,
-	0x2101d2,
-	0x100d3,
-	0x1100d3,
-	0x2100d3,
-	0x101d3,
-	0x1101d3,
-	0x2101d3,
-	0x110d0,
-	0x1110d0,
-	0x2110d0,
-	0x111d0,
-	0x1111d0,
-	0x2111d0,
-	0x110d1,
-	0x1110d1,
-	0x2110d1,
-	0x111d1,
-	0x1111d1,
-	0x2111d1,
-	0x110d2,
-	0x1110d2,
-	0x2110d2,
-	0x111d2,
-	0x1111d2,
-	0x2111d2,
-	0x110d3,
-	0x1110d3,
-	0x2110d3,
-	0x111d3,
-	0x1111d3,
-	0x2111d3,
-	0x120d0,
-	0x1120d0,
-	0x2120d0,
-	0x121d0,
-	0x1121d0,
-	0x2121d0,
-	0x120d1,
-	0x1120d1,
-	0x2120d1,
-	0x121d1,
-	0x1121d1,
-	0x2121d1,
-	0x120d2,
-	0x1120d2,
-	0x2120d2,
-	0x121d2,
-	0x1121d2,
-	0x2121d2,
-	0x120d3,
-	0x1120d3,
-	0x2120d3,
-	0x121d3,
-	0x1121d3,
-	0x2121d3,
-	0x130d0,
-	0x1130d0,
-	0x2130d0,
-	0x131d0,
-	0x1131d0,
-	0x2131d0,
-	0x130d1,
-	0x1130d1,
-	0x2130d1,
-	0x131d1,
-	0x1131d1,
-	0x2131d1,
-	0x130d2,
-	0x1130d2,
-	0x2130d2,
-	0x131d2,
-	0x1131d2,
-	0x2131d2,
-	0x130d3,
-	0x1130d3,
-	0x2130d3,
-	0x131d3,
-	0x1131d3,
-	0x2131d3,
-	0x10068,
-	0x10168,
-	0x10268,
-	0x10368,
-	0x10468,
-	0x10568,
-	0x10668,
-	0x10768,
-	0x10868,
-	0x10069,
-	0x10169,
-	0x10269,
-	0x10369,
-	0x10469,
-	0x10569,
-	0x10669,
-	0x10769,
-	0x10869,
-	0x1006a,
-	0x1016a,
-	0x1026a,
-	0x1036a,
-	0x1046a,
-	0x1056a,
-	0x1066a,
-	0x1076a,
-	0x1086a,
-	0x1006b,
-	0x1016b,
-	0x1026b,
-	0x1036b,
-	0x1046b,
-	0x1056b,
-	0x1066b,
-	0x1076b,
-	0x1086b,
-	0x11068,
-	0x11168,
-	0x11268,
-	0x11368,
-	0x11468,
-	0x11568,
-	0x11668,
-	0x11768,
-	0x11868,
-	0x11069,
-	0x11169,
-	0x11269,
-	0x11369,
-	0x11469,
-	0x11569,
-	0x11669,
-	0x11769,
-	0x11869,
-	0x1106a,
-	0x1116a,
-	0x1126a,
-	0x1136a,
-	0x1146a,
-	0x1156a,
-	0x1166a,
-	0x1176a,
-	0x1186a,
-	0x1106b,
-	0x1116b,
-	0x1126b,
-	0x1136b,
-	0x1146b,
-	0x1156b,
-	0x1166b,
-	0x1176b,
-	0x1186b,
-	0x12068,
-	0x12168,
-	0x12268,
-	0x12368,
-	0x12468,
-	0x12568,
-	0x12668,
-	0x12768,
-	0x12868,
-	0x12069,
-	0x12169,
-	0x12269,
-	0x12369,
-	0x12469,
-	0x12569,
-	0x12669,
-	0x12769,
-	0x12869,
-	0x1206a,
-	0x1216a,
-	0x1226a,
-	0x1236a,
-	0x1246a,
-	0x1256a,
-	0x1266a,
-	0x1276a,
-	0x1286a,
-	0x1206b,
-	0x1216b,
-	0x1226b,
-	0x1236b,
-	0x1246b,
-	0x1256b,
-	0x1266b,
-	0x1276b,
-	0x1286b,
-	0x13068,
-	0x13168,
-	0x13268,
-	0x13368,
-	0x13468,
-	0x13568,
-	0x13668,
-	0x13768,
-	0x13868,
-	0x13069,
-	0x13169,
-	0x13269,
-	0x13369,
-	0x13469,
-	0x13569,
-	0x13669,
-	0x13769,
-	0x13869,
-	0x1306a,
-	0x1316a,
-	0x1326a,
-	0x1336a,
-	0x1346a,
-	0x1356a,
-	0x1366a,
-	0x1376a,
-	0x1386a,
-	0x1306b,
-	0x1316b,
-	0x1326b,
-	0x1336b,
-	0x1346b,
-	0x1356b,
-	0x1366b,
-	0x1376b,
-	0x1386b,
-	0x1008c,
-	0x11008c,
-	0x21008c,
-	0x1018c,
-	0x11018c,
-	0x21018c,
-	0x1008d,
-	0x11008d,
-	0x21008d,
-	0x1018d,
-	0x11018d,
-	0x21018d,
-	0x1008e,
-	0x11008e,
-	0x21008e,
-	0x1018e,
-	0x11018e,
-	0x21018e,
-	0x1008f,
-	0x11008f,
-	0x21008f,
-	0x1018f,
-	0x11018f,
-	0x21018f,
-	0x1108c,
-	0x11108c,
-	0x21108c,
-	0x1118c,
-	0x11118c,
-	0x21118c,
-	0x1108d,
-	0x11108d,
-	0x21108d,
-	0x1118d,
-	0x11118d,
-	0x21118d,
-	0x1108e,
-	0x11108e,
-	0x21108e,
-	0x1118e,
-	0x11118e,
-	0x21118e,
-	0x1108f,
-	0x11108f,
-	0x21108f,
-	0x1118f,
-	0x11118f,
-	0x21118f,
-	0x1208c,
-	0x11208c,
-	0x21208c,
-	0x1218c,
-	0x11218c,
-	0x21218c,
-	0x1208d,
-	0x11208d,
-	0x21208d,
-	0x1218d,
-	0x11218d,
-	0x21218d,
-	0x1208e,
-	0x11208e,
-	0x21208e,
-	0x1218e,
-	0x11218e,
-	0x21218e,
-	0x1208f,
-	0x11208f,
-	0x21208f,
-	0x1218f,
-	0x11218f,
-	0x21218f,
-	0x1308c,
-	0x11308c,
-	0x21308c,
-	0x1318c,
-	0x11318c,
-	0x21318c,
-	0x1308d,
-	0x11308d,
-	0x21308d,
-	0x1318d,
-	0x11318d,
-	0x21318d,
-	0x1308e,
-	0x11308e,
-	0x21308e,
-	0x1318e,
-	0x11318e,
-	0x21318e,
-	0x1308f,
-	0x11308f,
-	0x21308f,
-	0x1318f,
-	0x11318f,
-	0x21318f,
-	0x100c0,
-	0x1100c0,
-	0x2100c0,
-	0x101c0,
-	0x1101c0,
-	0x2101c0,
-	0x102c0,
-	0x1102c0,
-	0x2102c0,
-	0x103c0,
-	0x1103c0,
-	0x2103c0,
-	0x104c0,
-	0x1104c0,
-	0x2104c0,
-	0x105c0,
-	0x1105c0,
-	0x2105c0,
-	0x106c0,
-	0x1106c0,
-	0x2106c0,
-	0x107c0,
-	0x1107c0,
-	0x2107c0,
-	0x108c0,
-	0x1108c0,
-	0x2108c0,
-	0x100c1,
-	0x1100c1,
-	0x2100c1,
-	0x101c1,
-	0x1101c1,
-	0x2101c1,
-	0x102c1,
-	0x1102c1,
-	0x2102c1,
-	0x103c1,
-	0x1103c1,
-	0x2103c1,
-	0x104c1,
-	0x1104c1,
-	0x2104c1,
-	0x105c1,
-	0x1105c1,
-	0x2105c1,
-	0x106c1,
-	0x1106c1,
-	0x2106c1,
-	0x107c1,
-	0x1107c1,
-	0x2107c1,
-	0x108c1,
-	0x1108c1,
-	0x2108c1,
-	0x100c2,
-	0x1100c2,
-	0x2100c2,
-	0x101c2,
-	0x1101c2,
-	0x2101c2,
-	0x102c2,
-	0x1102c2,
-	0x2102c2,
-	0x103c2,
-	0x1103c2,
-	0x2103c2,
-	0x104c2,
-	0x1104c2,
-	0x2104c2,
-	0x105c2,
-	0x1105c2,
-	0x2105c2,
-	0x106c2,
-	0x1106c2,
-	0x2106c2,
-	0x107c2,
-	0x1107c2,
-	0x2107c2,
-	0x108c2,
-	0x1108c2,
-	0x2108c2,
-	0x100c3,
-	0x1100c3,
-	0x2100c3,
-	0x101c3,
-	0x1101c3,
-	0x2101c3,
-	0x102c3,
-	0x1102c3,
-	0x2102c3,
-	0x103c3,
-	0x1103c3,
-	0x2103c3,
-	0x104c3,
-	0x1104c3,
-	0x2104c3,
-	0x105c3,
-	0x1105c3,
-	0x2105c3,
-	0x106c3,
-	0x1106c3,
-	0x2106c3,
-	0x107c3,
-	0x1107c3,
-	0x2107c3,
-	0x108c3,
-	0x1108c3,
-	0x2108c3,
-	0x110c0,
-	0x1110c0,
-	0x2110c0,
-	0x111c0,
-	0x1111c0,
-	0x2111c0,
-	0x112c0,
-	0x1112c0,
-	0x2112c0,
-	0x113c0,
-	0x1113c0,
-	0x2113c0,
-	0x114c0,
-	0x1114c0,
-	0x2114c0,
-	0x115c0,
-	0x1115c0,
-	0x2115c0,
-	0x116c0,
-	0x1116c0,
-	0x2116c0,
-	0x117c0,
-	0x1117c0,
-	0x2117c0,
-	0x118c0,
-	0x1118c0,
-	0x2118c0,
-	0x110c1,
-	0x1110c1,
-	0x2110c1,
-	0x111c1,
-	0x1111c1,
-	0x2111c1,
-	0x112c1,
-	0x1112c1,
-	0x2112c1,
-	0x113c1,
-	0x1113c1,
-	0x2113c1,
-	0x114c1,
-	0x1114c1,
-	0x2114c1,
-	0x115c1,
-	0x1115c1,
-	0x2115c1,
-	0x116c1,
-	0x1116c1,
-	0x2116c1,
-	0x117c1,
-	0x1117c1,
-	0x2117c1,
-	0x118c1,
-	0x1118c1,
-	0x2118c1,
-	0x110c2,
-	0x1110c2,
-	0x2110c2,
-	0x111c2,
-	0x1111c2,
-	0x2111c2,
-	0x112c2,
-	0x1112c2,
-	0x2112c2,
-	0x113c2,
-	0x1113c2,
-	0x2113c2,
-	0x114c2,
-	0x1114c2,
-	0x2114c2,
-	0x115c2,
-	0x1115c2,
-	0x2115c2,
-	0x116c2,
-	0x1116c2,
-	0x2116c2,
-	0x117c2,
-	0x1117c2,
-	0x2117c2,
-	0x118c2,
-	0x1118c2,
-	0x2118c2,
-	0x110c3,
-	0x1110c3,
-	0x2110c3,
-	0x111c3,
-	0x1111c3,
-	0x2111c3,
-	0x112c3,
-	0x1112c3,
-	0x2112c3,
-	0x113c3,
-	0x1113c3,
-	0x2113c3,
-	0x114c3,
-	0x1114c3,
-	0x2114c3,
-	0x115c3,
-	0x1115c3,
-	0x2115c3,
-	0x116c3,
-	0x1116c3,
-	0x2116c3,
-	0x117c3,
-	0x1117c3,
-	0x2117c3,
-	0x118c3,
-	0x1118c3,
-	0x2118c3,
-	0x120c0,
-	0x1120c0,
-	0x2120c0,
-	0x121c0,
-	0x1121c0,
-	0x2121c0,
-	0x122c0,
-	0x1122c0,
-	0x2122c0,
-	0x123c0,
-	0x1123c0,
-	0x2123c0,
-	0x124c0,
-	0x1124c0,
-	0x2124c0,
-	0x125c0,
-	0x1125c0,
-	0x2125c0,
-	0x126c0,
-	0x1126c0,
-	0x2126c0,
-	0x127c0,
-	0x1127c0,
-	0x2127c0,
-	0x128c0,
-	0x1128c0,
-	0x2128c0,
-	0x120c1,
-	0x1120c1,
-	0x2120c1,
-	0x121c1,
-	0x1121c1,
-	0x2121c1,
-	0x122c1,
-	0x1122c1,
-	0x2122c1,
-	0x123c1,
-	0x1123c1,
-	0x2123c1,
-	0x124c1,
-	0x1124c1,
-	0x2124c1,
-	0x125c1,
-	0x1125c1,
-	0x2125c1,
-	0x126c1,
-	0x1126c1,
-	0x2126c1,
-	0x127c1,
-	0x1127c1,
-	0x2127c1,
-	0x128c1,
-	0x1128c1,
-	0x2128c1,
-	0x120c2,
-	0x1120c2,
-	0x2120c2,
-	0x121c2,
-	0x1121c2,
-	0x2121c2,
-	0x122c2,
-	0x1122c2,
-	0x2122c2,
-	0x123c2,
-	0x1123c2,
-	0x2123c2,
-	0x124c2,
-	0x1124c2,
-	0x2124c2,
-	0x125c2,
-	0x1125c2,
-	0x2125c2,
-	0x126c2,
-	0x1126c2,
-	0x2126c2,
-	0x127c2,
-	0x1127c2,
-	0x2127c2,
-	0x128c2,
-	0x1128c2,
-	0x2128c2,
-	0x120c3,
-	0x1120c3,
-	0x2120c3,
-	0x121c3,
-	0x1121c3,
-	0x2121c3,
-	0x122c3,
-	0x1122c3,
-	0x2122c3,
-	0x123c3,
-	0x1123c3,
-	0x2123c3,
-	0x124c3,
-	0x1124c3,
-	0x2124c3,
-	0x125c3,
-	0x1125c3,
-	0x2125c3,
-	0x126c3,
-	0x1126c3,
-	0x2126c3,
-	0x127c3,
-	0x1127c3,
-	0x2127c3,
-	0x128c3,
-	0x1128c3,
-	0x2128c3,
-	0x130c0,
-	0x1130c0,
-	0x2130c0,
-	0x131c0,
-	0x1131c0,
-	0x2131c0,
-	0x132c0,
-	0x1132c0,
-	0x2132c0,
-	0x133c0,
-	0x1133c0,
-	0x2133c0,
-	0x134c0,
-	0x1134c0,
-	0x2134c0,
-	0x135c0,
-	0x1135c0,
-	0x2135c0,
-	0x136c0,
-	0x1136c0,
-	0x2136c0,
-	0x137c0,
-	0x1137c0,
-	0x2137c0,
-	0x138c0,
-	0x1138c0,
-	0x2138c0,
-	0x130c1,
-	0x1130c1,
-	0x2130c1,
-	0x131c1,
-	0x1131c1,
-	0x2131c1,
-	0x132c1,
-	0x1132c1,
-	0x2132c1,
-	0x133c1,
-	0x1133c1,
-	0x2133c1,
-	0x134c1,
-	0x1134c1,
-	0x2134c1,
-	0x135c1,
-	0x1135c1,
-	0x2135c1,
-	0x136c1,
-	0x1136c1,
-	0x2136c1,
-	0x137c1,
-	0x1137c1,
-	0x2137c1,
-	0x138c1,
-	0x1138c1,
-	0x2138c1,
-	0x130c2,
-	0x1130c2,
-	0x2130c2,
-	0x131c2,
-	0x1131c2,
-	0x2131c2,
-	0x132c2,
-	0x1132c2,
-	0x2132c2,
-	0x133c2,
-	0x1133c2,
-	0x2133c2,
-	0x134c2,
-	0x1134c2,
-	0x2134c2,
-	0x135c2,
-	0x1135c2,
-	0x2135c2,
-	0x136c2,
-	0x1136c2,
-	0x2136c2,
-	0x137c2,
-	0x1137c2,
-	0x2137c2,
-	0x138c2,
-	0x1138c2,
-	0x2138c2,
-	0x130c3,
-	0x1130c3,
-	0x2130c3,
-	0x131c3,
-	0x1131c3,
-	0x2131c3,
-	0x132c3,
-	0x1132c3,
-	0x2132c3,
-	0x133c3,
-	0x1133c3,
-	0x2133c3,
-	0x134c3,
-	0x1134c3,
-	0x2134c3,
-	0x135c3,
-	0x1135c3,
-	0x2135c3,
-	0x136c3,
-	0x1136c3,
-	0x2136c3,
-	0x137c3,
-	0x1137c3,
-	0x2137c3,
-	0x138c3,
-	0x1138c3,
-	0x2138c3,
-	0x10020,
-	0x110020,
-	0x210020,
-	0x11020,
-	0x111020,
-	0x211020,
-	0x12020,
-	0x112020,
-	0x212020,
-	0x13020,
-	0x113020,
-#endif
-	0x213020,
-	0x2007d,
-	0x12007d,
-	0x22007d,
-	0
-};
-
-void save_1d2d_trained_csr_ddr3_p012(unsigned int addr)
-{
-	unsigned int i;
-
-	dwc_ddrphy_apb_wr(0xd0000, 0x0); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-	dwc_ddrphy_apb_wr(0xc0080, 0x3); /* DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
-	for (i = 0; save_csr[i] != 0; i++) {
-		reg32_write(addr + (i << 2), dwc_ddrphy_apb_rd(save_csr[i]));
-	}
-	dwc_ddrphy_apb_wr(0xc0080, 0x0); /* DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
-	dwc_ddrphy_apb_wr(0xd0000, 0x1); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
-
-	ddr_dbg("save 1d2d training registers done \n");
-}
diff --git a/board/karo/tx8mm/ddr/ddr_init.c b/board/karo/tx8mm/ddr/ddr_init.c
deleted file mode 100644
index 6d15c11..0000000
--- a/board/karo/tx8mm/ddr/ddr_init.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright 2017 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Generated code from MX8M_DDR_tool
- * Align with uboot-imx_v2017.03_4.9.51_imx8m_ga
- */
-
-#include <common.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/ddr.h>
-#include <asm/arch/clock.h>
-#include "ddr.h"
-
-#ifdef CONFIG_ENABLE_DDR_TRAINING_DEBUG
-#define ddr_printf(args...) printf(args)
-#else
-#define ddr_printf(args...) do {} while (0)
-#endif
-
-#define SILICON_TRAIN
-
-void ddr_cfg_phy(void);
-volatile unsigned int tmp, tmp_t, i;
-void ddr_init(void)
-{
-	/** Initialize DDR clock and DDRC registers **/
-	reg32_write(0x30391000, 0x8f00003f);
-	reg32_write(0x30391000, 0x8f00000f);
-	reg32_write(0x3038a088, 0x7070000);
-	reg32_write(0x3038a084, 0x4030000);
-	reg32_write(0x303a00ec, 0xffff);
-	tmp = reg32_read(0x303a00f8);
-	tmp |= 0x20;
-	reg32_write(0x303a00f8,tmp);
-	reg32_write(0x30391004, 0x8f000000);
-	reg32_write(0x30360054, 0x12c091);
-	reg32_write(0x30360058, 0x0);
-	tmp = reg32_read(0x30360050);
-	tmp |= 0x200;
-	reg32_write(0x30360050,tmp);
-	tmp = reg32_read(0x30360050);
-	tmp &= ~0x10;
-	reg32_write(0x30360050,tmp);
-	do {
-		tmp = reg32_read(0x30360050);
-		if (tmp & 0x80000000)
-			break;
-	} while (1);
-	reg32_write(0x30391000, 0x8f000006);
-	reg32_write(0x3d400304, 0x1);
-	reg32_write(0x3d400030, 0x20);
-	reg32_write(0x3d400000, 0x81040001);
-	reg32_write(0x3d400010, 0x40004010);
-	reg32_write(0x3d400064, 0x610068);
-	reg32_write(0x3d4000d0, 0xc00200c5);
-	reg32_write(0x3d4000d4, 0x1000b);
-	reg32_write(0x3d4000dc, 0x1c700004);
-	reg32_write(0x3d4000e0, 0x180000);
-	reg32_write(0x3d4000e4, 0x90000);
-	reg32_write(0x3d4000f0, 0x0);
-	reg32_write(0x3d4000f4, 0xee5);
-	reg32_write(0x3d400100, 0xc101b0e);
-	reg32_write(0x3d400104, 0x30314);
-	reg32_write(0x3d400108, 0x4060509);
-	reg32_write(0x3d40010c, 0x2006);
-	reg32_write(0x3d400110, 0x6020306);
-	reg32_write(0x3d400114, 0x4040302);
-	reg32_write(0x3d400120, 0x905);
-	reg32_write(0x3d400180, 0x40800020);
-	reg32_write(0x3d400184, 0xc350);
-	reg32_write(0x3d400190, 0x3868203);
-	reg32_write(0x3d400194, 0x20303);
-	reg32_write(0x3d4001b4, 0x603);
-	reg32_write(0x3d400198, 0x7000000);
-	reg32_write(0x3d4001b0, 0x11);
-	reg32_write(0x3d4001a0, 0x400018);
-	reg32_write(0x3d4001a4, 0x5003c);
-	reg32_write(0x3d4001a8, 0x80000000);
-	reg32_write(0x3d4001c4, 0x1);
-	reg32_write(0x3d400200, 0x1f);
-	reg32_write(0x3d400204, 0x80808);
-	reg32_write(0x3d400208, 0x0);
-	reg32_write(0x3d40020c, 0x0);
-	reg32_write(0x3d400210, 0x1f1f);
-	reg32_write(0x3d400214, 0x7070707);
-	reg32_write(0x3d400218, 0xf070707);
-	reg32_write(0x3d400224, 0xa020b06);
-	reg32_write(0x3d400228, 0xa0a0a0a);
-	reg32_write(0x3d40022c, 0x0);
-	reg32_write(0x3d400240, 0x600060c);
-	reg32_write(0x3d400244, 0x1323);
-	reg32_write(0x3d400264, 0x9);
-	reg32_write(0x3d40049c, 0x100001);
-	reg32_write(0x3d4004a0, 0x41f);
-	reg32_write(0x30391000, 0x8f000000);
-	reg32_write(0x3d400304, 0x0);
-	reg32_write(0x3d400030, 0xa8);
-	reg32_write(0x3d400320, 0x0);
-	reg32_write(0x30391000, 0x8f000004);
-	reg32_write(0x30391000, 0x8f000000);
-	reg32_write(0x3d400320, 0x0);
-	reg32_write(0x3d4001b0, 0x0);
-	do {
-		tmp = reg32_read(0x3d400308);
-		if (tmp & 0x36000000) break;
-	} while (1);
-	reg32_write(0x3d400490, 0x0);
-	do {
-		tmp = reg32_read(0x3d4003fc);
-		if ((tmp & 0x10001) == 0) break;
-	} while (1);
-	reg32_write(0x3d400030, 0xa8);
-	do {
-		tmp = reg32_read(0x3d400004);
-		if (tmp & 0x3) break;
-	} while (1);
-
-	/* Configure DDR PHY's registers */
-	ddr_cfg_phy();
-
-	reg32_write(DDRC_RFSHCTL3(0), 0x00000000);
-	reg32_write(DDRC_SWCTL(0), 0x0000);
-	/*
-	 * ------------------- 9 -------------------
-	 * Set DFIMISC.dfi_init_start to 1
-	 *  -----------------------------------------
-	 */
-	reg32_write(DDRC_DFIMISC(0), 0x00000030);
-	reg32_write(DDRC_SWCTL(0), 0x0001);
-
-	/* wait DFISTAT.dfi_init_complete to 1 */
-	tmp_t = 0;
-	while (tmp_t == 0) {
-		tmp  = reg32_read(DDRC_DFISTAT(0));
-		tmp_t = tmp & 0x01;
-		tmp  = reg32_read(DDRC_MRSTAT(0));
-	}
-
-	reg32_write(DDRC_SWCTL(0), 0x0000);
-
-	/* clear DFIMISC.dfi_init_complete_en */
-	reg32_write(DDRC_DFIMISC(0), 0x00000010);
-	reg32_write(DDRC_DFIMISC(0), 0x00000011);
-	reg32_write(DDRC_PWRCTL(0), 0x00000088);
-
-	tmp = reg32_read(DDRC_CRCPARSTAT(0));
-	/*
-	 * set SWCTL.sw_done to enable quasi-dynamic register
-	 * programming outside reset.
-	 */
-	reg32_write(DDRC_SWCTL(0), 0x00000001);
-
-	/* wait SWSTAT.sw_done_ack to 1 */
-	while ((reg32_read(DDRC_SWSTAT(0)) & 0x1) == 0)
-		;
-
-	/* wait STAT.operating_mode([1:0] for ddr3) to normal state */
-	while ((reg32_read(DDRC_STAT(0)) & 0x3) != 0x1)
-		;
-
-	reg32_write(DDRC_PWRCTL(0), 0x00000088);
-	/* reg32_write(DDRC_PWRCTL(0), 0x018a); */
-	tmp = reg32_read(DDRC_CRCPARSTAT(0));
-
-	/* enable port 0 */
-	reg32_write(DDRC_PCTRL_0(0), 0x00000001);
-	/* enable DDR auto-refresh mode */
-	tmp = reg32_read(DDRC_RFSHCTL3(0)) & ~0x1;
-	reg32_write(DDRC_RFSHCTL3(0), tmp);
-}
diff --git a/board/karo/tx8mm/ddr/ddrphy_train.c b/board/karo/tx8mm/ddr/ddrphy_train.c
deleted file mode 100644
index 3d9fe28..0000000
--- a/board/karo/tx8mm/ddr/ddrphy_train.c
+++ /dev/null
@@ -1,351 +0,0 @@
-/*
- * Copyright 2017 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Generated code from MX8M_DDR_tool
- * Align with uboot-imx_v2017.03_4.9.51_imx8m_ga
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/ddr.h>
-#include "ddr.h"
-
-extern void wait_ddrphy_training_complete(void);
-void ddr_cfg_phy(void) {
-	unsigned int tmp, calbusy;
-
-	//Init DDRPHY register...
-	reg32_write(0x3c04017c, 0x3ff);
-	reg32_write(0x3c04057c, 0x3ff);
-	reg32_write(0x3c04417c, 0x3ff);
-	reg32_write(0x3c04457c, 0x3ff);
-	reg32_write(0x3c04817c, 0x3ff);
-	reg32_write(0x3c04857c, 0x3ff);
-	reg32_write(0x3c04c17c, 0x3ff);
-	reg32_write(0x3c04c57c, 0x3ff);
-	reg32_write(0x3c000154, 0x3ff);
-	reg32_write(0x3c004154, 0x3ff);
-	reg32_write(0x3c008154, 0x3ff);
-	reg32_write(0x3c00c154, 0x3ff);
-	reg32_write(0x3c010154, 0xff);
-	reg32_write(0x3c014154, 0xff);
-	reg32_write(0x3c018154, 0x3ff);
-	reg32_write(0x3c01c154, 0x3ff);
-	reg32_write(0x3c020154, 0x3ff);
-	reg32_write(0x3c024154, 0x3ff);
-	reg32_write(0x3c080314, 0xb);
-	reg32_write(0x3c0800b8, 0x1);
-	reg32_write(0x3c080090, 0x8);
-	reg32_write(0x3c0800e8, 0x0);
-	reg32_write(0x3c080158, 0xa);
-	reg32_write(0x3c040134, 0x208);
-	reg32_write(0x3c040534, 0x208);
-	reg32_write(0x3c044134, 0x208);
-	reg32_write(0x3c044534, 0x208);
-	reg32_write(0x3c048134, 0x208);
-	reg32_write(0x3c048534, 0x208);
-	reg32_write(0x3c04c134, 0x208);
-	reg32_write(0x3c04c534, 0x208);
-	reg32_write(0x3c040124, 0x618);
-	reg32_write(0x3c040524, 0x618);
-	reg32_write(0x3c044124, 0x618);
-	reg32_write(0x3c044524, 0x618);
-	reg32_write(0x3c048124, 0x618);
-	reg32_write(0x3c048524, 0x618);
-	reg32_write(0x3c04c124, 0x618);
-	reg32_write(0x3c04c524, 0x618);
-	reg32_write(0x3c00010c, 0x21);
-	reg32_write(0x3c00410c, 0x21);
-	reg32_write(0x3c00810c, 0x21);
-	reg32_write(0x3c00c10c, 0x21);
-	reg32_write(0x3c01010c, 0x21);
-	reg32_write(0x3c01410c, 0x21);
-	reg32_write(0x3c01810c, 0x21);
-	reg32_write(0x3c01c10c, 0x21);
-	reg32_write(0x3c02010c, 0x21);
-	reg32_write(0x3c02410c, 0x21);
-	reg32_write(0x3c080060, 0x5);
-	reg32_write(0x3c0801d4, 0x0);
-	reg32_write(0x3c080140, 0x0);
-	reg32_write(0x3c080020, 0x190);
-	reg32_write(0x3c080220, 0x9);
-	reg32_write(0x3c0802c8, 0x0);
-	reg32_write(0x3c04010c, 0x581);
-	reg32_write(0x3c04050c, 0x581);
-	reg32_write(0x3c04410c, 0x581);
-	reg32_write(0x3c04450c, 0x581);
-	reg32_write(0x3c04810c, 0x581);
-	reg32_write(0x3c04850c, 0x581);
-	reg32_write(0x3c04c10c, 0x581);
-	reg32_write(0x3c04c50c, 0x581);
-	reg32_write(0x3c0803e8, 0x1);
-	reg32_write(0x3c080064, 0x5);
-	reg32_write(0x3c0803c0, 0x5555);
-	reg32_write(0x3c0803c4, 0x5555);
-	reg32_write(0x3c0803c8, 0x5555);
-	reg32_write(0x3c0803cc, 0x5555);
-	reg32_write(0x3c0803d0, 0x5555);
-	reg32_write(0x3c0803d4, 0x5555);
-	reg32_write(0x3c0803d8, 0x5555);
-	reg32_write(0x3c0803dc, 0xf000);
-	reg32_write(0x3c080094, 0x0);
-	reg32_write(0x3c0800b4, 0x0);
-	reg32_write(0x3c08031c, 0x21);
-	reg32_write(0x3c080328, 0x24);
-
-	//enable APB bus to access DDRPHY RAM
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x0);
-	//load the 1D training image
-	ddr_load_train_code(FW_1D_IMAGE);
-
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54003, 0x640);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54004, 0x2);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54005, 0x3c3c);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54006, 0x12c);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54007, 0x2000);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54008, 0x101);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5400b, 0x31f);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5400c, 0xc8);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54012, 0x1);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5402f, 0x1c70);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54030, 0x4);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54031, 0x18);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5403a, 0x1323);
-
-	//disable APB bus to access DDRPHY RAM
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x1);
-	//Reset MPU and run
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x9);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x1);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x0);
-	wait_ddrphy_training_complete();
-
-	//set the PHY input clock to the desired frequency for pstate 0
-	reg32_write(0x30360054, 0x12c091);
-	reg32_write(0x30360058, 0x0);
-	tmp = reg32_read(0x30360050);
-	tmp |= 0x200;
-	reg32_write(0x30360050, tmp);
-	tmp = reg32_read(0x30360050);
-	tmp &= ~0x10;
-	reg32_write(0x30360050, tmp);
-	do {
-		tmp = reg32_read(0x30360050);
-		if (tmp & 0x80000000)
-			break;
-	} while (1);
-
-	//Halt MPU
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x1);
-	//enable APB bus to access DDRPHY RAM
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x0);
-
-	//Load firmware PIE image
-	reg32_write(0x3c240000, 0x10);
-	reg32_write(0x3c240004, 0x400);
-	reg32_write(0x3c240008, 0x10e);
-	reg32_write(0x3c24000c, 0x0);
-	reg32_write(0x3c240010, 0x0);
-	reg32_write(0x3c240014, 0x8);
-	reg32_write(0x3c2400a4, 0xb);
-	reg32_write(0x3c2400a8, 0x480);
-	reg32_write(0x3c2400ac, 0x109);
-	reg32_write(0x3c2400b0, 0x8);
-	reg32_write(0x3c2400b4, 0x448);
-	reg32_write(0x3c2400b8, 0x139);
-	reg32_write(0x3c2400bc, 0x8);
-	reg32_write(0x3c2400c0, 0x478);
-	reg32_write(0x3c2400c4, 0x109);
-	reg32_write(0x3c2400c8, 0x2);
-	reg32_write(0x3c2400cc, 0x10);
-	reg32_write(0x3c2400d0, 0x139);
-	reg32_write(0x3c2400d4, 0xf);
-	reg32_write(0x3c2400d8, 0x7c0);
-	reg32_write(0x3c2400dc, 0x139);
-	reg32_write(0x3c2400e0, 0x44);
-	reg32_write(0x3c2400e4, 0x630);
-	reg32_write(0x3c2400e8, 0x159);
-	reg32_write(0x3c2400ec, 0x14f);
-	reg32_write(0x3c2400f0, 0x630);
-	reg32_write(0x3c2400f4, 0x159);
-	reg32_write(0x3c2400f8, 0x47);
-	reg32_write(0x3c2400fc, 0x630);
-	reg32_write(0x3c240100, 0x149);
-	reg32_write(0x3c240104, 0x4f);
-	reg32_write(0x3c240108, 0x630);
-	reg32_write(0x3c24010c, 0x179);
-	reg32_write(0x3c240110, 0x8);
-	reg32_write(0x3c240114, 0xe0);
-	reg32_write(0x3c240118, 0x109);
-	reg32_write(0x3c24011c, 0x0);
-	reg32_write(0x3c240120, 0x7c8);
-	reg32_write(0x3c240124, 0x109);
-	reg32_write(0x3c240128, 0x0);
-	reg32_write(0x3c24012c, 0x1);
-	reg32_write(0x3c240130, 0x8);
-	reg32_write(0x3c240134, 0x0);
-	reg32_write(0x3c240138, 0x45a);
-	reg32_write(0x3c24013c, 0x9);
-	reg32_write(0x3c240140, 0x0);
-	reg32_write(0x3c240144, 0x448);
-	reg32_write(0x3c240148, 0x109);
-	reg32_write(0x3c24014c, 0x40);
-	reg32_write(0x3c240150, 0x630);
-	reg32_write(0x3c240154, 0x179);
-	reg32_write(0x3c240158, 0x1);
-	reg32_write(0x3c24015c, 0x618);
-	reg32_write(0x3c240160, 0x109);
-	reg32_write(0x3c240164, 0x40c0);
-	reg32_write(0x3c240168, 0x630);
-	reg32_write(0x3c24016c, 0x149);
-	reg32_write(0x3c240170, 0x8);
-	reg32_write(0x3c240174, 0x4);
-	reg32_write(0x3c240178, 0x48);
-	reg32_write(0x3c24017c, 0x4040);
-	reg32_write(0x3c240180, 0x630);
-	reg32_write(0x3c240184, 0x149);
-	reg32_write(0x3c240188, 0x0);
-	reg32_write(0x3c24018c, 0x4);
-	reg32_write(0x3c240190, 0x48);
-	reg32_write(0x3c240194, 0x40);
-	reg32_write(0x3c240198, 0x630);
-	reg32_write(0x3c24019c, 0x149);
-	reg32_write(0x3c2401a0, 0x10);
-	reg32_write(0x3c2401a4, 0x4);
-	reg32_write(0x3c2401a8, 0x18);
-	reg32_write(0x3c2401ac, 0x0);
-	reg32_write(0x3c2401b0, 0x4);
-	reg32_write(0x3c2401b4, 0x78);
-	reg32_write(0x3c2401b8, 0x549);
-	reg32_write(0x3c2401bc, 0x630);
-	reg32_write(0x3c2401c0, 0x159);
-	reg32_write(0x3c2401c4, 0xd49);
-	reg32_write(0x3c2401c8, 0x630);
-	reg32_write(0x3c2401cc, 0x159);
-	reg32_write(0x3c2401d0, 0x94a);
-	reg32_write(0x3c2401d4, 0x630);
-	reg32_write(0x3c2401d8, 0x159);
-	reg32_write(0x3c2401dc, 0x441);
-	reg32_write(0x3c2401e0, 0x630);
-	reg32_write(0x3c2401e4, 0x149);
-	reg32_write(0x3c2401e8, 0x42);
-	reg32_write(0x3c2401ec, 0x630);
-	reg32_write(0x3c2401f0, 0x149);
-	reg32_write(0x3c2401f4, 0x1);
-	reg32_write(0x3c2401f8, 0x630);
-	reg32_write(0x3c2401fc, 0x149);
-	reg32_write(0x3c240200, 0x0);
-	reg32_write(0x3c240204, 0xe0);
-	reg32_write(0x3c240208, 0x109);
-	reg32_write(0x3c24020c, 0xa);
-	reg32_write(0x3c240210, 0x10);
-	reg32_write(0x3c240214, 0x109);
-	reg32_write(0x3c240218, 0x9);
-	reg32_write(0x3c24021c, 0x3c0);
-	reg32_write(0x3c240220, 0x149);
-	reg32_write(0x3c240224, 0x9);
-	reg32_write(0x3c240228, 0x3c0);
-	reg32_write(0x3c24022c, 0x159);
-	reg32_write(0x3c240230, 0x18);
-	reg32_write(0x3c240234, 0x10);
-	reg32_write(0x3c240238, 0x109);
-	reg32_write(0x3c24023c, 0x0);
-	reg32_write(0x3c240240, 0x3c0);
-	reg32_write(0x3c240244, 0x109);
-	reg32_write(0x3c240248, 0x18);
-	reg32_write(0x3c24024c, 0x4);
-	reg32_write(0x3c240250, 0x48);
-	reg32_write(0x3c240254, 0x18);
-	reg32_write(0x3c240258, 0x4);
-	reg32_write(0x3c24025c, 0x58);
-	reg32_write(0x3c240260, 0xa);
-	reg32_write(0x3c240264, 0x10);
-	reg32_write(0x3c240268, 0x109);
-	reg32_write(0x3c24026c, 0x2);
-	reg32_write(0x3c240270, 0x10);
-	reg32_write(0x3c240274, 0x109);
-	reg32_write(0x3c240278, 0x7);
-	reg32_write(0x3c24027c, 0x7c0);
-	reg32_write(0x3c240280, 0x109);
-	reg32_write(0x3c240284, 0x10);
-	reg32_write(0x3c240288, 0x10);
-	reg32_write(0x3c24028c, 0x109);
-	reg32_write(0x3c240290, 0x0);
-	reg32_write(0x3c240294, 0x8140);
-	reg32_write(0x3c240298, 0x10c);
-	reg32_write(0x3c24029c, 0x10);
-	reg32_write(0x3c2402a0, 0x8138);
-	reg32_write(0x3c2402a4, 0x10c);
-	reg32_write(0x3c2402a8, 0x8);
-	reg32_write(0x3c2402ac, 0x7c8);
-	reg32_write(0x3c2402b0, 0x101);
-	reg32_write(0x3c2402b4, 0x8);
-	reg32_write(0x3c2402b8, 0x0);
-	reg32_write(0x3c2402bc, 0x8);
-	reg32_write(0x3c2402c0, 0x8);
-	reg32_write(0x3c2402c4, 0x448);
-	reg32_write(0x3c2402c8, 0x109);
-	reg32_write(0x3c2402cc, 0xf);
-	reg32_write(0x3c2402d0, 0x7c0);
-	reg32_write(0x3c2402d4, 0x109);
-	reg32_write(0x3c2402d8, 0x47);
-	reg32_write(0x3c2402dc, 0x630);
-	reg32_write(0x3c2402e0, 0x109);
-	reg32_write(0x3c2402e4, 0x8);
-	reg32_write(0x3c2402e8, 0x618);
-	reg32_write(0x3c2402ec, 0x109);
-	reg32_write(0x3c2402f0, 0x8);
-	reg32_write(0x3c2402f4, 0xe0);
-	reg32_write(0x3c2402f8, 0x109);
-	reg32_write(0x3c2402fc, 0x0);
-	reg32_write(0x3c240300, 0x7c8);
-	reg32_write(0x3c240304, 0x109);
-	reg32_write(0x3c240308, 0x8);
-	reg32_write(0x3c24030c, 0x8140);
-	reg32_write(0x3c240310, 0x10c);
-	reg32_write(0x3c240314, 0x0);
-	reg32_write(0x3c240318, 0x1);
-	reg32_write(0x3c24031c, 0x8);
-	reg32_write(0x3c240320, 0x8);
-	reg32_write(0x3c240324, 0x4);
-	reg32_write(0x3c240328, 0x8);
-	reg32_write(0x3c24032c, 0x8);
-	reg32_write(0x3c240330, 0x7c8);
-	reg32_write(0x3c240334, 0x101);
-	reg32_write(0x3c240018, 0x0);
-	reg32_write(0x3c24001c, 0x0);
-	reg32_write(0x3c240020, 0x8);
-	reg32_write(0x3c240024, 0x0);
-	reg32_write(0x3c240028, 0x0);
-	reg32_write(0x3c24002c, 0x0);
-	reg32_write(0x3c34039c, 0x400);
-	reg32_write(0x3c24005c, 0x0);
-	reg32_write(0x3c240098, 0x2c);
-	reg32_write(0x3c08002c, 0x32);
-	reg32_write(0x3c080030, 0x64);
-	reg32_write(0x3c080034, 0x3e8);
-	reg32_write(0x3c080038, 0x2c);
-	reg32_write(0x3c240030, 0x0);
-	reg32_write(0x3c240034, 0x173);
-	reg32_write(0x3c240038, 0x60);
-	reg32_write(0x3c24003c, 0x6110);
-	reg32_write(0x3c240040, 0x2152);
-	reg32_write(0x3c240044, 0xdfbd);
-	reg32_write(0x3c240048, 0xffff);
-	reg32_write(0x3c24004c, 0x6152);
-	reg32_write(0x3c300200, 0x00000000);
-	/*
-	 * CalBusy.0 == 1, indicates the calibrator is actively calibrating.
-	 * Wait Calibrating done.
-	 */
-	do {
-		tmp = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x20097);
-		calbusy = tmp & 0x01;
-	} while (calbusy);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x0);
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x2006e, 0x0);
-	//disable APB bus to access DDRPHY RAM
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x1);
-}
diff --git a/board/karo/tx8mm/ddr/helper.c b/board/karo/tx8mm/ddr/helper.c
deleted file mode 100644
index a63be80..0000000
--- a/board/karo/tx8mm/ddr/helper.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <spl.h>
-#include <asm/io.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/ddr.h>
-#include <asm/sections.h>
-
-#include "ddr.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#define IMEM_LEN 32768
-#define DMEM_LEN 16384
-#define IMEM_2D_OFFSET	49152
-
-#define IMEM_OFFSET_ADDR 0x00050000
-#define DMEM_OFFSET_ADDR 0x00054000
-#define DDR_TRAIN_CODE_BASE_ADDR IP2APB_DDRPHY_IPS_BASE_ADDR(0)
-
-/* We need PHY iMEM PHY is 32KB padded */
-void ddr_load_train_code(enum fw_type type)
-{
-	u32 tmp32, i;
-	u32 error = 0;
-	unsigned long pr_to32, pr_from32;
-	unsigned long fw_offset = type ? IMEM_2D_OFFSET : 0;
-	unsigned long imem_start = (unsigned long)&_end + fw_offset;
-	unsigned long dmem_start = imem_start + IMEM_LEN;
-
-	pr_from32 = imem_start;
-	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * IMEM_OFFSET_ADDR;
-	for (i = 0x0; i < IMEM_LEN; ) {
-		tmp32 = readl(pr_from32);
-		writew(tmp32 & 0x0000ffff, pr_to32);
-		pr_to32 += 4;
-		writew((tmp32 >> 16) & 0x0000ffff, pr_to32);
-		pr_to32 += 4;
-		pr_from32 += 4;
-		i += 4;
-	}
-
-	pr_from32 = dmem_start;
-	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * DMEM_OFFSET_ADDR;
-	for (i = 0x0; i < DMEM_LEN;) {
-		tmp32 = readl(pr_from32);
-		writew(tmp32 & 0x0000ffff, pr_to32);
-		pr_to32 += 4;
-		writew((tmp32 >> 16) & 0x0000ffff, pr_to32);
-		pr_to32 += 4;
-		pr_from32 += 4;
-		i += 4;
-	}
-
-	debug("check ddr_train_imem code\n");
-	pr_from32 = imem_start;
-	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * IMEM_OFFSET_ADDR;
-	for (i = 0x0; i < IMEM_LEN;) {
-		tmp32 = (readw(pr_to32) & 0x0000ffff);
-		pr_to32 += 4;
-		tmp32 += ((readw(pr_to32) & 0x0000ffff) << 16);
-
-		if (tmp32 != readl(pr_from32)) {
-			printf("%lx %lx\n", pr_from32, pr_to32);
-			error++;
-		}
-		pr_from32 += 4;
-		pr_to32 += 4;
-		i += 4;
-	}
-	if (error)
-		printf("check ddr_train_imem code fail=%d\n", error);
-	else
-		debug("check ddr_train_imem code pass\n");
-
-	debug("check ddr_train_dmem code\n");
-	pr_from32 = dmem_start;
-	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * DMEM_OFFSET_ADDR;
-	for (i = 0x0; i < DMEM_LEN;) {
-		tmp32 = (readw(pr_to32) & 0x0000ffff);
-		pr_to32 += 4;
-		tmp32 += ((readw(pr_to32) & 0x0000ffff) << 16);
-		if (tmp32 != readl(pr_from32)) {
-			printf("%lx %lx\n", pr_from32, pr_to32);
-			error++;
-		}
-		pr_from32 += 4;
-		pr_to32 += 4;
-		i += 4;
-	}
-
-	if (error)
-		printf("check ddr_train_dmem code fail=%d", error);
-	else
-		debug("check ddr_train_dmem code pass\n");
-}
diff --git a/board/karo/tx8mm/ddr/wait_ddrphy_training_complete.c b/board/karo/tx8mm/ddr/wait_ddrphy_training_complete.c
deleted file mode 100644
index 8b1febe..0000000
--- a/board/karo/tx8mm/ddr/wait_ddrphy_training_complete.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright 2017 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-#include <common.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/ddr.h>
-#include <asm/arch/clock.h>
-#include "ddr.h"
-
-static inline void poll_pmu_message_ready(void)
-{
-	unsigned int reg;
-
-	do {
-		reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0004);
-	} while (reg & 0x1);
-}
-
-static inline void ack_pmu_message_recieve(void)
-{
-	unsigned int reg;
-
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0031, 0x0);
-
-	do {
-		reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0004);
-	} while (!(reg & 0x1));
-
-	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0031, 0x1);
-}
-
-static inline unsigned int get_mail(void)
-{
-	unsigned int reg;
-
-	poll_pmu_message_ready();
-
-	reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0032);
-
-	ack_pmu_message_recieve();
-
-	return reg;
-}
-
-static inline unsigned int get_stream_message(void)
-{
-	unsigned int reg, reg2;
-
-	poll_pmu_message_ready();
-
-	reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0032);
-	reg2 = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0034);
-	reg2 = (reg2 << 16) | reg;
-
-	ack_pmu_message_recieve();
-
-	return reg2;
-}
-
-static inline void decode_major_message(unsigned int mail)
-{
-	ddr_dbg("[PMU Major message = 0x%08x]\n", mail);
-}
-
-static inline void decode_streaming_message(void)
-{
-	unsigned int string_index, arg __maybe_unused;
-	int i = 0;
-
-	string_index = get_stream_message();
-	ddr_dbg("	PMU String index = 0x%08x\n", string_index);
-	while (i < (string_index & 0xffff)) {
-		arg = get_stream_message();
-		ddr_dbg("	arg[%d] = 0x%08x\n", i, arg);
-		i++;
-	}
-
-	ddr_dbg("\n");
-}
-
-void wait_ddrphy_training_complete(void)
-{
-	unsigned int mail;
-
-	while (1) {
-		mail = get_mail();
-		decode_major_message(mail);
-		if (mail == 0x08) {
-			decode_streaming_message();
-		} else if (mail == 0x07) {
-			debug("DDR training PASS\n");
-			break;
-		} else if (mail == 0xff) {
-			printf("DDR training FAILED\n");
-			break;
-		}
-	}
-}
diff --git a/board/karo/tx8mm/spl.c b/board/karo/tx8mm/spl.c
deleted file mode 100644
index 2394d0f..0000000
--- a/board/karo/tx8mm/spl.c
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <errno.h>
-#include <fsl_esdhc.h>
-#include <spl.h>
-#include <mmc.h>
-#include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/imx8mm_pins.h>
-#include <asm/arch/sys_proto.h>
-#include <asm/mach-imx/gpio.h>
-#include <asm/mach-imx/iomux-v3.h>
-#include <asm/mach-imx/mxc_i2c.h>
-#include <power/pmic.h>
-#include <power/bd71837.h>
-#include "ddr/ddr.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void spl_dram_init(void)
-{
-	ddr_init();
-}
-
-#define I2C_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
-					     PAD_CTL_HYS |	\
-					     PAD_CTL_PUE |	\
-					     PAD_CTL_DSE6)
-
-struct i2c_pads_info i2c_pad_info1 = {
-	.scl = {
-		.i2c_mode = IMX8MM_PAD_I2C1_SCL_I2C1_SCL | I2C_PAD_CTRL,
-		.gpio_mode = IMX8MM_PAD_I2C1_SCL_GPIO5_IO14 | I2C_PAD_CTRL,
-		.gp = IMX_GPIO_NR(5, 14),
-	},
-	.sda = {
-		.i2c_mode = IMX8MM_PAD_I2C1_SDA_I2C1_SDA | I2C_PAD_CTRL,
-		.gpio_mode = IMX8MM_PAD_I2C1_SDA_GPIO5_IO15 | I2C_PAD_CTRL,
-		.gp = IMX_GPIO_NR(5, 15),
-	},
-};
-
-#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
-					     PAD_CTL_PUE |	\
-					     PAD_CTL_FSEL2 |	\
-					     PAD_CTL_DSE6)
-
-#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
-					     PAD_CTL_HYS |	\
-					     PAD_CTL_PUE |	\
-					     PAD_CTL_DSE6)
-
-static const iomux_v3_cfg_t tx8mm_usdhc1_pads[] = {
-	IMX8MM_PAD_SD1_CLK_USDHC1_CLK | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_CMD_USDHC1_CMD | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA0_USDHC1_DATA0 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA1_USDHC1_DATA1 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA2_USDHC1_DATA2 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA3_USDHC1_DATA3 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA4_USDHC1_DATA4 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA5_USDHC1_DATA5 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA6_USDHC1_DATA6 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA7_USDHC1_DATA7 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_STROBE_USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
-	IMX8MM_PAD_SD1_RESET_B_USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
-};
-
-static const iomux_v3_cfg_t tx8mm_usdhc2_pads[] = {
-	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_CD_B_GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
-};
-
-static const iomux_v3_cfg_t tx8mm_usdhc3_pads[] = {
-	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA02_GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
-};
-
-static struct tx8m_esdhc_cfg {
-	struct fsl_esdhc_cfg cfg;
-	int clk;
-	const iomux_v3_cfg_t *pads;
-	size_t num_pads;
-	int cd_gpio;
-} tx8mm_sdhc_cfgs[] = {
-	{
-		.cfg = {
-			.esdhc_base = USDHC1_BASE_ADDR,
-			.max_bus_width = 8,
-		},
-		.clk = MXC_ESDHC_CLK,
-		.pads = tx8mm_usdhc1_pads,
-		.num_pads = ARRAY_SIZE(tx8mm_usdhc1_pads),
-		.cd_gpio = -EINVAL,
-	},
-	{
-		.cfg = {
-			.esdhc_base = USDHC2_BASE_ADDR,
-			.max_bus_width = 4,
-		},
-		.clk = MXC_ESDHC2_CLK,
-		.pads = tx8mm_usdhc2_pads,
-		.num_pads = ARRAY_SIZE(tx8mm_usdhc2_pads),
-		.cd_gpio = IMX_GPIO_NR(2, 12),
-	},
-	{
-		.cfg = {
-			.esdhc_base = USDHC3_BASE_ADDR,
-			.max_bus_width = 4,
-		},
-		.clk = MXC_ESDHC3_CLK,
-		.pads = tx8mm_usdhc3_pads,
-		.num_pads = ARRAY_SIZE(tx8mm_usdhc3_pads),
-		.cd_gpio = IMX_GPIO_NR(3, 8),
-	},
-};
-
-int board_mmc_init(bd_t *bis)
-{
-	int ret;
-	/*
-	 * According to the board_mmc_init() the following map is done:
-	 * (U-Boot device node)    (Physical Port)
-	 * mmc0                    USDHC1 (eMMC)
-	 * mmc1                    USDHC2
-	 * mmc2                    USDHC3
-	 */
-
-	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
-		struct mmc *mmc;
-		struct tx8m_esdhc_cfg *cfg;
-
-		if (i >= ARRAY_SIZE(tx8mm_sdhc_cfgs)) {
-			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
-			       CONFIG_SYS_FSL_USDHC_NUM,
-			       ARRAY_SIZE(tx8mm_sdhc_cfgs));
-			return -EINVAL;
-		}
-
-		cfg = &tx8mm_sdhc_cfgs[i];
-		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
-		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
-
-		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
-		if (ret) {
-			printf("Failed to initialize MMC%zu: %d\n", i, ret);
-			continue;
-		}
-
-		mmc = find_mmc_device(i);
-		if (mmc == NULL) {
-			printf("mmc device %zi not found\n", i);
-			continue;
-		}
-		if (board_mmc_getcd(mmc)) {
-			ret = mmc_init(mmc);
-			if (ret) {
-				printf("mmc_init(mmc%zi) failed: %d\n", i, ret);
-			}
-		} else {
-			debug("No Medium found in MMC slot %zi\n", i);
-		}
-	}
-	return 0;
-}
-
-static inline struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
-{
-	for (size_t i = 0; i < ARRAY_SIZE(tx8mm_sdhc_cfgs); i++) {
-		struct tx8m_esdhc_cfg *cfg = &tx8mm_sdhc_cfgs[i];
-
-		if (priv->esdhc_base == cfg->cfg.esdhc_base)
-			return cfg;
-	}
-	return NULL;
-}
-
-int board_mmc_getcd(struct mmc *mmc)
-{
-	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
-
-	if (cfg == NULL) {
-		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
-		return 0;
-	}
-	if (cfg->cd_gpio < 0)
-		return 1;
-
-	return !gpio_get_value(cfg->cd_gpio);
-}
-
-#ifdef CONFIG_POWER
-#define I2C_PMIC	0
-int power_init_board(void)
-{
-	struct pmic *p;
-	int ret;
-
-	ret = power_bd71837_init(I2C_PMIC);
-	if (ret)
-		printf("power init failed");
-
-	p = pmic_get("BD71837");
-	pmic_probe(p);
-
-	/* decrease RESET key long push time from the default 10s to 10ms */
-	pmic_reg_write(p, BD71837_PWRONCONFIG1, 0x0);
-
-	/* unlock the PMIC regs */
-	pmic_reg_write(p, BD71837_REGLOCK, 0x1);
-
-	/* increase VDD_DRAM to 0.9v for 3Ghz DDR */
-	pmic_reg_write(p, BD71837_BUCK5_VOLT, 0x2);
-
-	/* increase NVCC_DRAM_1V35 to 1.35v for DDR3L */
-	pmic_reg_write(p, BD71837_BUCK8_VOLT, 0x37);
-
-	/* lock the PMIC regs */
-	pmic_reg_write(p, BD71837_REGLOCK, 0x11);
-
-	return 0;
-}
-#endif
-
-void spl_board_init(void)
-{
-	if (!IS_ENABLED(CONFIG_SPL_DISABLE_BANNER_PRINT))
-		puts("Normal Boot\n");
-}
-
-#ifdef CONFIG_SPL_LOAD_FIT
-int board_fit_config_name_match(const char *name)
-{
-	debug("%s: %s\n", __func__, name);
-
-	return 0;
-}
-#endif
-
-#define UART_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL0 |	\
-					     PAD_CTL_DSE6)
-
-static const iomux_v3_cfg_t uart_pads[] = {
-	IMX8MM_PAD_UART1_RXD_UART1_RX | UART_PAD_CTRL,
-	IMX8MM_PAD_UART1_TXD_UART1_TX | UART_PAD_CTRL,
-};
-
-static int tx8m_spl_iomux_setup(void)
-{
-	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
-debug("%s@%d:\n", __func__, __LINE__);
-
-	return 0;
-}
-
-void board_init_f(ulong dummy)
-{
-	int ret;
-
-	/* Clear global data */
-	memset((void *)gd, 0, sizeof(gd_t));
-
-	arch_cpu_init();
-
-	tx8m_spl_iomux_setup();
-
-	timer_init();
-
-	preloader_console_init();
-
-	/* Clear the BSS. */
-	memset(__bss_start, 0, __bss_end - __bss_start);
-
-	ret = spl_init();
-	if (ret) {
-		debug("spl_init() failed: %d\n", ret);
-		hang();
-	}
-
-	enable_tzc380();
-
-#if !IS_ENABLED(CONFIG_DM_I2C)
-	/* Adjust pmic voltage to 1.0V for 800M */
-	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
-#endif
-	power_init_board();
-
-	/* DDR initialization */
-	spl_dram_init();
-
-	board_init_r(NULL, 0);
-}
diff --git a/board/karo/tx8mm/tx8mm.c b/board/karo/tx8mm/tx8mm.c
deleted file mode 100644
index 7ced087..0000000
--- a/board/karo/tx8mm/tx8mm.c
+++ /dev/null
@@ -1,833 +0,0 @@
-/*
- * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <console.h>
-#include <errno.h>
-#include <fsl_esdhc.h>
-#include <fsl_wdog.h>
-#include <imx_mipi_dsi_bridge.h>
-#include <led.h>
-#include <malloc.h>
-#include <miiphy.h>
-#include <mipi_dsi_panel.h>
-#include <mmc.h>
-#include <netdev.h>
-#include <sec_mipi_dsim.h>
-#include <spl.h>
-#include <thermal.h>
-#include <asm-generic/gpio.h>
-#include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/imx8mm_pins.h>
-#include <asm/arch/sys_proto.h>
-#include <asm/armv8/mmu.h>
-#include <asm/mach-imx/dma.h>
-#include <asm/mach-imx/gpio.h>
-#include <asm/mach-imx/iomux-v3.h>
-#include <asm/mach-imx/mxc_i2c.h>
-#include <asm/mach-imx/video.h>
-#include <dm/uclass.h>
-#include <power/pmic.h>
-#include <power/bd71837.h>
-#include "../common/karo.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#if !CONFIG_IS_ENABLED(DM_MMC)
-#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
-					     PAD_CTL_PUE |	\
-					     PAD_CTL_FSEL2 |	\
-					     PAD_CTL_DSE6)
-
-#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
-					     PAD_CTL_HYS |	\
-					     PAD_CTL_PUE |	\
-					     PAD_CTL_DSE6)
-
-static const iomux_v3_cfg_t tx8mm_usdhc1_pads[] = {
-	IMX8MM_PAD_SD1_CLK_USDHC1_CLK | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_CMD_USDHC1_CMD | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA0_USDHC1_DATA0 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA1_USDHC1_DATA1 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA2_USDHC1_DATA2 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA3_USDHC1_DATA3 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA4_USDHC1_DATA4 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA5_USDHC1_DATA5 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA6_USDHC1_DATA6 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA7_USDHC1_DATA7 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_STROBE_USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
-	IMX8MM_PAD_SD1_RESET_B_USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
-};
-
-static const iomux_v3_cfg_t tx8mm_usdhc2_pads[] = {
-	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_CD_B_GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
-};
-
-static const iomux_v3_cfg_t tx8mm_usdhc3_pads[] = {
-	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA02_GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
-};
-
-static struct tx8m_esdhc_cfg {
-	struct fsl_esdhc_cfg cfg;
-	int clk;
-	const iomux_v3_cfg_t *pads;
-	size_t num_pads;
-	int cd_gpio;
-} tx8mm_sdhc_cfgs[] = {
-	{
-		.cfg = {
-			.esdhc_base = USDHC1_BASE_ADDR,
-			.max_bus_width = 8,
-		},
-		.clk = MXC_ESDHC_CLK,
-		.pads = tx8mm_usdhc1_pads,
-		.num_pads = ARRAY_SIZE(tx8mm_usdhc1_pads),
-		.cd_gpio = -EINVAL,
-	},
-	{
-		.cfg = {
-			.esdhc_base = USDHC2_BASE_ADDR,
-			.max_bus_width = 4,
-		},
-		.clk = MXC_ESDHC2_CLK,
-		.pads = tx8mm_usdhc2_pads,
-		.num_pads = ARRAY_SIZE(tx8mm_usdhc2_pads),
-		.cd_gpio = IMX_GPIO_NR(2, 12),
-	},
-	{
-		.cfg = {
-			.esdhc_base = USDHC3_BASE_ADDR,
-			.max_bus_width = 4,
-		},
-		.clk = MXC_ESDHC3_CLK,
-		.pads = tx8mm_usdhc3_pads,
-		.num_pads = ARRAY_SIZE(tx8mm_usdhc3_pads),
-		.cd_gpio = IMX_GPIO_NR(3, 8),
-	},
-};
-
-static inline struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
-{
-	for (size_t i = 0; i < ARRAY_SIZE(tx8mm_sdhc_cfgs); i++) {
-		struct tx8m_esdhc_cfg *cfg = &tx8mm_sdhc_cfgs[i];
-
-		if (priv->esdhc_base == cfg->cfg.esdhc_base)
-			return cfg;
-	}
-	return NULL;
-}
-
-int board_mmc_getcd(struct mmc *mmc)
-{
-	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
-
-	if (cfg == NULL) {
-		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
-		return 0;
-	}
-	if (cfg->cd_gpio < 0) {
-		debug("%s@%d: 1\n", __func__, __LINE__);
-		return 1;
-	}
-	debug("%s@%d: %d\n", __func__, __LINE__,
-	      !gpio_get_value(cfg->cd_gpio));
-	return !gpio_get_value(cfg->cd_gpio);
-}
-
-int board_mmc_init(bd_t *bis)
-{
-	int ret;
-	/*
-	 * According to the board_mmc_init() the following map is done:
-	 * (U-Boot device node)    (Physical Port)
-	 * mmc0                    USDHC1 (eMMC)
-	 * mmc1                    USDHC2
-	 * mmc2                    USDHC3
-	 */
-
-	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
-		struct mmc *mmc;
-		struct tx8m_esdhc_cfg *cfg;
-
-		if (i >= ARRAY_SIZE(tx8mm_sdhc_cfgs)) {
-			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
-			       CONFIG_SYS_FSL_USDHC_NUM,
-			       ARRAY_SIZE(tx8mm_sdhc_cfgs));
-			return -EINVAL;
-		}
-
-		cfg = &tx8mm_sdhc_cfgs[i];
-		if (cfg->cd_gpio >= 0) {
-			gpio_request(cfg->cd_gpio, "MMC CD");
-			gpio_direction_input(cfg->cd_gpio);
-		}
-		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
-		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
-
-		debug("%s@%d: Initialising MMC dev %zu @ %08llx clock=%u\n", __func__, __LINE__,
-		      i, cfg->cfg.esdhc_base, cfg->cfg.sdhc_clk);
-		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
-		if (ret) {
-			printf("Failed to initialize MMC%zu: %d\n", i, ret);
-			continue;
-		}
-
-		mmc = find_mmc_device(i);
-		if (mmc == NULL) {
-			printf("mmc device %zi not found\n", i);
-			continue;
-		}
-		if (board_mmc_getcd(mmc)) {
-			ret = mmc_init(mmc);
-			if (ret)
-				printf("mmc_init(mmc%zi) failed: %d\n", i, ret);
-		} else {
-			debug("No Medium found in MMC slot %zi\n", i);
-		}
-	}
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_OF_BOARD_SETUP
-#include <asm/setup.h>
-#include <asm/bootm.h>
-
-int ft_board_setup(void *blob, bd_t *bd)
-{
-	struct tag_serialnr serno;
-	char serno_str[64 / 4 + 1];
-
-	get_board_serial(&serno);
-	snprintf(serno_str, sizeof(serno_str), "%08x%08x",
-		 serno.high, serno.low);
-
-	printf("serial-number: %s\n", serno_str);
-
-	fdt_setprop(blob, 0, "serial-number", serno_str, strlen(serno_str));
-	fsl_fdt_fixup_dr_usb(blob, bd);
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_FEC_MXC
-#define MDIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_DSE6 |	\
-					     PAD_CTL_PE |	\
-					     PAD_CTL_PUE)
-
-#define FEC_IN_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL2)
-
-#define FEC_OUT_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_FSEL2 |	\
-					     PAD_CTL_DSE6)
-
-static const iomux_v3_cfg_t tx8mm_fec_pads[] = {
-	IMX8MM_PAD_ENET_MDC_ENET1_MDC | MDIO_PAD_CTRL, /* 0x146 */
-	IMX8MM_PAD_ENET_MDIO_ENET1_MDIO | MDIO_PAD_CTRL,
-	IMX8MM_PAD_ENET_TD2_ENET1_TX_CLK | MUX_MODE_SION | FEC_IN_PAD_CTRL, /* 0x40000016 */
-	IMX8MM_PAD_ENET_TD0_ENET1_RGMII_TD0 | FEC_OUT_PAD_CTRL, /* 0x16 */
-	IMX8MM_PAD_ENET_TD1_ENET1_RGMII_TD1 | FEC_OUT_PAD_CTRL, /* 0x16 */
-	IMX8MM_PAD_ENET_RD0_ENET1_RGMII_RD0 | FEC_IN_PAD_CTRL, /* 0x90 */
-	IMX8MM_PAD_ENET_RD1_ENET1_RGMII_RD1 | FEC_IN_PAD_CTRL, /* 0x90 */
-	IMX8MM_PAD_ENET_RXC_ENET1_RX_ER | FEC_IN_PAD_CTRL, /* 0x90 */
-	IMX8MM_PAD_ENET_RX_CTL_ENET1_RGMII_RX_CTL | FEC_IN_PAD_CTRL, /* 0x90 */
-	IMX8MM_PAD_ENET_TX_CTL_ENET1_RGMII_TX_CTL | FEC_OUT_PAD_CTRL, /* 0x16 */
-};
-
-static int tx8mm_etnphy_init(void)
-{
-	int ret;
-	struct gpio_desc enet0_pwr;
-	struct gpio_desc enet0_rst;
-
-	ret = dm_gpio_lookup_name("gpio1_23", &enet0_pwr);
-	if (ret) {
-		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
-		return ret;
-	}
-
-	ret = dm_gpio_lookup_name("gpio1_29", &enet0_rst);
-	if (ret) {
-		printf("Failed to lookup ENET0_RST GPIO: %d\n", ret);
-		return ret;
-	}
-
-	ret = dm_gpio_request(&enet0_pwr, "ENET0_PWR");
-	if (ret) {
-		printf("Failed to request ENET0_PWR GPIO: %d\n", ret);
-		return ret;
-	}
-
-	ret = dm_gpio_request(&enet0_rst, "ENET0_RST");
-	if (ret) {
-		printf("Failed to request ENET0_RST GPIO: %d\n", ret);
-		return ret;
-	}
-
-	dm_gpio_set_dir_flags(&enet0_rst, GPIOD_IS_OUT);
-	dm_gpio_set_dir_flags(&enet0_pwr, GPIOD_IS_OUT);
-	dm_gpio_set_value(&enet0_rst, 0);
-	dm_gpio_set_value(&enet0_pwr, 1);
-
-	imx_iomux_v3_setup_multiple_pads(tx8mm_fec_pads,
-					 ARRAY_SIZE(tx8mm_fec_pads));
-
-	mdelay(25);
-	dm_gpio_set_value(&enet0_rst, 1);
-	mdelay(10);
-	return 0;
-}
-
-static int tx8mm_setup_fec(void)
-{
-	struct iomuxc_gpr_base_regs *iomuxc_gpr_regs =
-		(void *)IOMUXC_GPR_BASE_ADDR;
-	unsigned char mac[6];
-
-	set_clk_enet(ENET_50MHZ);
-
-	/* Use 50M anatop REF_CLK1 for ENET1, not from external */
-	setbits_le32(&iomuxc_gpr_regs->gpr[1],
-		     IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK);
-
-	imx_get_mac_from_fuse(0, mac);
-	printf("MAC addr: %pM\n", mac);
-
-	return tx8mm_etnphy_init();
-}
-
-int board_phy_config(struct phy_device *phydev)
-{
-	if (phydev->drv->config)
-		phydev->drv->config(phydev);
-
-	return 0;
-}
-#else
-static inline int tx8mm_setup_fec(void)
-{
-	return 0;
-}
-#endif
-
-int dram_init(void)
-{
-	/* rom_pointer[1] contains the size of RAM occupied by TEE */
-	if (rom_pointer[1])
-		gd->ram_size = PHYS_SDRAM_SIZE - ALIGN(rom_pointer[1], PAGE_SIZE);
-	else
-		gd->ram_size = PHYS_SDRAM_SIZE;
-
-	return 0;
-}
-
-int board_fix_fdt(void *blob)
-{
-	return 0;
-}
-
-#define GPIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
-					     PAD_CTL_PUE |	\
-					     PAD_CTL_DSE6)
-
-static const iomux_v3_cfg_t tx8mm_gpio_pads[] = {
-	IMX8MM_PAD_SD2_RESET_B_GPIO2_IO19 | GPIO_PAD_CTRL,
-};
-
-#ifdef CONFIG_SHOW_ACTIVITY
-enum {
-	LED_STATE_INIT = -1,
-	LED_STATE_OFF,
-	LED_STATE_ON,
-	LED_STATE_DISABLED,
-};
-
-static int led_state = LED_STATE_DISABLED;
-static bool tx8m_temp_check_enabled = true;
-static struct udevice *leddev;
-static struct udevice *thermaldev;
-
-#define TEMPERATURE_HOT		80
-#define TEMPERATURE_MIN		-40
-
-static inline int calc_blink_rate(void)
-{
-	int cpu_temp;
-	static int last_temp = INT_MAX;
-	static int avg_count;
-
-	if (!tx8m_temp_check_enabled)
-		return CONFIG_SYS_HZ;
-
-	if (!thermaldev || thermal_get_temp(thermaldev, &cpu_temp))
-		return CONFIG_SYS_HZ / 2;
-
-	if (last_temp == INT_MAX) {
-		last_temp = cpu_temp;
-	} else if (cpu_temp != last_temp) {
-		static int cpu_temps[4];
-
-		if (thermal_get_temp(thermaldev, &cpu_temps[avg_count]))
-			return CONFIG_SYS_HZ / 2;
-		if (++avg_count >= ARRAY_SIZE(cpu_temps)) {
-			int bad = -1;
-			int i;
-
-			for (i = 0; i < avg_count; i++) {
-				if (cpu_temp != cpu_temps[i])
-					bad = i;
-			}
-			if (bad < 0) {
-				debug("CPU temperature changed from %d to %d\n",
-				      last_temp, cpu_temp);
-				last_temp = cpu_temp;
-			} else {
-				debug("Spurious CPU temperature reading %d -> %d -> %d\n",
-				      cpu_temp, cpu_temps[bad], cpu_temps[i - 1]);
-			}
-			avg_count = 0;
-		}
-	} else {
-		avg_count = 0;
-	}
-	return CONFIG_SYS_HZ + CONFIG_SYS_HZ / 10 -
-		(last_temp - TEMPERATURE_MIN) * CONFIG_SYS_HZ /
-		(TEMPERATURE_HOT - TEMPERATURE_MIN);
-}
-
-void show_activity(int arg)
-{
-	static int blink_rate;
-	static ulong last;
-	int ret;
-
-	if (led_state == LED_STATE_DISABLED)
-		return;
-
-	if (led_state == LED_STATE_INIT) {
-		last = get_timer(0);
-		ret = led_set_state(leddev, LEDST_ON);
-		if (ret == 0)
-			led_state = LED_STATE_ON;
-		else
-			led_state = LED_STATE_DISABLED;
-		blink_rate = calc_blink_rate();
-	} else {
-		if (get_timer(last) > blink_rate) {
-			blink_rate = calc_blink_rate();
-			last = get_timer(0);
-			if (led_state == LED_STATE_ON) {
-				ret = led_set_state(leddev, LEDST_OFF);
-			} else {
-				ret = led_set_state(leddev, LEDST_ON);
-			}
-			if (ret == 0)
-				led_state = 1 - led_state;
-			else
-				led_state = LED_STATE_DISABLED;
-		}
-	}
-
-}
-
-static void tx8m_led_init(void)
-{
-	int ret;
-
-	ret = led_get_by_label("Heartbeat", &leddev);
-	if (ret) {
-		printf("Failed to find LED device: %d\n", ret);
-		return;
-	}
-
-	ret = uclass_get_device_by_name(UCLASS_THERMAL, "cpu-thermal",
-					&thermaldev);
-	if (ret)
-		printf("Failed to find THERMAL device: %d\n", ret);
-
-	led_state = LED_STATE_INIT;
-}
-#else
-static inline void tx8m_led_init(void)
-{
-printf("%s@%d: \n", __func__, __LINE__);
-}
-#endif
-
-int checkboard(void)
-{
-	printf("Board: Ka-Ro TX8M-1610\n");
-	return 0;
-}
-
-int board_init(void)
-{
-	int ret;
-	struct gpio_desc reset_out;
-
-	tx8mm_setup_fec();
-
-	ret = dm_gpio_lookup_name("gpio2_19", &reset_out);
-	if (ret) {
-		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
-		return ret;
-	}
-	ret = dm_gpio_request(&reset_out, "RESET_OUT");
-	if (ret) {
-		printf("Failed to request RESET_OUT GPIO: %d\n", ret);
-		return ret;
-	}
-
-	imx_iomux_v3_setup_multiple_pads(tx8mm_gpio_pads,
-					 ARRAY_SIZE(tx8mm_gpio_pads));
-	tx8m_led_init();
-	return ret;
-}
-
-#ifdef CONFIG_BOARD_EARLY_INIT_R
-int board_early_init_r(void)
-{
-	return 0;
-}
-#endif
-
-int board_late_init(void)
-{
-	int ret;
-	struct src *src_regs = (void *)SRC_BASE_ADDR;
-	struct watchdog_regs *wdog = (void *)WDOG1_BASE_ADDR;
-	u32 srsr = readl(&src_regs->srsr);
-	u16 wrsr = readw(&wdog->wrsr);
-	const char *fdt_file = env_get("fdt_file");
-
-	karo_env_cleanup();
-	if (srsr & 0x10 && !(wrsr & WRSR_SFTW))
-		env_set("wdreset", "1");
-	if (had_ctrlc())
-		env_set("safeboot", "1");
-	if (fdt_file) {
-		ret = karo_load_fdt(fdt_file);
-		if (ret)
-			printf("Failed to load FDT from '%s': %d\n",
-			       fdt_file, ret);
-	}
-	return 0;
-}
-
-int mmc_map_to_kernel_blk(int devno)
-{
-	return devno + 1;
-}
-
-void board_quiesce_devices(void)
-{
-}
-
-#ifdef CONFIG_VIDEO
-static const struct sec_mipi_dsim_plat_data imx8mm_mipi_dsim_plat_data = {
-	.version	= 0x1060200,
-	.max_data_lanes = 4,
-	.max_data_rate  = 1500000000ULL,
-	.reg_base = MIPI_DSI_BASE_ADDR,
-	.gpr_base = CSI_BASE_ADDR + 0x8000,
-};
-
-#define DSI_DDR_MODE 0
-
-struct mipi_dsi_client_dev dsi83_dev = {
-	.channel = 0,
-	.lanes = 4,
-	.format = MIPI_DSI_FMT_RGB888,
-	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
-	.name = "DSI83",
-};
-
-#define DISPLAY_MIX_SFT_RSTN_CSR	0x00
-#define DISPLAY_MIX_CLK_EN_CSR		0x04
-
-   /* 'DISP_MIX_SFT_RSTN_CSR' bit fields */
-#define BUS_RSTN_BLK_SYNC_SFT_EN	BIT(6)
-
-   /* 'DISP_MIX_CLK_EN_CSR' bit fields */
-#define LCDIF_PIXEL_CLK_SFT_EN		BIT(7)
-#define LCDIF_APB_CLK_SFT_EN		BIT(6)
-
-static void disp_mix_bus_rstn_reset(ulong gpr_base, bool reset)
-{
-	if (!reset)
-		/* release reset */
-		setbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
-			     BUS_RSTN_BLK_SYNC_SFT_EN);
-	else
-		/* hold reset */
-		clrbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
-			     BUS_RSTN_BLK_SYNC_SFT_EN);
-}
-
-static void disp_mix_lcdif_clks_enable(ulong gpr_base, bool enable)
-{
-	if (enable)
-		/* enable lcdif clks */
-		setbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
-			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
-	else
-		/* disable lcdif clks */
-		clrbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
-			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
-}
-
-#define LINE_LENGTH	1280
-#define H_FRONT_PORCH	64
-#define H_BACK_PORCH	4
-#define HSYNC_LEN	1
-#define VERT_SIZE	800
-#define V_FRONT_PORCH	40
-#define V_BACK_PORCH	1
-#define VSYNC_LEN	1
-#define VREFRESH	60
-
-#define BPP	24
-#define SYNC_DELAY	64
-#define HTOTAL		(HSYNC_LEN + H_BACK_PORCH + LINE_LENGTH + H_FRONT_PORCH)
-#define VTOTAL		(VSYNC_LEN + V_BACK_PORCH + VERT_SIZE + V_FRONT_PORCH)
-#define PCLK		(HTOTAL * VTOTAL * VREFRESH)
-#define DSI_CLK		(PCLK * BPP / 4 / (!!DSI_DDR_MODE + 1))
-#define DSI_CLK_DIV	((DSI_CLK + PCLK - 1) / PCLK)
-#define LVDS_CLK	(DSI_CLK / DSI_CLK_DIV)
-#define LVDS_CLK_DIV	((LVDS_CLK + 12500000) / 25000000 - 1)
-
-static struct dsi83_data {
-	u8 addr;
-	u8 val;
-	u8 mask;
-} dsi83_data[] = {
-	{ 0x09, 1, },
-	{ 0x0d, 0x00, 0x01, },
-	{ 0x10, 0x00, 0x18, }, // DSI lanes 0x00: 4 lanes; 0x08: 3 lanes
-	{ 0x10, 0x00, 0x01, }, // SOT_ERR_TOL_DIS
-	{ 0x11, 0xc0, 0xc0, }, // DSI DATA equalization
-	{ 0x11, 0x0c, 0x0c, }, // DSI clock equalization
-	{ 0x12, DSI_CLK / 1000000 / 5, }, // DSI clk range 8: 40..45MHz; 9: 45..50MHz; ...
-	{ 0x0a, 0x01, 0x01, },
-	{ 0x0a, LVDS_CLK_DIV << 1, 0x0e, },
-	{ 0x0b, 0x00, 0x03, },
-	{ 0x0b, (DSI_CLK_DIV - 1) << 3, 0x7c, },
-	{ 0x18, 0x60, 0xe0, }, // DE_NEG HS_NEG VS_NEG
-	{ 0x18, 0x08, 0x9, }, // CHA_24BPP_MODE CHA24BPP_FORMAT1
-	{ 0x20, LINE_LENGTH % 256, },
-	{ 0x21, LINE_LENGTH / 256, },
-	{ 0x24, VERT_SIZE % 256, },
-	{ 0x25, VERT_SIZE / 256, },
-	{ 0x28, SYNC_DELAY % 256, },
-	{ 0x29, SYNC_DELAY / 256, },
-	{ 0x2c, HSYNC_LEN % 256, },
-	{ 0x2d, HSYNC_LEN / 256, },
-	{ 0x30, VSYNC_LEN % 256, },
-	{ 0x31, VSYNC_LEN / 256, },
-	{ 0x34, H_BACK_PORCH + HSYNC_LEN, },
-	{ 0x36, V_BACK_PORCH + VSYNC_LEN, },
-	{ 0x38, H_FRONT_PORCH, },
-	{ 0x3a, V_FRONT_PORCH, },
-	//{ 0x3c, 0x10, 0x10, }, // enable CHA_TEST_PATTERN
-	{ 0x3c, 0x00, },
-	{ 0x0d, 0x01, 0x01, }, // enable PLL
-	{ 0xe5, 0xfd, 0xfd, }, // clear error status
-};
-
-#define DSI83_SLAVE_ADDR	0x2c
-
-static int dsi83_init(void)
-{
-	int ret;
-	struct udevice *dev;
-	struct udevice *chip;
-	u8 val;
-
-	debug("DSI clock: %u.%03uMHz dsi_clk_div=%u\n",
-	      DSI_CLK / 1000000, DSI_CLK / 1000 % 1000, DSI_CLK_DIV);
-	debug("LVDS clock: %u.%03uMHz lvds_clk_range=%u\n",
-	      LVDS_CLK / 1000000, LVDS_CLK / 1000 % 1000, LVDS_CLK_DIV);
-
-	ret = uclass_get_device_by_seq(UCLASS_I2C, 1, &dev);
-	if (ret) {
-		printf("%s: Failed to find I2C bus device: %d\n",
-		       __func__, ret);
-		return ret;
-	}
-	ret = dm_i2c_probe(dev, DSI83_SLAVE_ADDR, 0x0, &chip);
-	if (ret) {
-		printf("%s: I2C probe failed for slave addr %02x: %d\n",
-		       __func__, DSI83_SLAVE_ADDR, ret);
-		return ret;
-	}
-	for (size_t i = 0; i < ARRAY_SIZE(dsi83_data); i++) {
-		struct dsi83_data *p = &dsi83_data[i];
-
-		ret = dm_i2c_read(chip, p->addr, &val, 1);
-		if (ret) {
-			printf("%s: Failed to read reg %02x\n",
-			       __func__, p->val);
-			return ret;
-		}
-		debug("%s@%d: Read %02x from reg %02x\n",
-		      __func__, __LINE__, val, p->addr);
-		val = (val & ~p->mask) | p->val;
-		debug("%s@%d: Writing %02x to reg %02x\n",
-		      __func__, __LINE__, val, p->addr);
-		ret = dm_i2c_write(chip, p->addr, &val, 1);
-		if (ret) {
-			printf("%s: Failed to write %02x to reg %02x\n",
-			       __func__, p->val, p->addr);
-			return ret;
-		}
-	}
-	return 0;
-}
-
-static const iomux_v3_cfg_t tx8mm_lcd_pads[] = {
-	IMX8MM_PAD_GPIO1_IO01_GPIO1_IO1 | GPIO_PAD_CTRL,
-	IMX8MM_PAD_GPIO1_IO04_GPIO1_IO4 | GPIO_PAD_CTRL,
-};
-
-static void tx8m_backlight_enable(void)
-{
-	int ret;
-	struct gpio_desc backlight_control;
-	struct gpio_desc lcd_enable;
-
-	ret = dm_gpio_lookup_name("gpio1_1", &backlight_control);
-	if (ret == 0) {
-		ret = dm_gpio_request(&backlight_control, "BACKLIGHT_CONTROL");
-		if (ret == 0) {
-			dm_gpio_set_dir_flags(&backlight_control, GPIOD_IS_OUT);
-			dm_gpio_set_value(&backlight_control, 1);
-		} else {
-			printf("Failed to request BACKLIGHT_CONTROL GPIO: %d\n",
-			       ret);
-		}
-	} else {
-		printf("Failed to lookup BACKLIGHT_CONTROL GPIO: %d\n", ret);
-	}
-
-	ret = dm_gpio_lookup_name("gpio1_4", &lcd_enable);
-	if (ret == 0) {
-		ret = dm_gpio_request(&lcd_enable, "LCD_ENABLE");
-		if (ret == 0) {
-			dm_gpio_set_dir_flags(&lcd_enable, GPIOD_IS_OUT);
-			dm_gpio_set_value(&lcd_enable, 1);
-		} else {
-			printf("Failed to request LCD_ENABLE GPIO: %d\n", ret);
-		}
-	} else {
-		printf("Failed to lookup LCD_ENABLE GPIO: %d\n", ret);
-	}
-
-	imx_iomux_v3_setup_multiple_pads(tx8mm_lcd_pads,
-					 ARRAY_SIZE(tx8mm_lcd_pads));
-}
-
-#define FSL_SIP_GPC			0xC2000000
-#define FSL_SIP_CONFIG_GPC_PM_DOMAIN	0x3
-#define DISPMIX				9
-#define MIPI				10
-
-static void do_enable_mipi2lvds(struct display_info_t const *disp)
-{
-	/* enable the dispmix & mipi phy power domain */
-	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
-		     DISPMIX, true, 0);
-	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
-		     MIPI, true, 0);
-
-	/* Get lcdif out of reset */
-	disp_mix_bus_rstn_reset(imx8mm_mipi_dsim_plat_data.gpr_base, false);
-	disp_mix_lcdif_clks_enable(imx8mm_mipi_dsim_plat_data.gpr_base, true);
-
-	sec_mipi_dsim_setup(&imx8mm_mipi_dsim_plat_data);
-	imx_mipi_dsi_bridge_attach(&dsi83_dev);
-	dsi83_init();
-	tx8m_backlight_enable();
-}
-
-static struct display_info_t const panel_info[] = {
-	{
-		.bus = LCDIF_BASE_ADDR,
-		.pixfmt = BPP,
-		.enable	= do_enable_mipi2lvds,
-		.mode	= {
-			.name		= "MIPI2LVDS",
-			.refresh	= VREFRESH,
-			.xres		= LINE_LENGTH,
-			.yres		= VERT_SIZE,
-			.pixclock	= KHZ2PICOS(PCLK / 1000),
-			.left_margin	= H_BACK_PORCH,
-			.hsync_len	= HSYNC_LEN,
-			.right_margin	= H_FRONT_PORCH,
-			.upper_margin	= V_BACK_PORCH,
-			.vsync_len	= VSYNC_LEN,
-			.lower_margin	= V_FRONT_PORCH,
-			.sync		= FB_SYNC_EXT,
-			.vmode		= FB_VMODE_NONINTERLACED,
-		},
-	},
-};
-
-int board_video_skip(void)
-{
-	int ret;
-	const char *baseboard = env_get("baseboard");
-	const char *panel = env_get("panel");
-	size_t i;
-
-	if (had_ctrlc()) {
-		printf("<CTRL-C> detected; disabling display\n");
-		return 1;
-	}
-
-	if (!panel) {
-		printf("No LCD panel configured\n");
-		return 1;
-	}
-
-	if (!baseboard || strcmp(baseboard, "mipi-mb") != 0) {
-		printf("No Display support for '%s' baseboard\n",
-		       baseboard ?: "unspecified");
-		return 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(panel_info); i++) {
-		const struct display_info_t *pi = &panel_info[i];
-
-		if (strcmp(panel, pi->mode.name) != 0)
-			continue;
-
-		ret = mxs_lcd_panel_setup(pi->mode,
-					  pi->pixfmt,
-					  pi->bus);
-		if (ret)
-			return ret;
-
-		if (pi->enable)
-			pi->enable(panel_info + i);
-
-		printf("Display: %s (%ux%u)\n", pi->mode.name,
-		       pi->mode.xres, pi->mode.yres);
-	}
-	return ret;
-}
-#endif
diff --git a/include/configs/tx8m.h b/include/configs/tx8m.h
new file mode 100644
index 0000000..faa5065
--- /dev/null
+++ b/include/configs/tx8m.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __IMX8MM_EVK_H
+#define __IMX8MM_EVK_H
+
+#include <linux/sizes.h>
+#include <asm/arch/imx-regs.h>
+
+#ifdef CONFIG_SECURE_BOOT
+#define CONFIG_CSF_SIZE			SZ_8K
+#endif
+
+#define CONFIG_SPL_MAX_SIZE		(148 * 1024)
+#define CONFIG_SYS_MONITOR_LEN		SZ_1M
+#define CONFIG_SYS_MMCSD_FS_BOOT_PARTITION	0x1
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_ENABLE_DDR_TRAINING_DEBUG
+#define CONFIG_USBD_HS
+#if defined(CONFIG_IMX8MM)
+#define CONFIG_SPL_BSS_START_ADDR	0x00910000
+#if 0
+#define CONFIG_SYS_SPL_MALLOC_START	0x42200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	SZ_512K
+#endif
+#define CONFIG_SYS_SPL_MALLOC_START	0x00911000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	SZ_64K
+#define CONFIG_MALLOC_F_ADDR		0x00912000 /* malloc f used before GD_FLG_FULL_MALLOC_INIT set */
+#elif defined(CONFIG_IMX8MN)
+#define CONFIG_SPL_BSS_START_ADDR	0x00950000
+#define CONFIG_SYS_SPL_MALLOC_START	0x00940000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	SZ_64K
+#define CONFIG_SPL_STACK		0x95fff0
+#define CONFIG_MALLOC_F_ADDR		0x00940000 /* malloc f used before GD_FLG_FULL_MALLOC_INIT set */
+#else
+#error Unsupported SOC type
+#endif
+
+#define CONFIG_SPL_BSS_MAX_SIZE		SZ_8K
+#define CONFIG_SPL_LOAD_FIT_ADDRESS	0
+
+#define CONFIG_SPL_ABORT_ON_RAW_IMAGE /* For RAW image gives an error info not panic */
+
+#if defined(CONFIG_KARO_TX8MM) || defined(CONFIG_KARO_TX8MN)
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_BD71837
+#endif
+
+#ifndef CONFIG_DM_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		400000
+#endif
+
+#if CONFIG_IS_ENABLED(USB_SUPPORT)
+#define CONFIG_SYS_USB_FAT_BOOT_PARTITION  1
+#define CONFIG_SPL_FS_LOAD_PAYLOAD_NAME "u-boot"
+#endif
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#endif /* CONFIG_SPL_BUILD */
+#define CONFIG_SYS_INIT_SP_ADDR		0x00920000
+
+#define CONFIG_SERIAL_TAG
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_BOARD_EARLY_INIT_R
+#ifdef CONFIG_LED
+#define CONFIG_SHOW_ACTIVITY
+#endif
+
+/* ENET Config */
+#ifdef CONFIG_FEC_MXC
+#define IMX_FEC_BASE			0x30BE0000
+#define CONFIG_FEC_MXC_PHYADDR		0
+#define CONFIG_FEC_XCV_TYPE		RMII
+#endif
+
+#define __pfx(p,v)			(p##v)
+#define _pfx(p,v)			__pfx(p, v)
+
+#define CONFIG_FDTADDR			43000000
+#define FDTADDR_STR			__stringify(CONFIG_FDTADDR)
+
+/* Initial environment variables */
+#ifndef CONFIG_TX8M_UBOOT_MFG
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"append_bootargs=clk_ignore_unused debug\0"			\
+	"baseboard=mipi-mb\0"						\
+	"board=imx8mm-tx8m-1610\0"					\
+	"boot_mode=mmc\0"						\
+	"bootargs_mmc=run default_bootargs;"				\
+	" setenv bootargs ${bootargs} root=PARTUUID=${uuid_rootfs}"	\
+	" ${append_bootargs}\0"						\
+	"bootargs_nfs=run default_bootargs;"				\
+	" setenv bootargs root=/dev/nfs"				\
+	" nfsroot=${nfs_server}:${nfsroot},nolock ${append_bootargs}\0"	\
+	"bootcmd=run bootcmd_${boot_mode} bootm_cmd\0"			\
+	"bootcmd_mmc=run loadkernel bootargs_mmc\0"			\
+	"bootcmd_nfs=run loadkernel bootargs_nfs\0"			\
+	"bootm_cmd=booti ${loadaddr} ${initrd_addr} ${fdt_addr}\0"	\
+	"console=ttymxc0,115200 earlycon=ec_imx6q,0x30860000,115200\0"	\
+	"default_bootargs=setenv bootargs init=/linuxrc"		\
+	" console=${console} panic=-1 ro\0"				\
+	"emmc_boot_ack=1\0"						\
+	"emmc_boot_part=1\0"						\
+	"fdt_addr=" FDTADDR_STR "\0"					\
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0"			\
+	"fdt_high=63000000\0"						\
+	"fdtsave=save mmc ${mmcdev} ${fdt_addr} ${fdt_file}"		\
+	" ${fdt_size}\0"						\
+	"initrd_addr=-\0"						\
+	"initrd_high=63800000\0"					\
+	"linux_image=Image-tx8m-1610.bin\0"				\
+	"loadfdt=if test \"${baseboard}\" != \"\";then"			\
+	" fdtfile=${board}-${baseboard}.dtb;else"			\
+	" fdtfile=${board}.dtb;fi;fdt rm /"				\
+	";load mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdtfile}\0"	\
+	"loadkernel=load mmc ${mmcdev}:${mmcpart} ${loadaddr}"		\
+	" ${linux_image}\0"						\
+	"mmcdev=0\0"							\
+	"mmcpart=1\0"							\
+	"panel=MIPI2LVDS\0"						\
+	"uuid_rootfs=0cc66cc0-5458-384d-1610-726f6f746673\0"
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"bootcmd=fastboot 0\0"						\
+	"emmc_boot_ack=1\0"						\
+	"emmc_boot_part=1\0"						\
+	"fastboot_dev=mmc\0"						\
+	"mmcdev=0\0"
+#endif
+
+/* Link Definitions */
+#define CONFIG_LOADADDR			40480000
+
+#define CONFIG_SYS_LOAD_ADDR		_pfx(0x,CONFIG_LOADADDR)
+
+#define CONFIG_ENV_OVERWRITE
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(2048 * 512 - CONFIG_ENV_SIZE)
+#else
+#error "No supported Environment location defined"
+#endif
+#define CONFIG_ENV_SIZE			0x1000
+#define CONFIG_SYS_MMC_ENV_DEV		0
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		((CONFIG_ENV_SIZE + SZ_2K + SZ_16K) * SZ_1K)
+
+#define CONFIG_SYS_SDRAM_BASE		0x40000000
+#define PHYS_SDRAM			0x40000000
+#if defined(CONFIG_KARO_TX8MM)
+#define PHYS_SDRAM_SIZE			SZ_1G
+#elif defined(CONFIG_KARO_TX8MN)
+#define PHYS_SDRAM_SIZE			SZ_1G
+#elif defined(CONFIG_KARO_QS8M)
+#define PHYS_SDRAM_SIZE			SZ_512M
+#else
+#error Unsupported Board type
+#endif
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + (PHYS_SDRAM_SIZE >> 1))
+
+#define CONFIG_MXC_UART_BASE		UART1_BASE_ADDR
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		2048
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* USDHC */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#define CONFIG_SUPPORT_EMMC_BOOT	/* eMMC specific */
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+#ifdef CONFIG_USB_EHCI_MX7
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+#endif
diff --git a/include/configs/tx8mm.h b/include/configs/tx8mm.h
deleted file mode 100644
index 4ef5680..0000000
--- a/include/configs/tx8mm.h
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __IMX8MM_EVK_H
-#define __IMX8MM_EVK_H
-
-#include <linux/sizes.h>
-#include <asm/arch/imx-regs.h>
-
-#ifdef CONFIG_SECURE_BOOT
-#define CONFIG_CSF_SIZE			SZ_8K
-#endif
-
-#define CONFIG_SPL_MAX_SIZE		(148 * 1024)
-#define CONFIG_SYS_MONITOR_LEN		SZ_1M
-#define CONFIG_SYS_MMCSD_FS_BOOT_PARTITION	0x1
-
-#ifdef CONFIG_SPL_BUILD
-#define CONFIG_ENABLE_DDR_TRAINING_DEBUG
-#define CONFIG_USBD_HS
-#define CONFIG_SPL_BSS_START_ADDR	0x00910000
-#define CONFIG_SPL_BSS_MAX_SIZE		SZ_8K
-#define CONFIG_SYS_SPL_MALLOC_START	0x42200000
-#define CONFIG_SYS_SPL_MALLOC_SIZE	SZ_512K
-#define CONFIG_SPL_LOAD_FIT_ADDRESS	0
-
-#define CONFIG_MALLOC_F_ADDR		0x00912000 /* malloc f used before GD_FLG_FULL_MALLOC_INIT set */
-
-#define CONFIG_SPL_ABORT_ON_RAW_IMAGE /* For RAW image gives an error info not panic */
-
-#define CONFIG_POWER
-#define CONFIG_POWER_I2C
-#define CONFIG_POWER_BD71837
-
-#ifndef CONFIG_DM_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC_I2C1
-#endif
-
-#if CONFIG_IS_ENABLED(USB_SUPPORT)
-#define CONFIG_SYS_USB_FAT_BOOT_PARTITION  1
-#define CONFIG_SPL_FS_LOAD_PAYLOAD_NAME "u-boot"
-#endif
-
-#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
-#endif /* CONFIG_SPL_BUILD */
-#define CONFIG_SYS_INIT_SP_ADDR		0x00920000
-
-#define CONFIG_SERIAL_TAG
-
-#define CONFIG_REMAKE_ELF
-
-#define CONFIG_BOARD_EARLY_INIT_R
-#ifdef CONFIG_LED
-#define CONFIG_SHOW_ACTIVITY
-#endif
-
-/* ENET Config */
-#ifdef CONFIG_FEC_MXC
-#define IMX_FEC_BASE			0x30BE0000
-#define CONFIG_FEC_MXC_PHYADDR		0
-#define CONFIG_FEC_XCV_TYPE		RMII
-#endif
-
-#define __pfx(p,v)			(p##v)
-#define _pfx(p,v)			__pfx(p, v)
-
-#define CONFIG_FDTADDR			43000000
-#define FDTADDR_STR			__stringify(CONFIG_FDTADDR)
-
-/* Initial environment variables */
-#ifndef CONFIG_TX8MM_UBOOT_MFG
-#define CONFIG_EXTRA_ENV_SETTINGS					\
-	"append_bootargs=clk_ignore_unused debug\0"			\
-	"baseboard=mipi-mb\0"						\
-	"board=imx8mm-tx8m-1610\0"					\
-	"boot_mode=mmc\0"						\
-	"bootargs_mmc=run default_bootargs;"				\
-	" setenv bootargs ${bootargs} root=PARTUUID=${uuid_rootfs}"	\
-	" ${append_bootargs}\0"						\
-	"bootargs_nfs=run default_bootargs;"				\
-	" setenv bootargs root=/dev/nfs"				\
-	" nfsroot=${nfs_server}:${nfsroot},nolock ${append_bootargs}\0"	\
-	"bootcmd=run bootcmd_${boot_mode} bootm_cmd\0"			\
-	"bootcmd_mmc=run loadkernel bootargs_mmc\0"			\
-	"bootcmd_nfs=run loadkernel bootargs_nfs\0"			\
-	"bootm_cmd=booti ${loadaddr} ${initrd_addr} ${fdt_addr}\0"	\
-	"console=ttymxc0,115200 earlycon=ec_imx6q,0x30860000,115200\0"	\
-	"default_bootargs=setenv bootargs init=/linuxrc"		\
-	" console=${console} panic=-1 ro\0"				\
-	"emmc_boot_ack=1\0"						\
-	"emmc_boot_part=1\0"						\
-	"fdt_addr=" FDTADDR_STR "\0"					\
-	"fdt_file=Image-" CONFIG_DEFAULT_FDT_FILE "\0"			\
-	"fdt_high=63000000\0"						\
-	"fdtsave=save mmc ${mmcdev} ${fdt_addr} ${fdt_file}"		\
-	" ${fdt_size}\0"						\
-	"initrd_addr=-\0"						\
-	"initrd_high=63800000\0"					\
-	"linux_image=Image-tx8m-1610.bin\0"				\
-	"loadfdt=if test \"${baseboard}\" != \"\";then"			\
-	" fdtfile=Image-${board}-${baseboard}.dtb;else"			\
-	" fdtfile=Image-${board}.dtb;fi"				\
-	";load mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdtfile}\0"	\
-	"loadkernel=load mmc ${mmcdev}:${mmcpart} ${loadaddr}"		\
-	" ${linux_image}\0"						\
-	"mmcdev=0\0"							\
-	"mmcpart=1\0"							\
-	"panel=MIPI2LVDS\0"						\
-	"uuid_rootfs=0cc66cc0-5458-384d-1610-726f6f746673\0"
-#else
-#define CONFIG_EXTRA_ENV_SETTINGS					\
-	"bootcmd=fastboot 0\0"						\
-	"emmc_boot_ack=1\0"						\
-	"emmc_boot_part=1\0"						\
-	"fastboot_dev=mmc\0"						\
-	"mmcdev=0\0"
-#endif
-
-/* Link Definitions */
-#define CONFIG_LOADADDR			40480000
-
-#define CONFIG_SYS_LOAD_ADDR		_pfx(0x,CONFIG_LOADADDR)
-
-#define CONFIG_ENV_OVERWRITE
-#if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(2048 * 512 - CONFIG_ENV_SIZE)
-#else
-#error "No supported Environment location defined"
-#endif
-#define CONFIG_ENV_SIZE			0x1000
-#define CONFIG_SYS_MMC_ENV_DEV		0
-
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		((CONFIG_ENV_SIZE + SZ_2K + SZ_16K) * SZ_1K)
-
-#define CONFIG_SYS_SDRAM_BASE		0x40000000
-#define PHYS_SDRAM			0x40000000
-#define PHYS_SDRAM_SIZE			SZ_1G
-#define CONFIG_NR_DRAM_BANKS		1
-
-#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM
-#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + (PHYS_SDRAM_SIZE >> 1))
-
-#define CONFIG_MXC_UART_BASE		UART1_BASE_ADDR
-
-/* Monitor Command Prompt */
-#define CONFIG_SYS_CBSIZE		2048
-#define CONFIG_SYS_MAXARGS		256
-#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
-#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-
-/* USDHC */
-#define CONFIG_FSL_ESDHC
-#define CONFIG_FSL_USDHC
-
-#define CONFIG_SYS_FSL_USDHC_NUM	3
-#define CONFIG_SYS_FSL_ESDHC_ADDR	0
-
-#define CONFIG_SUPPORT_EMMC_BOOT	/* eMMC specific */
-#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
-
-#ifndef CONFIG_DM_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
-#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
-#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
-#define CONFIG_SYS_I2C_SPEED		400000
-#endif
-
-#ifdef CONFIG_USB_EHCI_MX7
-#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
-#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
-#endif
-
-#ifdef CONFIG_VIDEO
-#define CONFIG_VIDEO_MXS
-#define CONFIG_VIDEO_LOGO
-#define CONFIG_SPLASH_SCREEN
-#define CONFIG_SPLASH_SCREEN_ALIGN
-#define CONFIG_BMP_16BPP
-#define CONFIG_VIDEO_BMP_RLE8
-#define CONFIG_VIDEO_BMP_LOGO
-#endif
-
-#endif
-- 
2.7.4

