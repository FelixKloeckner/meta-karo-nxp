From b71e3252c2a984acb3f9fd9408ddd207cede1521 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lothar=20Wa=C3=9Fmann?= <LW@KARO-electronics.de>
Date: Tue, 26 Nov 2019 09:23:26 +0100
Subject: [PATCH 32/39] karo: tx8m: add i.MX8MNano support

---
 arch/arm/dts/imx8mn-tx8m-nd00-u-boot.dtsi |  12 +
 arch/arm/dts/imx8mn-tx8m-nd00.dts         | 595 +++++++++++++++++++
 board/karo/tx8m/Makefile                  |   4 +-
 board/karo/tx8m/spl.c                     |   2 +-
 board/karo/tx8m/tx8m.c                    | 887 ----------------------------
 board/karo/tx8m/tx8mm.c                   | 923 ++++++++++++++++++++++++++++++
 board/karo/tx8m/tx8mn.c                   | 918 +++++++++++++++++++++++++++++
 configs/tx8m-1610_defconfig               |   2 +-
 configs/tx8m-1610_mfg_defconfig           |   5 +-
 configs/tx8m-1610_noenv_defconfig         |   4 +-
 configs/tx8m-nd00_defconfig               | 107 ++++
 configs/tx8m-nd00_mfg_defconfig           | 110 ++++
 configs/tx8m-nd00_noenv_defconfig         | 102 ++++
 include/configs/tx8m.h                    |   2 +-
 14 files changed, 2777 insertions(+), 896 deletions(-)
 create mode 100644 arch/arm/dts/imx8mn-tx8m-nd00-u-boot.dtsi
 create mode 100644 arch/arm/dts/imx8mn-tx8m-nd00.dts
 delete mode 100644 board/karo/tx8m/tx8m.c
 create mode 100644 board/karo/tx8m/tx8mm.c
 create mode 100644 board/karo/tx8m/tx8mn.c
 create mode 100644 configs/tx8m-nd00_defconfig
 create mode 100644 configs/tx8m-nd00_mfg_defconfig
 create mode 100644 configs/tx8m-nd00_noenv_defconfig

diff --git a/arch/arm/dts/imx8mn-tx8m-nd00-u-boot.dtsi b/arch/arm/dts/imx8mn-tx8m-nd00-u-boot.dtsi
new file mode 100644
index 0000000..a8fb490
--- /dev/null
+++ b/arch/arm/dts/imx8mn-tx8m-nd00-u-boot.dtsi
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ */
+#include "config.h"
+
+/ {
+	config {
+		u-boot,mmc-env-offset = <CONFIG_ENV_OFFSET>;
+	};
+};
diff --git a/arch/arm/dts/imx8mn-tx8m-nd00.dts b/arch/arm/dts/imx8mn-tx8m-nd00.dts
new file mode 100644
index 0000000..29ac862
--- /dev/null
+++ b/arch/arm/dts/imx8mn-tx8m-nd00.dts
@@ -0,0 +1,595 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ */
+
+/dts-v1/;
+
+#include "fsl-imx8mn.dtsi"
+
+/ {
+	model = "Ka-Ro electronics TX8M-ND00 (NXP i.MX8MN) board";
+	compatible = "karo,imx8mn-tx8m", "fsl,imx8mn";
+
+	aliases {
+		usb-host = &usbotg2;
+		usbotg = &usbotg1;
+		i2c0 = &i2c1;
+		i2c1 = &i2c2;
+		i2c2 = &i2c3;
+	};
+
+	chosen {
+		bootargs = "console=ttymxc0,115200 earlycon=ec_imx6q,0x30860000,115200";
+		stdout-path = &uart1;
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		audio_clk: clock@0 {
+			compatible = "fixed-clock";
+			reg = <0>;
+			#clock-cells = <0>;
+			clock-frequency = <26000000>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led {
+			label = "Heartbeat";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_led>;
+			gpios = <&gpio1 2 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0x40000000>;
+	};
+
+	owire {
+		compatible = "w1-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_owire>;
+		gpios = <&gpio3 25 GPIO_ACTIVE_HIGH>;
+		linux,open-drain;
+	};
+
+	reg_3v3: regulator-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		power-supply = <&buck6_reg>;
+	};
+
+	reg_3v3_etn: regulator-3v3-etn {
+		compatible = "regulator-fixed";
+		regulator-name = "3V3_ETN";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_etnphy_power>;
+		gpio = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		power-supply = <&reg_3v3>;
+	};
+};
+
+&A53_0 {
+	arm-supply = <&buck2_reg>;
+};
+
+&i2c1 {
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	pinctrl-1 = <&pinctrl_i2c1_gpio>;
+	clock-frequency = <400000>;
+	scl-gpios = <&gpio5 14 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&gpio5 15 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	pmic: bd71837@4b {
+		reg = <0x4b>;
+		compatible = "rohm,bd71837";
+		/* PMIC BD71837 PMIC_nINT GPIO1_IO3 */
+		pinctrl-0 = <&pinctrl_pmic>;
+		gpio_intr = <&gpio1 3 GPIO_ACTIVE_LOW>;
+
+		gpo {
+			rohm,drv = <0x0C>;	/* 0b0000_1100 all gpios with CMOS output mode */
+		};
+
+		regulators {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			bd71837,pmic-buck2-uses-i2c-dvs;
+			bd71837,pmic-buck2-dvs-voltage = <1000000>, <900000>, <0>; /* VDD_ARM: Run-Idle */
+
+			buck1_reg: regulator@0 {
+				reg = <0>;
+				regulator-compatible = "buck1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <1250>;
+			};
+
+			buck2_reg: regulator@1 {
+				reg = <1>;
+				regulator-compatible = "buck2";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <1250>;
+			};
+
+			buck3_reg: regulator@2 {
+				reg = <2>;
+				regulator-compatible = "buck3";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+			};
+
+			buck4_reg: regulator@3 {
+				reg = <3>;
+				regulator-compatible = "buck4";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+			};
+
+			buck5_reg: regulator@4 {
+				reg = <4>;
+				regulator-compatible = "buck5";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6_reg: regulator@5 {
+				reg = <5>;
+				regulator-compatible = "buck6";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck7_reg: regulator@6 {
+				reg = <6>;
+				regulator-compatible = "buck7";
+				regulator-min-microvolt = <1605000>;
+				regulator-max-microvolt = <1995000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck8_reg: regulator@7 {
+				reg = <7>;
+				regulator-compatible = "buck8";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1_reg: regulator@8 {
+				reg = <8>;
+				regulator-compatible = "ldo1";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2_reg: regulator@9 {
+				reg = <9>;
+				regulator-compatible = "ldo2";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3_reg: regulator@10 {
+				reg = <10>;
+				regulator-compatible = "ldo3";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4_reg: regulator@11 {
+				reg = <11>;
+				regulator-compatible = "ldo4";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5_reg: regulator@12 {
+				reg = <12>;
+				regulator-compatible = "ldo5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6_reg: regulator@13 {
+				reg = <13>;
+				regulator-compatible = "ldo6";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo7_reg: regulator@14 {
+				reg = <14>;
+				regulator-compatible = "ldo7";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+};
+
+&i2c3 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+};
+
+&fec1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_fec1 &pinctrl_etnphy_rst>;
+	pinctrl-1 = <&pinctrl_fec1_sleep>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	phy-supply = <&reg_3v3_etn>;
+	phy-reset-gpios = <&gpio1 29 GPIO_ACTIVE_LOW>;
+	phy-reset-duration = <10>;
+	assigned-clock-parents = <&clk IMX8MM_SYS_PLL1_266M>,
+				 <&clk IMX8MM_SYS_PLL2_100M>,
+				 <&clk IMX8MM_SYS_PLL2_50M>;
+	assigned-clock-rates = <0>, <0>, <50000000>, <100000000>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_etnphy_int>;
+			interrupt-parent = <&gpio1>;
+			interrupts = <28 IRQ_TYPE_EDGE_FALLING>;
+			smsc,disable-energy-detect;
+		};
+	};
+};
+
+&uart1 { /* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1 &pinctrl_uart1_rtscts>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2 &pinctrl_uart2_rtscts>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3 &pinctrl_uart3_rtscts>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+&usbotg1 {
+	status = "okay";
+};
+
+&usdhc1 { /* eMMC */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2 &pinctrl_usdhc2_cd>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz &pinctrl_usdhc2_cd>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz &pinctrl_usdhc2_cd>;
+	bus-width = <4>;
+	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>;
+	no-1-8-v;
+	fsl,wp-controller;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3 &pinctrl_usdhc3_cd>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz &pinctrl_usdhc3_cd>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz &pinctrl_usdhc3_cd>;
+	bus-width = <4>;
+	cd-gpios = <&gpio3 8 GPIO_ACTIVE_LOW>;
+	no-1-8-v;
+	fsl,wp-controller;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl_etnphy_int: etnphy-intgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ENET_RD2__GPIO1_IO28		0x90
+		>;
+	};
+
+	pinctrl_etnphy_power: etnphy-powergrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ENET_TXC__GPIO1_IO23		0x142
+		>;
+	};
+
+	pinctrl_etnphy_rst: etnphy-rstgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ENET_RD3__GPIO1_IO29		0x140
+		>;
+	};
+
+	pinctrl_fec1: fec1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ENET_MDC__ENET1_MDC		0x142
+			MX8MN_IOMUXC_ENET_MDIO__ENET1_MDIO		0x142
+			MX8MN_IOMUXC_ENET_TD2__ENET1_TX_CLK		0x40000016
+			MX8MN_IOMUXC_ENET_TD0__ENET1_RGMII_TD0		0x16
+			MX8MN_IOMUXC_ENET_TD1__ENET1_RGMII_TD1		0x16
+			MX8MN_IOMUXC_ENET_RD0__ENET1_RGMII_RD0		0x90
+			MX8MN_IOMUXC_ENET_RD1__ENET1_RGMII_RD1		0x90
+			MX8MN_IOMUXC_ENET_RXC__ENET1_RX_ER		0x16
+			MX8MN_IOMUXC_ENET_RX_CTL__ENET1_RGMII_RX_CTL	0x16
+			MX8MN_IOMUXC_ENET_TX_CTL__ENET1_RGMII_TX_CTL	0x16
+		>;
+	};
+
+	pinctrl_fec1_sleep: fec1-sleepgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ENET_MDC__ENET1_MDC		0x120
+			MX8MN_IOMUXC_ENET_MDIO__ENET1_MDIO		0x120
+			MX8MN_IOMUXC_ENET_TD2__ENET1_TX_CLK		0x40000120
+			MX8MN_IOMUXC_ENET_TD0__ENET1_RGMII_TD0		0x120
+			MX8MN_IOMUXC_ENET_TD1__ENET1_RGMII_TD1		0x120
+			MX8MN_IOMUXC_ENET_RD0__ENET1_RGMII_RD0		0x120
+			MX8MN_IOMUXC_ENET_RD1__ENET1_RGMII_RD1		0x120
+			MX8MN_IOMUXC_ENET_RXC__ENET1_RX_ER		0x120
+			MX8MN_IOMUXC_ENET_RX_CTL__ENET1_RGMII_RX_CTL	0x120
+			MX8MN_IOMUXC_ENET_TX_CTL__ENET1_RGMII_TX_CTL	0x120
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C1_SCL__I2C1_SCL			0x400001c2
+			MX8MN_IOMUXC_I2C1_SDA__I2C1_SDA			0x400001c2
+		>;
+	};
+
+	pinctrl_i2c1_gpio: i2c1-gpiogrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C1_SCL__GPIO5_IO14		0x400001c2
+			MX8MN_IOMUXC_I2C1_SDA__GPIO5_IO15		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C2_SCL__I2C2_SCL			0x400001c2
+			MX8MN_IOMUXC_I2C2_SDA__I2C2_SDA			0x400001c2
+		>;
+	};
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C3_SCL__I2C3_SCL			0x400001c2
+			MX8MN_IOMUXC_I2C3_SDA__I2C3_SDA			0x400001c2
+		>;
+	};
+
+	pinctrl_i2c4: i2c4grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C4_SCL__I2C4_SCL			0x400001c2
+			MX8MN_IOMUXC_I2C4_SDA__I2C4_SDA			0x400001c2
+		>;
+	};
+
+	pinctrl_led: ledgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_GPIO1_IO02__GPIO1_IO2		0x06
+		>;
+	};
+
+	pinctrl_owire: owiregrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SAI5_MCLK__GPIO3_IO25		0x400001c0
+		>;
+	};
+
+	pinctrl_pmic: pmicgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_GPIO1_IO03__GPIO1_IO3		0x1c0
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_UART1_RXD__UART1_DCE_RX		0x140
+			MX8MN_IOMUXC_UART1_TXD__UART1_DCE_TX		0x140
+		>;
+	};
+
+	pinctrl_uart1_rtscts: uart1-rtsctsgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_UART3_TXD__UART1_DCE_RTS_B		0x140
+			MX8MN_IOMUXC_UART3_RXD__UART1_DCE_CTS_B		0x140
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_UART2_RXD__UART2_DCE_RX		0x140
+			MX8MN_IOMUXC_UART2_TXD__UART2_DCE_TX		0x140
+		>;
+	};
+
+	pinctrl_uart2_rtscts: uart2-rtsctsgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_UART4_TXD__UART2_DCE_RTS_B		0x140
+			MX8MN_IOMUXC_UART4_RXD__UART2_DCE_CTS_B		0x140
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ECSPI1_SCLK__UART3_DCE_RX		0x140
+			MX8MN_IOMUXC_ECSPI1_MOSI__UART3_DCE_TX		0x140
+		>;
+	};
+
+	pinctrl_uart3_rtscts: uart3-rtsctsgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ECSPI1_SS0__UART3_DCE_RTS_B	0x140
+			MX8MN_IOMUXC_ECSPI1_MISO__UART3_DCE_CTS_B	0x140
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD1_CLK__USDHC1_CLK		0x190
+			MX8MN_IOMUXC_SD1_CMD__USDHC1_CMD		0x150
+			MX8MN_IOMUXC_SD1_DATA0__USDHC1_DATA0		0x1d0
+			MX8MN_IOMUXC_SD1_DATA1__USDHC1_DATA1		0x1d0
+			MX8MN_IOMUXC_SD1_DATA2__USDHC1_DATA2		0x1d0
+			MX8MN_IOMUXC_SD1_DATA3__USDHC1_DATA3		0x1d0
+			MX8MN_IOMUXC_SD1_DATA4__USDHC1_DATA4		0x1d0
+			MX8MN_IOMUXC_SD1_DATA5__USDHC1_DATA5		0x1d0
+			MX8MN_IOMUXC_SD1_DATA6__USDHC1_DATA6		0x1d0
+			MX8MN_IOMUXC_SD1_DATA7__USDHC1_DATA7		0x1d0
+			MX8MN_IOMUXC_SD1_STROBE__USDHC1_STROBE		0x156
+			MX8MN_IOMUXC_SD1_RESET_B__USDHC1_RESET_B	0x156
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD2_CLK__USDHC2_CLK		0x190
+			MX8MN_IOMUXC_SD2_CMD__USDHC2_CMD		0x1d0
+			MX8MN_IOMUXC_SD2_DATA0__USDHC2_DATA0		0x1d0
+			MX8MN_IOMUXC_SD2_DATA1__USDHC2_DATA1		0x1d0
+			MX8MN_IOMUXC_SD2_DATA2__USDHC2_DATA2		0x1d0
+			MX8MN_IOMUXC_SD2_DATA3__USDHC2_DATA3		0x1d0
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2grp100mhz {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD2_CLK__USDHC2_CLK		0x194
+			MX8MN_IOMUXC_SD2_CMD__USDHC2_CMD		0x1d4
+			MX8MN_IOMUXC_SD2_DATA0__USDHC2_DATA0		0x1d4
+			MX8MN_IOMUXC_SD2_DATA1__USDHC2_DATA1		0x1d4
+			MX8MN_IOMUXC_SD2_DATA2__USDHC2_DATA2		0x1d4
+			MX8MN_IOMUXC_SD2_DATA3__USDHC2_DATA3		0x1d4
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2grp200mhz {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD2_CLK__USDHC2_CLK		0x196
+			MX8MN_IOMUXC_SD2_CMD__USDHC2_CMD		0x1d6
+			MX8MN_IOMUXC_SD2_DATA0__USDHC2_DATA0		0x1d6
+			MX8MN_IOMUXC_SD2_DATA1__USDHC2_DATA1		0x1d6
+			MX8MN_IOMUXC_SD2_DATA2__USDHC2_DATA2		0x1d6
+			MX8MN_IOMUXC_SD2_DATA3__USDHC2_DATA3		0x1d6
+		>;
+	};
+
+	pinctrl_usdhc2_cd: usdhc2-cdgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD2_CD_B__GPIO2_IO12		0x1c0
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_NAND_WE_B__USDHC3_CLK		0x40000190
+			MX8MN_IOMUXC_NAND_WP_B__USDHC3_CMD		0x1d0
+			MX8MN_IOMUXC_NAND_DATA04__USDHC3_DATA0		0x1d0
+			MX8MN_IOMUXC_NAND_DATA05__USDHC3_DATA1		0x1d0
+			MX8MN_IOMUXC_NAND_DATA06__USDHC3_DATA2		0x1d0
+			MX8MN_IOMUXC_NAND_DATA07__USDHC3_DATA3		0x1d0
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3grp100mhz {
+		fsl,pins = <
+			MX8MN_IOMUXC_NAND_WE_B__USDHC3_CLK		0x40000194
+			MX8MN_IOMUXC_NAND_WP_B__USDHC3_CMD		0x1d4
+			MX8MN_IOMUXC_NAND_DATA04__USDHC3_DATA0		0x1d4
+			MX8MN_IOMUXC_NAND_DATA05__USDHC3_DATA1		0x1d4
+			MX8MN_IOMUXC_NAND_DATA06__USDHC3_DATA2		0x1d4
+			MX8MN_IOMUXC_NAND_DATA07__USDHC3_DATA3		0x1d4
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3grp200mhz {
+		fsl,pins = <
+			MX8MN_IOMUXC_NAND_WE_B__USDHC3_CLK		0x40000196
+			MX8MN_IOMUXC_NAND_WP_B__USDHC3_CMD		0x1d6
+			MX8MN_IOMUXC_NAND_DATA04__USDHC3_DATA0		0x1d6
+			MX8MN_IOMUXC_NAND_DATA05__USDHC3_DATA1		0x1d6
+			MX8MN_IOMUXC_NAND_DATA06__USDHC3_DATA2		0x1d6
+			MX8MN_IOMUXC_NAND_DATA07__USDHC3_DATA3		0x1d6
+		>;
+	};
+
+	pinctrl_usdhc3_cd: usdhc3-cdgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_NAND_DATA02__GPIO3_IO8		0x1c0
+		>;
+	};
+};
diff --git a/board/karo/tx8m/Makefile b/board/karo/tx8m/Makefile
index 8aa49a7..c780594 100644
--- a/board/karo/tx8m/Makefile
+++ b/board/karo/tx8m/Makefile
@@ -14,8 +14,8 @@ obj-$(CONFIG_IMX8M_DDR3L) += ddr3l_timing.o
 
 else
 
-obj-$(CONFIG_KARO_TX8MM) += tx8m.o
-obj-$(CONFIG_KARO_TX8MN) += tx8m.o
+obj-$(CONFIG_KARO_TX8MM) += tx8mm.o
+obj-$(CONFIG_KARO_TX8MN) += tx8mn.o
 obj-$(CONFIG_KARO_QS8M) += qs8m.o
 
 endif
diff --git a/board/karo/tx8m/spl.c b/board/karo/tx8m/spl.c
index 122c43e..ca64d18 100644
--- a/board/karo/tx8m/spl.c
+++ b/board/karo/tx8m/spl.c
@@ -305,7 +305,7 @@ static inline int power_init_board(void)
 {
 	return 0;
 }
-#endif /* CONFIG_POWER && CONFIG_KARO_TX8MM */
+#endif /* CONFIG_POWER */
 
 #ifdef CONFIG_KARO_QS8M
 #define pmic_i2c_addr		0x34
diff --git a/board/karo/tx8m/tx8m.c b/board/karo/tx8m/tx8m.c
deleted file mode 100644
index a8d5bc5..0000000
--- a/board/karo/tx8m/tx8m.c
+++ /dev/null
@@ -1,887 +0,0 @@
-/*
- * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <console.h>
-#include <errno.h>
-#include <fsl_esdhc.h>
-#include <fsl_wdog.h>
-#include <imx_mipi_dsi_bridge.h>
-#include <led.h>
-#include <malloc.h>
-#include <miiphy.h>
-#include <mipi_dsi_panel.h>
-#include <mmc.h>
-#include <netdev.h>
-#include <sec_mipi_dsim.h>
-#include <spl.h>
-#include <thermal.h>
-#include <asm-generic/gpio.h>
-#include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/imx8mm_pins.h>
-#include <asm/arch/sys_proto.h>
-#include <asm/armv8/mmu.h>
-#include <asm/mach-imx/dma.h>
-#include <asm/mach-imx/gpio.h>
-#include <asm/mach-imx/iomux-v3.h>
-#include <asm/mach-imx/mxc_i2c.h>
-#include <asm/mach-imx/video.h>
-#include <dm/uclass.h>
-#include <power/pmic.h>
-#include "../common/karo.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#if !CONFIG_IS_ENABLED(DM_MMC)
-#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
-					     PAD_CTL_PUE |	\
-					     PAD_CTL_FSEL2 |	\
-					     PAD_CTL_DSE6)
-
-#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
-					     PAD_CTL_HYS |	\
-					     PAD_CTL_PUE |	\
-					     PAD_CTL_DSE6)
-
-static const iomux_v3_cfg_t tx8mm_usdhc1_pads[] = {
-	IMX8MM_PAD_SD1_CLK_USDHC1_CLK | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_CMD_USDHC1_CMD | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA0_USDHC1_DATA0 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA1_USDHC1_DATA1 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA2_USDHC1_DATA2 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA3_USDHC1_DATA3 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA4_USDHC1_DATA4 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA5_USDHC1_DATA5 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA6_USDHC1_DATA6 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_DATA7_USDHC1_DATA7 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD1_STROBE_USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
-	IMX8MM_PAD_SD1_RESET_B_USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
-};
-
-static const iomux_v3_cfg_t tx8mm_usdhc2_pads[] = {
-	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_SD2_CD_B_GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
-};
-
-static const iomux_v3_cfg_t tx8mm_usdhc3_pads[] = {
-	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | USDHC_PAD_CTRL,
-	IMX8MM_PAD_NAND_DATA02_GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
-};
-
-static struct tx8m_esdhc_cfg {
-	struct fsl_esdhc_cfg cfg;
-	int clk;
-	const iomux_v3_cfg_t *pads;
-	size_t num_pads;
-	int cd_gpio;
-} tx8mm_sdhc_cfgs[] = {
-	{
-		.cfg = {
-			.esdhc_base = USDHC1_BASE_ADDR,
-			.max_bus_width = 8,
-		},
-		.clk = MXC_ESDHC_CLK,
-		.pads = tx8mm_usdhc1_pads,
-		.num_pads = ARRAY_SIZE(tx8mm_usdhc1_pads),
-		.cd_gpio = -EINVAL,
-	},
-	{
-		.cfg = {
-			.esdhc_base = USDHC2_BASE_ADDR,
-			.max_bus_width = 4,
-		},
-		.clk = MXC_ESDHC2_CLK,
-		.pads = tx8mm_usdhc2_pads,
-		.num_pads = ARRAY_SIZE(tx8mm_usdhc2_pads),
-		.cd_gpio = IMX_GPIO_NR(2, 12),
-	},
-	{
-		.cfg = {
-			.esdhc_base = USDHC3_BASE_ADDR,
-			.max_bus_width = 4,
-		},
-		.clk = MXC_ESDHC3_CLK,
-		.pads = tx8mm_usdhc3_pads,
-		.num_pads = ARRAY_SIZE(tx8mm_usdhc3_pads),
-		.cd_gpio = IMX_GPIO_NR(3, 8),
-	},
-};
-
-static inline struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
-{
-	for (size_t i = 0; i < ARRAY_SIZE(tx8mm_sdhc_cfgs); i++) {
-		struct tx8m_esdhc_cfg *cfg = &tx8mm_sdhc_cfgs[i];
-
-		if (priv->esdhc_base == cfg->cfg.esdhc_base)
-			return cfg;
-	}
-	return NULL;
-}
-
-int board_mmc_getcd(struct mmc *mmc)
-{
-	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
-
-	if (cfg == NULL) {
-		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
-		return 0;
-	}
-	if (cfg->cd_gpio < 0) {
-		debug("%s@%d: 1\n", __func__, __LINE__);
-		return 1;
-	}
-	debug("%s@%d: %d\n", __func__, __LINE__,
-	      !gpio_get_value(cfg->cd_gpio));
-	return !gpio_get_value(cfg->cd_gpio);
-}
-
-int board_mmc_init(bd_t *bis)
-{
-	int ret;
-	/*
-	 * According to the board_mmc_init() the following map is done:
-	 * (U-Boot device node)    (Physical Port)
-	 * mmc0                    USDHC1 (eMMC)
-	 * mmc1                    USDHC2
-	 * mmc2                    USDHC3
-	 */
-
-	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
-		struct mmc *mmc;
-		struct tx8m_esdhc_cfg *cfg;
-
-		if (i >= ARRAY_SIZE(tx8mm_sdhc_cfgs)) {
-			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
-			       CONFIG_SYS_FSL_USDHC_NUM,
-			       ARRAY_SIZE(tx8mm_sdhc_cfgs));
-			return -EINVAL;
-		}
-
-		cfg = &tx8mm_sdhc_cfgs[i];
-		if (cfg->cd_gpio >= 0) {
-			gpio_request(cfg->cd_gpio, "MMC CD");
-			gpio_direction_input(cfg->cd_gpio);
-		}
-		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
-		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
-
-		debug("%s@%d: Initialising MMC dev %zu @ %08llx clock=%u\n", __func__, __LINE__,
-		      i, cfg->cfg.esdhc_base, cfg->cfg.sdhc_clk);
-		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
-		if (ret) {
-			printf("Failed to initialize MMC%zu: %d\n", i, ret);
-			continue;
-		}
-
-		mmc = find_mmc_device(i);
-		if (mmc == NULL) {
-			printf("mmc device %zi not found\n", i);
-			continue;
-		}
-		if (board_mmc_getcd(mmc)) {
-			ret = mmc_init(mmc);
-			if (ret && ret != -EOPNOTSUPP)
-				printf("%s@%d: mmc_init(mmc%zi) failed: %d\n",
-				       __func__, __LINE__, i, ret);
-		} else {
-			debug("No Medium found in MMC slot %zi\n", i);
-		}
-	}
-	return 0;
-}
-#endif /* DM_MMC */
-
-#ifdef CONFIG_OF_BOARD_SETUP
-#include <asm/setup.h>
-#include <asm/bootm.h>
-
-int ft_board_setup(void *blob, bd_t *bd)
-{
-	struct tag_serialnr serno;
-	char serno_str[64 / 4 + 1];
-
-	get_board_serial(&serno);
-	snprintf(serno_str, sizeof(serno_str), "%08x%08x",
-		 serno.high, serno.low);
-
-	printf("serial-number: %s\n", serno_str);
-
-	fdt_setprop(blob, 0, "serial-number", serno_str, strlen(serno_str));
-	fsl_fdt_fixup_dr_usb(blob, bd);
-	return 0;
-}
-#endif /* OF_BOARD_SETUP */
-
-#ifdef CONFIG_FEC_MXC
-#define MDIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_DSE6 |	\
-					     PAD_CTL_PE |	\
-					     PAD_CTL_PUE)
-
-#define FEC_IN_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL2)
-
-#define FEC_OUT_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_FSEL2 |	\
-					     PAD_CTL_DSE6)
-
-static const iomux_v3_cfg_t tx8mm_fec_pads[] = {
-	IMX8MM_PAD_ENET_MDC_ENET1_MDC | MDIO_PAD_CTRL, /* 0x146 */
-	IMX8MM_PAD_ENET_MDIO_ENET1_MDIO | MDIO_PAD_CTRL,
-	IMX8MM_PAD_ENET_TD2_ENET1_TX_CLK | MUX_MODE_SION | FEC_IN_PAD_CTRL, /* 0x40000016 */
-	IMX8MM_PAD_ENET_TD0_ENET1_RGMII_TD0 | FEC_OUT_PAD_CTRL, /* 0x16 */
-	IMX8MM_PAD_ENET_TD1_ENET1_RGMII_TD1 | FEC_OUT_PAD_CTRL, /* 0x16 */
-	IMX8MM_PAD_ENET_RD0_ENET1_RGMII_RD0 | FEC_IN_PAD_CTRL, /* 0x90 */
-	IMX8MM_PAD_ENET_RD1_ENET1_RGMII_RD1 | FEC_IN_PAD_CTRL, /* 0x90 */
-	IMX8MM_PAD_ENET_RXC_ENET1_RX_ER | FEC_IN_PAD_CTRL, /* 0x90 */
-	IMX8MM_PAD_ENET_RX_CTL_ENET1_RGMII_RX_CTL | FEC_IN_PAD_CTRL, /* 0x90 */
-	IMX8MM_PAD_ENET_TX_CTL_ENET1_RGMII_TX_CTL | FEC_OUT_PAD_CTRL, /* 0x16 */
-};
-
-#include <fuse.h>
-static int tx8mm_etnphy_init(void)
-{
-	int ret;
-	struct gpio_desc enet0_pwr;
-	struct gpio_desc enet0_rst;
-
-	ret = dm_gpio_lookup_name("gpio1_23", &enet0_pwr);
-	if (ret) {
-		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
-		return ret;
-	}
-
-	ret = dm_gpio_lookup_name("gpio1_29", &enet0_rst);
-	if (ret) {
-		printf("Failed to lookup ENET0_RST GPIO: %d\n", ret);
-		return ret;
-	}
-
-	ret = dm_gpio_request(&enet0_pwr, "ENET0_PWR");
-	if (ret) {
-		printf("Failed to request ENET0_PWR GPIO: %d\n", ret);
-		return ret;
-	}
-
-	ret = dm_gpio_request(&enet0_rst, "ENET0_RST");
-	if (ret) {
-		printf("Failed to request ENET0_RST GPIO: %d\n", ret);
-		return ret;
-	}
-
-	dm_gpio_set_dir_flags(&enet0_rst, GPIOD_IS_OUT);
-	dm_gpio_set_dir_flags(&enet0_pwr, GPIOD_IS_OUT);
-	dm_gpio_set_value(&enet0_rst, 0);
-	dm_gpio_set_value(&enet0_pwr, 1);
-
-	imx_iomux_v3_setup_multiple_pads(tx8mm_fec_pads,
-					 ARRAY_SIZE(tx8mm_fec_pads));
-
-	mdelay(25);
-	dm_gpio_set_value(&enet0_rst, 1);
-	mdelay(10);
-	return 0;
-}
-
-static int tx8mm_setup_fec(void)
-{
-	struct iomuxc_gpr_base_regs *iomuxc_gpr_regs =
-		(void *)IOMUXC_GPR_BASE_ADDR;
-	unsigned char mac[6];
-
-	set_clk_enet(ENET_50MHZ);
-
-	/* Use 50M anatop REF_CLK1 for ENET1, not from external */
-	setbits_le32(&iomuxc_gpr_regs->gpr[1],
-		     IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK);
-
-	imx_get_mac_from_fuse(0, mac);
-	printf("MAC addr: %pM\n", mac);
-
-	return tx8mm_etnphy_init();
-}
-
-int board_phy_config(struct phy_device *phydev)
-{
-	if (phydev->drv->config)
-		phydev->drv->config(phydev);
-
-	return 0;
-}
-#else
-static inline int tx8mm_setup_fec(void)
-{
-	return 0;
-}
-#endif /* FEX_MXC */
-
-int dram_init(void)
-{
-	/* rom_pointer[1] contains the size of RAM occupied by TEE */
-	if (rom_pointer[1])
-		gd->ram_size = PHYS_SDRAM_SIZE - ALIGN(rom_pointer[1], PAGE_SIZE);
-	else
-		gd->ram_size = PHYS_SDRAM_SIZE;
-
-	return 0;
-}
-
-int board_fix_fdt(void *blob)
-{
-	return 0;
-}
-
-#define GPIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
-					     PAD_CTL_PUE |	\
-					     PAD_CTL_DSE6)
-
-static const iomux_v3_cfg_t tx8mm_gpio_pads[] = {
-	IMX8MM_PAD_SD2_RESET_B_GPIO2_IO19 | GPIO_PAD_CTRL,
-};
-
-#ifdef CONFIG_SHOW_ACTIVITY
-enum {
-	LED_STATE_INIT = -1,
-	LED_STATE_OFF,
-	LED_STATE_ON,
-	LED_STATE_DISABLED,
-};
-
-static int led_state = LED_STATE_DISABLED;
-static bool tx8m_temp_check_enabled = true;
-static struct udevice *leddev;
-static struct udevice *thermaldev;
-
-#define TEMPERATURE_HOT		80
-#define TEMPERATURE_MIN		-40
-
-static inline int calc_blink_rate(void)
-{
-	int cpu_temp;
-	static int last_temp = INT_MAX;
-	static int avg_count;
-
-	if (!tx8m_temp_check_enabled)
-		return CONFIG_SYS_HZ;
-
-	if (!thermaldev || thermal_get_temp(thermaldev, &cpu_temp))
-		return CONFIG_SYS_HZ / 2;
-
-	if (last_temp == INT_MAX) {
-		last_temp = cpu_temp;
-	} else if (cpu_temp != last_temp) {
-		static int cpu_temps[4];
-
-		if (thermal_get_temp(thermaldev, &cpu_temps[avg_count]))
-			return CONFIG_SYS_HZ / 2;
-		if (++avg_count >= ARRAY_SIZE(cpu_temps)) {
-			int bad = -1;
-			int i;
-
-			for (i = 0; i < avg_count; i++) {
-				if (cpu_temp != cpu_temps[i])
-					bad = i;
-			}
-			if (bad < 0) {
-				debug("CPU temperature changed from %d to %d\n",
-				      last_temp, cpu_temp);
-				last_temp = cpu_temp;
-			} else {
-				debug("Spurious CPU temperature reading %d -> %d -> %d\n",
-				      cpu_temp, cpu_temps[bad], cpu_temps[i - 1]);
-			}
-			avg_count = 0;
-		}
-	} else {
-		avg_count = 0;
-	}
-	return CONFIG_SYS_HZ + CONFIG_SYS_HZ / 10 -
-		(last_temp - TEMPERATURE_MIN) * CONFIG_SYS_HZ /
-		(TEMPERATURE_HOT - TEMPERATURE_MIN);
-}
-
-void show_activity(int arg)
-{
-	static int blink_rate;
-	static ulong last;
-	int ret;
-
-	if (led_state == LED_STATE_DISABLED)
-		return;
-
-	if (led_state == LED_STATE_INIT) {
-		last = get_timer(0);
-		ret = led_set_state(leddev, LEDST_ON);
-		if (ret == 0)
-			led_state = LED_STATE_ON;
-		else
-			led_state = LED_STATE_DISABLED;
-		blink_rate = calc_blink_rate();
-	} else {
-		if (get_timer(last) > blink_rate) {
-			blink_rate = calc_blink_rate();
-			last = get_timer(0);
-			if (led_state == LED_STATE_ON) {
-				ret = led_set_state(leddev, LEDST_OFF);
-			} else {
-				ret = led_set_state(leddev, LEDST_ON);
-			}
-			if (ret == 0)
-				led_state = 1 - led_state;
-			else
-				led_state = LED_STATE_DISABLED;
-		}
-	}
-
-}
-
-static void tx8m_led_init(void)
-{
-	int ret;
-
-	ret = led_get_by_label("Heartbeat", &leddev);
-	if (ret) {
-		printf("Failed to find LED device: %d\n", ret);
-		return;
-	}
-
-	ret = uclass_get_device_by_name(UCLASS_THERMAL, "cpu-thermal",
-					&thermaldev);
-	if (ret)
-		printf("Failed to find THERMAL device: %d\n", ret);
-
-	led_state = LED_STATE_INIT;
-}
-#else
-static inline void tx8m_led_init(void)
-{
-	debug("%s@%d: \n", __func__, __LINE__);
-}
-#endif /* SHOW_ACTIVITY */
-
-int checkboard(void)
-{
-#if defined(CONFIG_KARO_TX8MM) || defined(CONFIG_KARO_TX8MN)
-	if (is_imx8mm())
-		printf("Board: Ka-Ro TX8M-1610\n");
-	else if (is_imx8mn())
-		printf("Board: Ka-Ro TX8M-ND00\n");
-	else
-		printf("Board: <unsupported processor type>\n");
-#elif defined(CONFIG_KARO_QS8M)
-	if (is_imx8mm())
-		printf("Board: Ka-Ro QS8M-MQ00\n");
-	else
-		printf("Board: Ka-Ro QS8M-ND00\n");
-#else
-#error Unsupported module variant
-#endif
-	return 0;
-}
-
-#ifdef CONFIG_DM_I2C
-static inline int tx8mm_i2c_init(void)
-{
-	int ret = 0;
-	int i;
-
-	for (i = 0; ret != -ENODEV; i++) {
-		struct udevice *i2c_dev;
-		u8 i2c_addr;
-
-		ret = uclass_get_device_by_seq(UCLASS_I2C, i, &i2c_dev);
-		if (ret == -ENODEV)
-			break;
-
-		for (i2c_addr = 0x07; i2c_addr < 0x78; i2c_addr++) {
-			struct udevice *chip;
-
-			ret = dm_i2c_probe(i2c_dev, i2c_addr, 0x0, &chip);
-			if (ret == 0) {
-				printf("Found an I2C device @ %u:%02x\n",
-				       i, i2c_addr);
-			} else if (ret != -EREMOTEIO) {
-				printf("Error %d accessing device %u:%02x\n",
-				       ret, i, i2c_addr);
-				break;
-			}
-		}
-	}
-	return ret;
-}
-#else
-static int tx8mm_i2c_init(void)
-{
-	return 0;
-}
-#endif
-
-int board_init(void)
-{
-	int ret;
-	struct gpio_desc reset_out;
-
-	tx8mm_setup_fec();
-
-	//tx8mm_i2c_init();
-
-	ret = dm_gpio_lookup_name("gpio2_19", &reset_out);
-	if (ret) {
-		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
-		return ret;
-	}
-	ret = dm_gpio_request(&reset_out, "RESET_OUT");
-	if (ret) {
-		printf("Failed to request RESET_OUT GPIO: %d\n", ret);
-		return ret;
-	}
-
-	imx_iomux_v3_setup_multiple_pads(tx8mm_gpio_pads,
-					 ARRAY_SIZE(tx8mm_gpio_pads));
-	tx8m_led_init();
-	return ret;
-}
-
-#ifdef CONFIG_BOARD_EARLY_INIT_R
-int board_early_init_r(void)
-{
-	return 0;
-}
-#endif
-
-int board_late_init(void)
-{
-	int ret;
-	struct src *src_regs = (void *)SRC_BASE_ADDR;
-	struct watchdog_regs *wdog = (void *)WDOG1_BASE_ADDR;
-	u32 srsr = readl(&src_regs->srsr);
-	u16 wrsr = readw(&wdog->wrsr);
-	const char *fdt_file = env_get("fdt_file");
-
-	karo_env_cleanup();
-	if (srsr & 0x10 && !(wrsr & WRSR_SFTW))
-		env_set("wdreset", "1");
-	if (had_ctrlc())
-		env_set("safeboot", "1");
-	if (fdt_file) {
-		ret = karo_load_fdt(fdt_file);
-		if (ret)
-			printf("Failed to load FDT from '%s': %d\n",
-			       fdt_file, ret);
-	}
-	return 0;
-}
-
-int mmc_map_to_kernel_blk(int devno)
-{
-	return devno + 1;
-}
-
-void board_quiesce_devices(void)
-{
-}
-
-#ifdef CONFIG_VIDEO
-static const struct sec_mipi_dsim_plat_data imx8mm_mipi_dsim_plat_data = {
-	.version	= 0x1060200,
-	.max_data_lanes = 4,
-	.max_data_rate  = 1500000000ULL,
-	.reg_base = MIPI_DSI_BASE_ADDR,
-	.gpr_base = CSI_BASE_ADDR + 0x8000,
-};
-
-#define DSI_DDR_MODE 0
-
-struct mipi_dsi_client_dev dsi83_dev = {
-	.channel = 0,
-	.lanes = 4,
-	.format = MIPI_DSI_FMT_RGB888,
-	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
-	.name = "DSI83",
-};
-
-#define DISPLAY_MIX_SFT_RSTN_CSR	0x00
-#define DISPLAY_MIX_CLK_EN_CSR		0x04
-
-   /* 'DISP_MIX_SFT_RSTN_CSR' bit fields */
-#define BUS_RSTN_BLK_SYNC_SFT_EN	BIT(6)
-
-   /* 'DISP_MIX_CLK_EN_CSR' bit fields */
-#define LCDIF_PIXEL_CLK_SFT_EN		BIT(7)
-#define LCDIF_APB_CLK_SFT_EN		BIT(6)
-
-static void disp_mix_bus_rstn_reset(ulong gpr_base, bool reset)
-{
-	if (!reset)
-		/* release reset */
-		setbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
-			     BUS_RSTN_BLK_SYNC_SFT_EN);
-	else
-		/* hold reset */
-		clrbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
-			     BUS_RSTN_BLK_SYNC_SFT_EN);
-}
-
-static void disp_mix_lcdif_clks_enable(ulong gpr_base, bool enable)
-{
-	if (enable)
-		/* enable lcdif clks */
-		setbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
-			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
-	else
-		/* disable lcdif clks */
-		clrbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
-			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
-}
-
-#define LINE_LENGTH	1280
-#define H_FRONT_PORCH	64
-#define H_BACK_PORCH	4
-#define HSYNC_LEN	1
-#define VERT_SIZE	800
-#define V_FRONT_PORCH	40
-#define V_BACK_PORCH	1
-#define VSYNC_LEN	1
-#define VREFRESH	60
-
-#define BPP	24
-#define SYNC_DELAY	64
-#define HTOTAL		(HSYNC_LEN + H_BACK_PORCH + LINE_LENGTH + H_FRONT_PORCH)
-#define VTOTAL		(VSYNC_LEN + V_BACK_PORCH + VERT_SIZE + V_FRONT_PORCH)
-#define PCLK		(HTOTAL * VTOTAL * VREFRESH)
-#define DSI_CLK		(PCLK * BPP / 4 / (!!DSI_DDR_MODE + 1))
-#define DSI_CLK_DIV	((DSI_CLK + PCLK - 1) / PCLK)
-#define LVDS_CLK	(DSI_CLK / DSI_CLK_DIV)
-#define LVDS_CLK_DIV	((LVDS_CLK + 12500000) / 25000000 - 1)
-
-static struct dsi83_data {
-	u8 addr;
-	u8 val;
-	u8 mask;
-} dsi83_data[] = {
-	{ 0x09, 1, },
-	{ 0x0d, 0x00, 0x01, },
-	{ 0x10, 0x00, 0x18, }, // DSI lanes 0x00: 4 lanes; 0x08: 3 lanes
-	{ 0x10, 0x00, 0x01, }, // SOT_ERR_TOL_DIS
-	{ 0x11, 0xc0, 0xc0, }, // DSI DATA equalization
-	{ 0x11, 0x0c, 0x0c, }, // DSI clock equalization
-	{ 0x12, DSI_CLK / 1000000 / 5, }, // DSI clk range 8: 40..45MHz; 9: 45..50MHz; ...
-	{ 0x0a, 0x01, 0x01, },
-	{ 0x0a, LVDS_CLK_DIV << 1, 0x0e, },
-	{ 0x0b, 0x00, 0x03, },
-	{ 0x0b, (DSI_CLK_DIV - 1) << 3, 0x7c, },
-	{ 0x18, 0x60, 0xe0, }, // DE_NEG HS_NEG VS_NEG
-	{ 0x18, 0x08, 0x9, }, // CHA_24BPP_MODE CHA24BPP_FORMAT1
-	{ 0x20, LINE_LENGTH % 256, },
-	{ 0x21, LINE_LENGTH / 256, },
-	{ 0x24, VERT_SIZE % 256, },
-	{ 0x25, VERT_SIZE / 256, },
-	{ 0x28, SYNC_DELAY % 256, },
-	{ 0x29, SYNC_DELAY / 256, },
-	{ 0x2c, HSYNC_LEN % 256, },
-	{ 0x2d, HSYNC_LEN / 256, },
-	{ 0x30, VSYNC_LEN % 256, },
-	{ 0x31, VSYNC_LEN / 256, },
-	{ 0x34, H_BACK_PORCH + HSYNC_LEN, },
-	{ 0x36, V_BACK_PORCH + VSYNC_LEN, },
-	{ 0x38, H_FRONT_PORCH, },
-	{ 0x3a, V_FRONT_PORCH, },
-	//{ 0x3c, 0x10, 0x10, }, // enable CHA_TEST_PATTERN
-	{ 0x3c, 0x00, },
-	{ 0x0d, 0x01, 0x01, }, // enable PLL
-	{ 0xe5, 0xfd, 0xfd, }, // clear error status
-};
-
-#define DSI83_SLAVE_ADDR	0x2c
-
-static int dsi83_init(void)
-{
-	int ret;
-	struct udevice *dev;
-	struct udevice *chip;
-	u8 val;
-
-	debug("DSI clock: %u.%03uMHz dsi_clk_div=%u\n",
-	      DSI_CLK / 1000000, DSI_CLK / 1000 % 1000, DSI_CLK_DIV);
-	debug("LVDS clock: %u.%03uMHz lvds_clk_range=%u\n",
-	      LVDS_CLK / 1000000, LVDS_CLK / 1000 % 1000, LVDS_CLK_DIV);
-
-	ret = uclass_get_device_by_seq(UCLASS_I2C, 1, &dev);
-	if (ret) {
-		printf("%s: Failed to find I2C bus device: %d\n",
-		       __func__, ret);
-		return ret;
-	}
-	ret = dm_i2c_probe(dev, DSI83_SLAVE_ADDR, 0x0, &chip);
-	if (ret) {
-		printf("%s: I2C probe failed for slave addr %02x: %d\n",
-		       __func__, DSI83_SLAVE_ADDR, ret);
-		return ret;
-	}
-	for (size_t i = 0; i < ARRAY_SIZE(dsi83_data); i++) {
-		struct dsi83_data *p = &dsi83_data[i];
-
-		ret = dm_i2c_read(chip, p->addr, &val, 1);
-		if (ret) {
-			printf("%s: Failed to read reg %02x\n",
-			       __func__, p->val);
-			return ret;
-		}
-		debug("%s@%d: Read %02x from reg %02x\n",
-		      __func__, __LINE__, val, p->addr);
-		val = (val & ~p->mask) | p->val;
-		debug("%s@%d: Writing %02x to reg %02x\n",
-		      __func__, __LINE__, val, p->addr);
-		ret = dm_i2c_write(chip, p->addr, &val, 1);
-		if (ret) {
-			printf("%s: Failed to write %02x to reg %02x\n",
-			       __func__, p->val, p->addr);
-			return ret;
-		}
-	}
-	return 0;
-}
-
-static const iomux_v3_cfg_t tx8mm_lcd_pads[] = {
-	IMX8MM_PAD_GPIO1_IO01_GPIO1_IO1 | GPIO_PAD_CTRL,
-	IMX8MM_PAD_GPIO1_IO04_GPIO1_IO4 | GPIO_PAD_CTRL,
-};
-
-static void tx8m_backlight_enable(void)
-{
-	int ret;
-	struct gpio_desc backlight_control;
-	struct gpio_desc lcd_enable;
-
-	ret = dm_gpio_lookup_name("gpio1_1", &backlight_control);
-	if (ret == 0) {
-		ret = dm_gpio_request(&backlight_control, "BACKLIGHT_CONTROL");
-		if (ret == 0) {
-			dm_gpio_set_dir_flags(&backlight_control, GPIOD_IS_OUT);
-			dm_gpio_set_value(&backlight_control, 1);
-		} else {
-			printf("Failed to request BACKLIGHT_CONTROL GPIO: %d\n",
-			       ret);
-		}
-	} else {
-		printf("Failed to lookup BACKLIGHT_CONTROL GPIO: %d\n", ret);
-	}
-
-	ret = dm_gpio_lookup_name("gpio1_4", &lcd_enable);
-	if (ret == 0) {
-		ret = dm_gpio_request(&lcd_enable, "LCD_ENABLE");
-		if (ret == 0) {
-			dm_gpio_set_dir_flags(&lcd_enable, GPIOD_IS_OUT);
-			dm_gpio_set_value(&lcd_enable, 1);
-		} else {
-			printf("Failed to request LCD_ENABLE GPIO: %d\n", ret);
-		}
-	} else {
-		printf("Failed to lookup LCD_ENABLE GPIO: %d\n", ret);
-	}
-
-	imx_iomux_v3_setup_multiple_pads(tx8mm_lcd_pads,
-					 ARRAY_SIZE(tx8mm_lcd_pads));
-}
-
-#define FSL_SIP_GPC			0xC2000000
-#define FSL_SIP_CONFIG_GPC_PM_DOMAIN	0x3
-#define DISPMIX				9
-#define MIPI				10
-
-static void do_enable_mipi2lvds(struct display_info_t const *disp)
-{
-	/* enable the dispmix & mipi phy power domain */
-	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
-		     DISPMIX, true, 0);
-	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
-		     MIPI, true, 0);
-
-	/* Get lcdif out of reset */
-	disp_mix_bus_rstn_reset(imx8mm_mipi_dsim_plat_data.gpr_base, false);
-	disp_mix_lcdif_clks_enable(imx8mm_mipi_dsim_plat_data.gpr_base, true);
-
-	sec_mipi_dsim_setup(&imx8mm_mipi_dsim_plat_data);
-	imx_mipi_dsi_bridge_attach(&dsi83_dev);
-	dsi83_init();
-	tx8m_backlight_enable();
-}
-
-static struct display_info_t const panel_info[] = {
-	{
-		.bus = LCDIF_BASE_ADDR,
-		.pixfmt = BPP,
-		.enable	= do_enable_mipi2lvds,
-		.mode	= {
-			.name		= "MIPI2LVDS",
-			.refresh	= VREFRESH,
-			.xres		= LINE_LENGTH,
-			.yres		= VERT_SIZE,
-			.pixclock	= KHZ2PICOS(PCLK / 1000),
-			.left_margin	= H_BACK_PORCH,
-			.hsync_len	= HSYNC_LEN,
-			.right_margin	= H_FRONT_PORCH,
-			.upper_margin	= V_BACK_PORCH,
-			.vsync_len	= VSYNC_LEN,
-			.lower_margin	= V_FRONT_PORCH,
-			.sync		= FB_SYNC_EXT,
-			.vmode		= FB_VMODE_NONINTERLACED,
-		},
-	},
-};
-
-int board_video_skip(void)
-{
-	int ret;
-	const char *baseboard = env_get("baseboard");
-	const char *panel = env_get("panel");
-	size_t i;
-
-	if (had_ctrlc()) {
-		printf("<CTRL-C> detected; disabling display\n");
-		return 1;
-	}
-
-	if (!panel) {
-		printf("No LCD panel configured\n");
-		return 1;
-	}
-
-	if (!baseboard || strcmp(baseboard, "mipi-mb") != 0) {
-		printf("No Display support for '%s' baseboard\n",
-		       baseboard ?: "unspecified");
-		return 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(panel_info); i++) {
-		const struct display_info_t *pi = &panel_info[i];
-
-		if (strcmp(panel, pi->mode.name) != 0)
-			continue;
-
-		ret = mxs_lcd_panel_setup(pi->mode,
-					  pi->pixfmt,
-					  pi->bus);
-		if (ret)
-			return ret;
-
-		if (pi->enable)
-			pi->enable(panel_info + i);
-
-		printf("Display: %s (%ux%u)\n", pi->mode.name,
-		       pi->mode.xres, pi->mode.yres);
-	}
-	return ret;
-}
-#endif
diff --git a/board/karo/tx8m/tx8mm.c b/board/karo/tx8m/tx8mm.c
new file mode 100644
index 0000000..950be8b
--- /dev/null
+++ b/board/karo/tx8m/tx8mm.c
@@ -0,0 +1,923 @@
+/*
+ * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <console.h>
+#include <errno.h>
+#include <fsl_esdhc.h>
+#include <fsl_wdog.h>
+#include <imx_mipi_dsi_bridge.h>
+#include <led.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <mipi_dsi_panel.h>
+#include <mmc.h>
+#include <netdev.h>
+#include <sec_mipi_dsim.h>
+#include <spl.h>
+#include <thermal.h>
+#include <usb.h>
+#include <asm-generic/gpio.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx8mm_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/armv8/mmu.h>
+#include <asm/mach-imx/dma.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/video.h>
+#include <dm/uclass.h>
+#include <power/pmic.h>
+#include "../common/karo.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_HYS |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_usdhc1_pads[] = {
+	IMX8MM_PAD_SD1_CLK_USDHC1_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_CMD_USDHC1_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA0_USDHC1_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA1_USDHC1_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA2_USDHC1_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA3_USDHC1_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA4_USDHC1_DATA4 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA5_USDHC1_DATA5 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA6_USDHC1_DATA6 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA7_USDHC1_DATA7 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_STROBE_USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
+	IMX8MM_PAD_SD1_RESET_B_USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc2_pads[] = {
+	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CD_B_GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc3_pads[] = {
+	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA02_GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
+};
+
+static struct tx8m_esdhc_cfg {
+	struct fsl_esdhc_cfg cfg;
+	int clk;
+	const iomux_v3_cfg_t *pads;
+	size_t num_pads;
+	int cd_gpio;
+} tx8mm_sdhc_cfgs[] = {
+	{
+		.cfg = {
+			.esdhc_base = USDHC1_BASE_ADDR,
+			.max_bus_width = 8,
+		},
+		.clk = MXC_ESDHC_CLK,
+		.pads = tx8mm_usdhc1_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc1_pads),
+		.cd_gpio = -EINVAL,
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC2_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC2_CLK,
+		.pads = tx8mm_usdhc2_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc2_pads),
+		.cd_gpio = IMX_GPIO_NR(2, 12),
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC3_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC3_CLK,
+		.pads = tx8mm_usdhc3_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc3_pads),
+		.cd_gpio = IMX_GPIO_NR(3, 8),
+	},
+};
+
+static inline struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(tx8mm_sdhc_cfgs); i++) {
+		struct tx8m_esdhc_cfg *cfg = &tx8mm_sdhc_cfgs[i];
+
+		if (priv->esdhc_base == cfg->cfg.esdhc_base)
+			return cfg;
+	}
+	return NULL;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
+
+	if (cfg == NULL) {
+		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
+		return 0;
+	}
+	if (cfg->cd_gpio < 0) {
+		debug("%s@%d: 1\n", __func__, __LINE__);
+		return 1;
+	}
+	debug("%s@%d: %d\n", __func__, __LINE__,
+	      !gpio_get_value(cfg->cd_gpio));
+	return !gpio_get_value(cfg->cd_gpio);
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (eMMC)
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+
+	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		struct mmc *mmc;
+		struct tx8m_esdhc_cfg *cfg;
+
+		if (i >= ARRAY_SIZE(tx8mm_sdhc_cfgs)) {
+			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
+			       CONFIG_SYS_FSL_USDHC_NUM,
+			       ARRAY_SIZE(tx8mm_sdhc_cfgs));
+			return -EINVAL;
+		}
+
+		cfg = &tx8mm_sdhc_cfgs[i];
+		if (cfg->cd_gpio >= 0) {
+			gpio_request(cfg->cd_gpio, "MMC CD");
+			gpio_direction_input(cfg->cd_gpio);
+		}
+		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
+		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
+
+		debug("%s@%d: Initialising MMC dev %zu @ %08llx clock=%u\n", __func__, __LINE__,
+		      i, cfg->cfg.esdhc_base, cfg->cfg.sdhc_clk);
+		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
+		if (ret) {
+			printf("Failed to initialize MMC%zu: %d\n", i, ret);
+			continue;
+		}
+
+		mmc = find_mmc_device(i);
+		if (mmc == NULL) {
+			printf("mmc device %zi not found\n", i);
+			continue;
+		}
+		if (board_mmc_getcd(mmc)) {
+			ret = mmc_init(mmc);
+			if (ret && ret != -EOPNOTSUPP)
+				printf("%s@%d: mmc_init(mmc%zi) failed: %d\n",
+				       __func__, __LINE__, i, ret);
+		} else {
+			debug("No Medium found in MMC slot %zi\n", i);
+		}
+	}
+	return 0;
+}
+#endif /* DM_MMC */
+
+#ifdef CONFIG_USB
+int board_usb_init(int index, enum usb_init_type init)
+{
+	imx8m_usb_power(index, true);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+#define MDIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_DSE6 |	\
+					     PAD_CTL_PE |	\
+					     PAD_CTL_PUE)
+
+#define FEC_IN_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL2)
+
+#define FEC_OUT_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_fec_pads[] = {
+	IMX8MM_PAD_ENET_MDC_ENET1_MDC | MDIO_PAD_CTRL, /* 0x146 */
+	IMX8MM_PAD_ENET_MDIO_ENET1_MDIO | MDIO_PAD_CTRL,
+	IMX8MM_PAD_ENET_TD2_ENET1_TX_CLK | MUX_MODE_SION | FEC_IN_PAD_CTRL, /* 0x40000016 */
+	IMX8MM_PAD_ENET_TD0_ENET1_RGMII_TD0 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MM_PAD_ENET_TD1_ENET1_RGMII_TD1 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MM_PAD_ENET_RD0_ENET1_RGMII_RD0 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RD1_ENET1_RGMII_RD1 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RXC_ENET1_RX_ER | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RX_CTL_ENET1_RGMII_RX_CTL | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_TX_CTL_ENET1_RGMII_TX_CTL | FEC_OUT_PAD_CTRL, /* 0x16 */
+};
+
+#include <fuse.h>
+static int tx8mm_etnphy_init(void)
+{
+	int ret;
+	struct gpio_desc enet0_pwr;
+	struct gpio_desc enet0_rst;
+
+	ret = dm_gpio_lookup_name("gpio1_23", &enet0_pwr);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_lookup_name("gpio1_29", &enet0_rst);
+	if (ret) {
+		printf("Failed to lookup ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_pwr, "ENET0_PWR");
+	if (ret) {
+		printf("Failed to request ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_rst, "ENET0_RST");
+	if (ret) {
+		printf("Failed to request ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	dm_gpio_set_dir_flags(&enet0_rst, GPIOD_IS_OUT);
+	dm_gpio_set_dir_flags(&enet0_pwr, GPIOD_IS_OUT);
+	dm_gpio_set_value(&enet0_rst, 0);
+	dm_gpio_set_value(&enet0_pwr, 1);
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_fec_pads,
+					 ARRAY_SIZE(tx8mm_fec_pads));
+
+	mdelay(25);
+	dm_gpio_set_value(&enet0_rst, 1);
+	mdelay(10);
+	return 0;
+}
+
+static int tx8mm_setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *iomuxc_gpr_regs =
+		(void *)IOMUXC_GPR_BASE_ADDR;
+	unsigned char mac[6];
+
+	set_clk_enet(ENET_50MHZ);
+
+	/* Use 50M anatop REF_CLK1 for ENET1, not from external */
+	setbits_le32(&iomuxc_gpr_regs->gpr[1],
+		     IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK);
+
+	imx_get_mac_from_fuse(0, mac);
+	printf("MAC addr: %pM\n", mac);
+
+	return tx8mm_etnphy_init();
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#else
+static inline int tx8mm_setup_fec(void)
+{
+	return 0;
+}
+#endif /* FEX_MXC */
+
+int dram_init(void)
+{
+	/* rom_pointer[1] contains the size of RAM occupied by TEE */
+	if (rom_pointer[1])
+		gd->ram_size = PHYS_SDRAM_SIZE -
+			ALIGN(rom_pointer[1], PAGE_SIZE);
+	else
+		gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+int board_fix_fdt(void *blob)
+{
+	return 0;
+}
+
+#define GPIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_gpio_pads[] = {
+	IMX8MM_PAD_SD2_RESET_B_GPIO2_IO19 | GPIO_PAD_CTRL,
+};
+
+#ifdef CONFIG_SHOW_ACTIVITY
+enum {
+	LED_STATE_INIT = -1,
+	LED_STATE_OFF,
+	LED_STATE_ON,
+	LED_STATE_DISABLED,
+};
+
+static int led_state = LED_STATE_DISABLED;
+static bool tx8m_temp_check_enabled = true;
+static struct udevice *leddev;
+static struct udevice *thermaldev;
+
+#define TEMPERATURE_HOT		80
+#define TEMPERATURE_MIN		-40
+
+static inline int calc_blink_rate(void)
+{
+	int cpu_temp;
+	static int last_temp = INT_MAX;
+	static int avg_count;
+
+	if (!tx8m_temp_check_enabled)
+		return CONFIG_SYS_HZ;
+
+	if (!thermaldev || thermal_get_temp(thermaldev, &cpu_temp))
+		return CONFIG_SYS_HZ / 2;
+
+	if (last_temp == INT_MAX) {
+		last_temp = cpu_temp;
+	} else if (cpu_temp != last_temp) {
+		static int cpu_temps[4];
+
+		if (thermal_get_temp(thermaldev, &cpu_temps[avg_count]))
+			return CONFIG_SYS_HZ / 2;
+		if (++avg_count >= ARRAY_SIZE(cpu_temps)) {
+			int bad = -1;
+			int i;
+
+			for (i = 0; i < avg_count; i++) {
+				if (cpu_temp != cpu_temps[i])
+					bad = i;
+			}
+			if (bad < 0) {
+				debug("CPU temperature changed from %d to %d\n",
+				      last_temp, cpu_temp);
+				last_temp = cpu_temp;
+			} else {
+				debug("Spurious CPU temperature reading %d -> %d -> %d\n",
+				      cpu_temp, cpu_temps[bad],
+				      cpu_temps[i - 1]);
+			}
+			avg_count = 0;
+		}
+	} else {
+		avg_count = 0;
+	}
+	return CONFIG_SYS_HZ + CONFIG_SYS_HZ / 10 -
+		(last_temp - TEMPERATURE_MIN) * CONFIG_SYS_HZ /
+		(TEMPERATURE_HOT - TEMPERATURE_MIN);
+}
+
+void show_activity(int arg)
+{
+	static int blink_rate;
+	static ulong last;
+	int ret;
+
+	if (led_state == LED_STATE_DISABLED)
+		return;
+
+	if (led_state == LED_STATE_INIT) {
+		last = get_timer(0);
+		ret = led_set_state(leddev, LEDST_ON);
+		if (ret == 0)
+			led_state = LED_STATE_ON;
+		else
+			led_state = LED_STATE_DISABLED;
+		blink_rate = calc_blink_rate();
+	} else {
+		if (get_timer(last) > blink_rate) {
+			blink_rate = calc_blink_rate();
+			last = get_timer(0);
+			if (led_state == LED_STATE_ON) {
+				ret = led_set_state(leddev, LEDST_OFF);
+			} else {
+				ret = led_set_state(leddev, LEDST_ON);
+			}
+			if (ret == 0)
+				led_state = 1 - led_state;
+			else
+				led_state = LED_STATE_DISABLED;
+		}
+	}
+
+}
+
+static void tx8m_led_init(void)
+{
+	int ret;
+
+	ret = led_get_by_label("Heartbeat", &leddev);
+	if (ret) {
+		printf("Failed to find LED device: %d\n", ret);
+		return;
+	}
+
+	ret = uclass_get_device_by_name(UCLASS_THERMAL, "cpu-thermal",
+					&thermaldev);
+	if (ret)
+		printf("Failed to find THERMAL device: %d\n", ret);
+
+	led_state = LED_STATE_INIT;
+}
+#else
+static inline void tx8m_led_init(void)
+{
+	debug("%s@%d: \n", __func__, __LINE__);
+}
+#endif /* SHOW_ACTIVITY */
+
+int checkboard(void)
+{
+#if defined(CONFIG_KARO_TX8MM_1610) || defined(CONFIG_KARO_TX8MN)
+	if (is_imx8mm())
+		printf("Board: Ka-Ro TX8M-1610\n");
+	else if (is_imx8mn())
+		printf("Board: Ka-Ro TX8M-ND00\n");
+	else
+		printf("Board: <unsupported processor type>\n");
+#elif defined(CONFIG_KARO_TX8MM_1620)
+		printf("Board: Ka-Ro TX8M-1620\n");
+#elif defined(CONFIG_KARO_QS8M)
+	if (is_imx8mm())
+		printf("Board: Ka-Ro QS8M-MQ00\n");
+	else
+		printf("Board: Ka-Ro QS8M-ND00\n");
+#else
+#error Unsupported module variant
+#endif
+	ctrlc();
+	return 0;
+}
+
+#ifdef CONFIG_DM_I2C
+static inline int tx8mm_i2c_init(void)
+{
+	int ret = 0;
+	int i;
+
+	for (i = 0; ret != -ENODEV; i++) {
+		struct udevice *i2c_dev;
+		u8 i2c_addr;
+
+		ret = uclass_get_device_by_seq(UCLASS_I2C, i, &i2c_dev);
+		if (ret == -ENODEV)
+			break;
+
+		for (i2c_addr = 0x07; i2c_addr < 0x78; i2c_addr++) {
+			struct udevice *chip;
+
+			ret = dm_i2c_probe(i2c_dev, i2c_addr, 0x0, &chip);
+			if (ret == 0) {
+				printf("Found an I2C device @ %u:%02x\n",
+				       i, i2c_addr);
+			} else if (ret != -EREMOTEIO) {
+				printf("Error %d accessing device %u:%02x\n",
+				       ret, i, i2c_addr);
+				break;
+			}
+		}
+	}
+	return ret;
+}
+#else
+static int tx8mm_i2c_init(void)
+{
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	int ret;
+	struct gpio_desc reset_out;
+
+	tx8mm_setup_fec();
+
+	//tx8mm_i2c_init();
+
+	ret = dm_gpio_lookup_name("gpio2_19", &reset_out);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+	ret = dm_gpio_request(&reset_out, "RESET_OUT");
+	if (ret) {
+		printf("Failed to request RESET_OUT GPIO: %d\n", ret);
+		return ret;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_gpio_pads,
+					 ARRAY_SIZE(tx8mm_gpio_pads));
+	tx8m_led_init();
+	return ret;
+}
+
+#ifdef CONFIG_BOARD_EARLY_INIT_R
+int board_early_init_r(void)
+{
+	if (ctrlc())
+		printf("<CTRL-C> detected; safeboot enabled\n");
+	return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+	int ret;
+	struct src *src_regs = (void *)SRC_BASE_ADDR;
+	struct watchdog_regs *wdog = (void *)WDOG1_BASE_ADDR;
+	u32 srsr = readl(&src_regs->srsr);
+	u16 wrsr = readw(&wdog->wrsr);
+	const char *fdt_file = env_get("fdt_file");
+
+	karo_env_cleanup();
+	if (srsr & 0x10 && !(wrsr & WRSR_SFTW)) {
+		printf("Watchog reset detected; reboot required!\n");
+		env_set("wdreset", "1");
+	}
+	if (had_ctrlc()) {
+		env_set("safeboot", "1");
+		fdt_file = NULL;
+	}
+	if (fdt_file) {
+		ret = karo_load_fdt(fdt_file);
+		if (ret)
+			printf("Failed to load FDT from '%s': %d\n",
+			       fdt_file, ret);
+	}
+	if (CONFIG_IS_ENABLED(FASTBOOT) && is_usb_boot()) {
+		env_set("bootdelay", "0");
+		env_set("bootcmd", "fastboot");
+	}
+	clear_ctrlc();
+	return 0;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 1;
+}
+
+void board_quiesce_devices(void)
+{
+}
+
+#ifdef CONFIG_VIDEO
+
+#ifdef CONFIG_KARO_TX8MM_1620
+#define TX8M_DSI83_I2C_BUS	0
+#else
+#define TX8M_DSI83_I2C_BUS	1
+#endif
+
+#define DSI83_SLAVE_ADDR	0x2c
+
+#define DISPLAY_MIX_SFT_RSTN_CSR	0x00
+#define DISPLAY_MIX_CLK_EN_CSR		0x04
+
+   /* 'DISP_MIX_SFT_RSTN_CSR' bit fields */
+#define BUS_RSTN_BLK_SYNC_SFT_EN	BIT(6)
+
+   /* 'DISP_MIX_CLK_EN_CSR' bit fields */
+#define LCDIF_PIXEL_CLK_SFT_EN		BIT(7)
+#define LCDIF_APB_CLK_SFT_EN		BIT(6)
+
+#define DSI_DDR_MODE 0
+
+static const struct sec_mipi_dsim_plat_data imx8mm_mipi_dsim_plat_data = {
+	.version	= 0x1060200,
+	.max_data_lanes = 4,
+	.max_data_rate  = 1500000000ULL,
+	.reg_base = MIPI_DSI_BASE_ADDR,
+	.gpr_base = CSI_BASE_ADDR + 0x8000,
+};
+
+struct mipi_dsi_client_dev dsi83_dev = {
+	.channel = 0,
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+	.name = "DSI83",
+};
+
+static void disp_mix_bus_rstn_reset(ulong gpr_base, bool reset)
+{
+	if (!reset)
+		/* release reset */
+		setbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
+			     BUS_RSTN_BLK_SYNC_SFT_EN);
+	else
+		/* hold reset */
+		clrbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
+			     BUS_RSTN_BLK_SYNC_SFT_EN);
+}
+
+static void disp_mix_lcdif_clks_enable(ulong gpr_base, bool enable)
+{
+	if (enable)
+		/* enable lcdif clks */
+		setbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
+			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
+	else
+		/* disable lcdif clks */
+		clrbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
+			     LCDIF_PIXEL_CLK_SFT_EN | LCDIF_APB_CLK_SFT_EN);
+}
+
+#define LINE_LENGTH	1280
+#define H_FRONT_PORCH	64
+#define H_BACK_PORCH	4
+#define HSYNC_LEN	1
+#define VERT_SIZE	800
+#define V_FRONT_PORCH	40
+#define V_BACK_PORCH	1
+#define VSYNC_LEN	1
+#define VREFRESH	60
+
+#define BPP		24
+#define SYNC_DELAY	64
+#define HTOTAL		(HSYNC_LEN + H_BACK_PORCH + LINE_LENGTH + H_FRONT_PORCH)
+#define VTOTAL		(VSYNC_LEN + V_BACK_PORCH + VERT_SIZE + V_FRONT_PORCH)
+#define PCLK		(HTOTAL * VTOTAL * VREFRESH)
+#define DSI_CLK		(PCLK * BPP / 4 / (!!DSI_DDR_MODE + 1))
+#define DSI_CLK_DIV	((DSI_CLK + PCLK - 1) / PCLK)
+#define LVDS_CLK	(DSI_CLK / DSI_CLK_DIV)
+#define LVDS_CLK_DIV	((LVDS_CLK + 12500000) / 25000000 - 1)
+
+static struct dsi83_data {
+	u8 addr;
+	u8 val;
+	u8 mask;
+} dsi83_data[] = {
+	{ 0x09, 1, },
+	{ 0x0d, 0x00, 0x01, },
+	{ 0x10, 0x00, 0x18, }, // DSI lanes 0x00: 4 lanes; 0x08: 3 lanes
+	{ 0x10, 0x00, 0x01, }, // SOT_ERR_TOL_DIS
+	{ 0x11, 0xc0, 0xc0, }, // DSI DATA equalization
+	{ 0x11, 0x0c, 0x0c, }, // DSI clock equalization
+	{ 0x12, DSI_CLK / 1000000 / 5, }, // DSI clk range 8: 40..45MHz; 9: 45..50MHz; ...
+	{ 0x0a, 0x01, 0x01, },
+	{ 0x0a, LVDS_CLK_DIV << 1, 0x0e, },
+	{ 0x0b, 0x00, 0x03, },
+	{ 0x0b, (DSI_CLK_DIV - 1) << 3, 0x7c, },
+	{ 0x18, 0x60, 0xe0, }, // DE_NEG HS_NEG VS_NEG
+	{ 0x18, 0x08, 0x0a, }, // CHA_24BPP_MODE CHA24BPP_FORMAT1
+	{ 0x20, LINE_LENGTH % 256, },
+	{ 0x21, LINE_LENGTH / 256, },
+	{ 0x24, VERT_SIZE % 256, },
+	{ 0x25, VERT_SIZE / 256, },
+	{ 0x28, SYNC_DELAY % 256, },
+	{ 0x29, SYNC_DELAY / 256, },
+	{ 0x2c, HSYNC_LEN % 256, },
+	{ 0x2d, HSYNC_LEN / 256, },
+	{ 0x30, VSYNC_LEN % 256, },
+	{ 0x31, VSYNC_LEN / 256, },
+	{ 0x34, H_BACK_PORCH + HSYNC_LEN, },
+	{ 0x36, V_BACK_PORCH + VSYNC_LEN, },
+	{ 0x38, H_FRONT_PORCH, },
+	{ 0x3a, V_FRONT_PORCH, },
+	//{ 0x3c, 0x10, 0x10, }, // enable CHA_TEST_PATTERN
+	{ 0x3c, 0x00, },
+	{ 0x0d, 0x01, 0x01, }, // enable PLL
+	{ 0xe5, 0xfd, 0xfd, }, // clear error status
+};
+
+static int dsi83_init(void)
+{
+	int ret;
+	struct udevice *dev;
+	struct udevice *chip;
+	u8 val;
+
+	debug("DSI clock: %u.%03uMHz dsi_clk_div=%u\n",
+	      DSI_CLK / 1000000, DSI_CLK / 1000 % 1000, DSI_CLK_DIV);
+	debug("LVDS clock: %u.%03uMHz lvds_clk_range=%u\n",
+	      LVDS_CLK / 1000000, LVDS_CLK / 1000 % 1000, LVDS_CLK_DIV);
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, TX8M_DSI83_I2C_BUS, &dev);
+	if (ret) {
+		printf("%s: Failed to find I2C bus device: %d\n",
+		       __func__, ret);
+		return ret;
+	}
+	ret = dm_i2c_probe(dev, DSI83_SLAVE_ADDR, 0x0, &chip);
+	if (ret) {
+		printf("%s: I2C probe failed for slave addr %02x: %d\n",
+		       __func__, DSI83_SLAVE_ADDR, ret);
+		return ret;
+	}
+	for (size_t i = 0; i < ARRAY_SIZE(dsi83_data); i++) {
+		struct dsi83_data *p = &dsi83_data[i];
+
+		ret = dm_i2c_read(chip, p->addr, &val, 1);
+		if (ret) {
+			printf("%s: Failed to read reg %02x\n",
+			       __func__, p->val);
+			return ret;
+		}
+		debug("%s@%d: Read %02x from reg %02x\n",
+		      __func__, __LINE__, val, p->addr);
+		val = (val & ~p->mask) | p->val;
+		debug("%s@%d: Writing %02x to reg %02x\n",
+		      __func__, __LINE__, val, p->addr);
+		ret = dm_i2c_write(chip, p->addr, &val, 1);
+		if (ret) {
+			printf("%s: Failed to write %02x to reg %02x\n",
+			       __func__, p->val, p->addr);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static const iomux_v3_cfg_t tx8mm_lcd_pads[] = {
+	IMX8MM_PAD_GPIO1_IO01_GPIO1_IO1 | GPIO_PAD_CTRL,
+	IMX8MM_PAD_GPIO1_IO04_GPIO1_IO4 | GPIO_PAD_CTRL,
+};
+
+static void tx8m_backlight_enable(void)
+{
+	int ret;
+	struct gpio_desc backlight_control;
+	struct gpio_desc lcd_enable;
+
+	ret = dm_gpio_lookup_name("gpio1_1", &backlight_control);
+	if (ret == 0) {
+		ret = dm_gpio_request(&backlight_control, "BACKLIGHT_CONTROL");
+		if (ret == 0) {
+			dm_gpio_set_dir_flags(&backlight_control,
+					      GPIOD_IS_OUT);
+			dm_gpio_set_value(&backlight_control, 1);
+		} else {
+			printf("Failed to request BACKLIGHT_CONTROL GPIO: %d\n",
+			       ret);
+		}
+	} else {
+		printf("Failed to lookup BACKLIGHT_CONTROL GPIO: %d\n", ret);
+	}
+
+	ret = dm_gpio_lookup_name("gpio1_4", &lcd_enable);
+	if (ret == 0) {
+		ret = dm_gpio_request(&lcd_enable, "LCD_ENABLE");
+		if (ret == 0) {
+			dm_gpio_set_dir_flags(&lcd_enable, GPIOD_IS_OUT);
+			dm_gpio_set_value(&lcd_enable, 1);
+		} else {
+			printf("Failed to request LCD_ENABLE GPIO: %d\n", ret);
+		}
+	} else {
+		printf("Failed to lookup LCD_ENABLE GPIO: %d\n", ret);
+	}
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_lcd_pads,
+					 ARRAY_SIZE(tx8mm_lcd_pads));
+}
+
+#define FSL_SIP_GPC			0xC2000000
+#define FSL_SIP_CONFIG_GPC_PM_DOMAIN	0x3
+#define DISPMIX				9
+#define MIPI				10
+
+static void do_enable_mipi2lvds(struct display_info_t const *disp)
+{
+	/* enable the dispmix & mipi phy power domain */
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
+		     DISPMIX, true, 0);
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
+		     MIPI, true, 0);
+
+	/* Get lcdif out of reset */
+	disp_mix_bus_rstn_reset(imx8mm_mipi_dsim_plat_data.gpr_base, false);
+	disp_mix_lcdif_clks_enable(imx8mm_mipi_dsim_plat_data.gpr_base, true);
+
+	sec_mipi_dsim_setup(&imx8mm_mipi_dsim_plat_data);
+	imx_mipi_dsi_bridge_attach(&dsi83_dev);
+	dsi83_init();
+	tx8m_backlight_enable();
+}
+
+static struct display_info_t const panel_info[] = {
+	{
+		.bus = LCDIF_BASE_ADDR,
+		.pixfmt = BPP,
+		.enable	= do_enable_mipi2lvds,
+		.mode	= {
+			.name		= "MIPI2LVDS",
+			.refresh	= VREFRESH,
+			.xres		= LINE_LENGTH,
+			.yres		= VERT_SIZE,
+			.pixclock	= KHZ2PICOS(PCLK / 1000),
+			.left_margin	= H_BACK_PORCH,
+			.hsync_len	= HSYNC_LEN,
+			.right_margin	= H_FRONT_PORCH,
+			.upper_margin	= V_BACK_PORCH,
+			.vsync_len	= VSYNC_LEN,
+			.lower_margin	= V_FRONT_PORCH,
+			.sync		= FB_SYNC_EXT,
+			.vmode		= FB_VMODE_NONINTERLACED,
+		},
+	},
+};
+
+int board_video_skip(void)
+{
+	int ret;
+	const char *baseboard = env_get("baseboard");
+	const char *panel = env_get("panel");
+	size_t i;
+
+	debug("%s@%d: baseboard='%s' panel='%s'\n", __func__, __LINE__,
+	      baseboard, panel);
+
+	if (had_ctrlc()) {
+		printf("<CTRL-C> detected; disabling display\n");
+		return 1;
+	}
+
+	if (!panel) {
+		printf("No LCD panel configured\n");
+		return 1;
+	}
+
+	if (!baseboard || strcmp(baseboard, "mipi-mb") != 0) {
+		printf("No Display support for '%s' baseboard\n",
+		       baseboard ?: "unspecified");
+		return 1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(panel_info); i++) {
+		const struct display_info_t *pi = &panel_info[i];
+
+		if (strcmp(panel, pi->mode.name) != 0)
+			continue;
+
+		ret = mxs_lcd_panel_setup(pi->mode,
+					  pi->pixfmt,
+					  pi->bus);
+		if (ret)
+			return ret;
+
+		if (pi->enable)
+			pi->enable(panel_info + i);
+
+		printf("Display: %s (%ux%u)\n", pi->mode.name,
+		       pi->mode.xres, pi->mode.yres);
+	}
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+#include <asm/setup.h>
+#include <asm/bootm.h>
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	struct tag_serialnr serno;
+	char serno_str[64 / 4 + 1];
+
+	get_board_serial(&serno);
+	snprintf(serno_str, sizeof(serno_str), "%08x%08x",
+		 serno.high, serno.low);
+
+	printf("serial-number: %s\n", serno_str);
+
+	fdt_setprop(blob, 0, "serial-number", serno_str, strlen(serno_str));
+	fsl_fdt_fixup_dr_usb(blob, bd);
+	return 0;
+}
+#endif /* OF_BOARD_SETUP */
diff --git a/board/karo/tx8m/tx8mn.c b/board/karo/tx8m/tx8mn.c
new file mode 100644
index 0000000..59f94cd
--- /dev/null
+++ b/board/karo/tx8m/tx8mn.c
@@ -0,0 +1,918 @@
+/*
+ * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <console.h>
+#include <errno.h>
+#include <fsl_esdhc.h>
+#include <fsl_wdog.h>
+#include <imx_mipi_dsi_bridge.h>
+#include <led.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <mipi_dsi_panel.h>
+#include <mmc.h>
+#include <netdev.h>
+#include <sec_mipi_dsim.h>
+#include <spl.h>
+#include <thermal.h>
+#include <usb.h>
+#include <asm-generic/gpio.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx8mn_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/armv8/mmu.h>
+#include <asm/mach-imx/dma.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/video.h>
+#include <dm/uclass.h>
+#include <power/pmic.h>
+#include "../common/karo.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_HYS |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mn_usdhc1_pads[] = {
+	IMX8MN_PAD_SD1_CLK__USDHC1_CLK | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_CMD__USDHC1_CMD | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_DATA0__USDHC1_DATA0 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_DATA1__USDHC1_DATA1 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_DATA2__USDHC1_DATA2 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_DATA3__USDHC1_DATA3 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_DATA4__USDHC1_DATA4 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_DATA5__USDHC1_DATA5 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_DATA6__USDHC1_DATA6 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_DATA7__USDHC1_DATA7 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD1_STROBE__USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
+	IMX8MN_PAD_SD1_RESET_B__USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mn_usdhc2_pads[] = {
+	IMX8MN_PAD_SD2_CLK__USDHC2_CLK | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD2_CMD__USDHC2_CMD | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD2_DATA0__USDHC2_DATA0 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD2_DATA1__USDHC2_DATA1 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD2_DATA2__USDHC2_DATA2 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD2_DATA3__USDHC2_DATA3 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_SD2_CD_B__GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mn_usdhc3_pads[] = {
+	IMX8MN_PAD_NAND_WE_B__USDHC3_CLK | USDHC_PAD_CTRL,
+	IMX8MN_PAD_NAND_WP_B__USDHC3_CMD | USDHC_PAD_CTRL,
+	IMX8MN_PAD_NAND_DATA04__USDHC3_DATA0 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_NAND_DATA05__USDHC3_DATA1 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_NAND_DATA06__USDHC3_DATA2 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_NAND_DATA07__USDHC3_DATA3 | USDHC_PAD_CTRL,
+	IMX8MN_PAD_NAND_DATA02__GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
+};
+
+static struct tx8m_esdhc_cfg {
+	struct fsl_esdhc_cfg cfg;
+	int clk;
+	const iomux_v3_cfg_t *pads;
+	size_t num_pads;
+	int cd_gpio;
+} tx8mn_sdhc_cfgs[] = {
+	{
+		.cfg = {
+			.esdhc_base = USDHC1_BASE_ADDR,
+			.max_bus_width = 8,
+		},
+		.clk = MXC_ESDHC_CLK,
+		.pads = tx8mn_usdhc1_pads,
+		.num_pads = ARRAY_SIZE(tx8mn_usdhc1_pads),
+		.cd_gpio = -EINVAL,
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC2_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC2_CLK,
+		.pads = tx8mn_usdhc2_pads,
+		.num_pads = ARRAY_SIZE(tx8mn_usdhc2_pads),
+		.cd_gpio = IMX_GPIO_NR(2, 12),
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC3_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC3_CLK,
+		.pads = tx8mn_usdhc3_pads,
+		.num_pads = ARRAY_SIZE(tx8mn_usdhc3_pads),
+		.cd_gpio = IMX_GPIO_NR(3, 8),
+	},
+};
+
+static struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(tx8mn_sdhc_cfgs); i++) {
+		struct tx8m_esdhc_cfg *cfg = &tx8mn_sdhc_cfgs[i];
+
+		if (priv->esdhc_base == cfg->cfg.esdhc_base)
+			return cfg;
+	}
+	return NULL;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
+
+	if (cfg == NULL) {
+		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
+		return 0;
+	}
+	if (cfg->cd_gpio < 0) {
+		debug("%s@%d: 1\n", __func__, __LINE__);
+		return 1;
+	}
+	debug("%s@%d: %d\n", __func__, __LINE__,
+	      !gpio_get_value(cfg->cd_gpio));
+	return !gpio_get_value(cfg->cd_gpio);
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (eMMC)
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+printf("%s@%d: \n", __func__, __LINE__);
+
+	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		struct mmc *mmc;
+		struct tx8m_esdhc_cfg *cfg;
+
+		if (i >= ARRAY_SIZE(tx8mn_sdhc_cfgs)) {
+			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
+			       CONFIG_SYS_FSL_USDHC_NUM,
+			       ARRAY_SIZE(tx8mn_sdhc_cfgs));
+			return -EINVAL;
+		}
+
+		cfg = &tx8mn_sdhc_cfgs[i];
+		if (cfg->cd_gpio >= 0) {
+			gpio_request(cfg->cd_gpio, "MMC CD");
+			gpio_direction_input(cfg->cd_gpio);
+		}
+		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
+		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
+
+		debug("%s@%d: Initialising MMC dev %zu @ %08llx clock=%u\n",
+		      __func__, __LINE__, i,
+		      cfg->cfg.esdhc_base, cfg->cfg.sdhc_clk);
+		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
+		if (ret) {
+			printf("Failed to initialize MMC%zu: %d\n", i, ret);
+			continue;
+		}
+
+		mmc = find_mmc_device(i);
+		if (mmc == NULL) {
+			printf("mmc device %zi not found\n", i);
+			continue;
+		}
+		if (board_mmc_getcd(mmc)) {
+			ret = mmc_init(mmc);
+			if (ret && ret != -EOPNOTSUPP)
+				printf("%s@%d: mmc_init(mmc%zi) failed: %d\n",
+				       __func__, __LINE__, i, ret);
+		} else {
+			debug("No Medium found in MMC slot %zi\n", i);
+		}
+	}
+	return 0;
+}
+#endif /* DM_MMC */
+
+#ifdef CONFIG_USB
+int board_usb_init(int index, enum usb_init_type init)
+{
+printf("%s@%d: \n", __func__, __LINE__);
+	imx8m_usb_power(index, true);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+#define MDIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_DSE6 |	\
+					     PAD_CTL_PE |	\
+					     PAD_CTL_PUE)
+
+#define FEC_IN_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL2)
+
+#define FEC_OUT_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mn_fec_pads[] = {
+	IMX8MN_PAD_ENET_MDC__ENET1_MDC | MDIO_PAD_CTRL, /* 0x146 */
+	IMX8MN_PAD_ENET_MDIO__ENET1_MDIO | MDIO_PAD_CTRL,
+	IMX8MN_PAD_ENET_TD2__ENET1_TX_CLK | MUX_MODE_SION | FEC_IN_PAD_CTRL, /* 0x40000016 */
+	IMX8MN_PAD_ENET_TD0__ENET1_RGMII_TD0 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MN_PAD_ENET_TD1__ENET1_RGMII_TD1 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MN_PAD_ENET_RD0__ENET1_RGMII_RD0 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MN_PAD_ENET_RD1__ENET1_RGMII_RD1 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MN_PAD_ENET_RXC__ENET1_RX_ER | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MN_PAD_ENET_RX_CTL__ENET1_RGMII_RX_CTL | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MN_PAD_ENET_TX_CTL__ENET1_RGMII_TX_CTL | FEC_OUT_PAD_CTRL, /* 0x16 */
+};
+
+#include <fuse.h>
+static int tx8mn_etnphy_init(void)
+{
+	int ret;
+	struct gpio_desc enet0_pwr;
+	struct gpio_desc enet0_rst;
+
+	ret = dm_gpio_lookup_name("gpio1_23", &enet0_pwr);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_lookup_name("gpio1_29", &enet0_rst);
+	if (ret) {
+		printf("Failed to lookup ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_pwr, "ENET0_PWR");
+	if (ret) {
+		printf("Failed to request ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_rst, "ENET0_RST");
+	if (ret) {
+		printf("Failed to request ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	dm_gpio_set_dir_flags(&enet0_rst, GPIOD_IS_OUT);
+	dm_gpio_set_dir_flags(&enet0_pwr, GPIOD_IS_OUT);
+	dm_gpio_set_value(&enet0_rst, 0);
+	dm_gpio_set_value(&enet0_pwr, 1);
+
+	imx_iomux_v3_setup_multiple_pads(tx8mn_fec_pads,
+					 ARRAY_SIZE(tx8mn_fec_pads));
+
+	mdelay(25);
+	dm_gpio_set_value(&enet0_rst, 1);
+	mdelay(10);
+	return 0;
+}
+
+static int tx8mn_setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *iomuxc_gpr_regs =
+		(void *)IOMUXC_GPR_BASE_ADDR;
+	unsigned char mac[6];
+
+	set_clk_enet(ENET_50MHZ);
+
+	/* Use 50M anatop REF_CLK1 for ENET1, not from external */
+	setbits_le32(&iomuxc_gpr_regs->gpr[1],
+		     IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK);
+
+	imx_get_mac_from_fuse(0, mac);
+	printf("MAC addr: %pM\n", mac);
+
+	return tx8mn_etnphy_init();
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#else
+static inline int tx8mn_setup_fec(void)
+{
+	return 0;
+}
+#endif /* FEX_MXC */
+
+int dram_init(void)
+{
+	printf("%s@%d: \n", __func__, __LINE__);
+
+	/* rom_pointer[1] contains the size of RAM occupied by TEE */
+	if (rom_pointer[1])
+		gd->ram_size = PHYS_SDRAM_SIZE -
+			ALIGN(rom_pointer[1], PAGE_SIZE);
+	else
+		gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+int board_fix_fdt(void *blob)
+{
+	printf("%s@%d: \n", __func__, __LINE__);
+	return 0;
+}
+
+#define GPIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mn_gpio_pads[] = {
+	IMX8MN_PAD_SD2_RESET_B__GPIO2_IO19 | GPIO_PAD_CTRL,
+};
+
+#ifdef CONFIG_SHOW_ACTIVITY
+enum {
+	LED_STATE_INIT = -1,
+	LED_STATE_OFF,
+	LED_STATE_ON,
+	LED_STATE_DISABLED,
+};
+
+static int led_state = LED_STATE_DISABLED;
+static bool tx8m_temp_check_enabled = true;
+static struct udevice *leddev;
+static struct udevice *thermaldev;
+
+#define TEMPERATURE_HOT		80
+#define TEMPERATURE_MIN		-40
+
+static inline int calc_blink_rate(void)
+{
+	int cpu_temp;
+	static int last_temp = INT_MAX;
+	static int avg_count;
+
+	if (!tx8m_temp_check_enabled)
+		return CONFIG_SYS_HZ;
+
+	if (!thermaldev || thermal_get_temp(thermaldev, &cpu_temp))
+		return CONFIG_SYS_HZ / 2;
+
+	if (last_temp == INT_MAX) {
+		last_temp = cpu_temp;
+	} else if (cpu_temp != last_temp) {
+		static int cpu_temps[4];
+
+		if (thermal_get_temp(thermaldev, &cpu_temps[avg_count]))
+			return CONFIG_SYS_HZ / 2;
+		if (++avg_count >= ARRAY_SIZE(cpu_temps)) {
+			int bad = -1;
+			int i;
+
+			for (i = 0; i < avg_count; i++) {
+				if (cpu_temp != cpu_temps[i])
+					bad = i;
+			}
+			if (bad < 0) {
+				debug("CPU temperature changed from %d to %d\n",
+				      last_temp, cpu_temp);
+				last_temp = cpu_temp;
+			} else {
+				debug("Spurious CPU temperature reading %d -> %d -> %d\n",
+				      cpu_temp, cpu_temps[bad],
+				      cpu_temps[i - 1]);
+			}
+			avg_count = 0;
+		}
+	} else {
+		avg_count = 0;
+	}
+	return CONFIG_SYS_HZ + CONFIG_SYS_HZ / 10 -
+		(last_temp - TEMPERATURE_MIN) * CONFIG_SYS_HZ /
+		(TEMPERATURE_HOT - TEMPERATURE_MIN);
+}
+
+void show_activity(int arg)
+{
+	static int blink_rate;
+	static ulong last;
+	int ret;
+
+	if (led_state == LED_STATE_DISABLED)
+		return;
+
+	if (led_state == LED_STATE_INIT) {
+		last = get_timer(0);
+		ret = led_set_state(leddev, LEDST_ON);
+		if (ret == 0)
+			led_state = LED_STATE_ON;
+		else
+			led_state = LED_STATE_DISABLED;
+		blink_rate = calc_blink_rate();
+	} else {
+		if (get_timer(last) > blink_rate) {
+			blink_rate = calc_blink_rate();
+			last = get_timer(0);
+			if (led_state == LED_STATE_ON) {
+				ret = led_set_state(leddev, LEDST_OFF);
+			} else {
+				ret = led_set_state(leddev, LEDST_ON);
+			}
+			if (ret == 0)
+				led_state = 1 - led_state;
+			else
+				led_state = LED_STATE_DISABLED;
+		}
+	}
+
+}
+
+static void tx8m_led_init(void)
+{
+	int ret;
+
+	printf("%s@%d: \n", __func__, __LINE__);
+	ret = led_get_by_label("Heartbeat", &leddev);
+	if (ret) {
+		printf("Failed to find LED device: %d\n", ret);
+		return;
+	}
+
+	ret = uclass_get_device_by_name(UCLASS_THERMAL, "cpu-thermal",
+					&thermaldev);
+	if (ret)
+		printf("Failed to find THERMAL device: %d\n", ret);
+
+	led_state = LED_STATE_INIT;
+}
+#else
+static inline void tx8m_led_init(void)
+{
+	debug("%s@%d: \n", __func__, __LINE__);
+}
+#endif /* SHOW_ACTIVITY */
+
+int checkboard(void)
+{
+#if defined(CONFIG_KARO_QS8M)
+	printf("Board: Ka-Ro QS8M-ND00\n");
+#elif defined(CONFIG_KARO_TX8MN)
+	printf("Board: Ka-Ro TX8M-ND00\n");
+#else
+#error Unsupported module variant
+#endif
+	ctrlc();
+	return 0;
+}
+
+#ifdef CONFIG_DM_I2C
+static inline int tx8mn_i2c_init(void)
+{
+	int ret = 0;
+	int i;
+
+	for (i = 0; ret != -ENODEV; i++) {
+		struct udevice *i2c_dev;
+		u8 i2c_addr;
+
+		ret = uclass_get_device_by_seq(UCLASS_I2C, i, &i2c_dev);
+		if (ret == -ENODEV)
+			break;
+
+		for (i2c_addr = 0x07; i2c_addr < 0x78; i2c_addr++) {
+			struct udevice *chip;
+
+			ret = dm_i2c_probe(i2c_dev, i2c_addr, 0x0, &chip);
+			if (ret == 0) {
+				printf("Found an I2C device @ %u:%02x\n",
+				       i, i2c_addr);
+			} else if (ret != -EREMOTEIO) {
+				printf("Error %d accessing device %u:%02x\n",
+				       ret, i, i2c_addr);
+				break;
+			}
+		}
+	}
+	return ret;
+}
+#else
+static int tx8mn_i2c_init(void)
+{
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	int ret;
+	struct gpio_desc reset_out;
+
+	printf("%s@%d: \n", __func__, __LINE__);
+	tx8mn_setup_fec();
+
+	//tx8mn_i2c_init();
+
+	ret = dm_gpio_lookup_name("gpio2_19", &reset_out);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+	ret = dm_gpio_request(&reset_out, "RESET_OUT");
+	if (ret) {
+		printf("Failed to request RESET_OUT GPIO: %d\n", ret);
+		return ret;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(tx8mn_gpio_pads,
+					 ARRAY_SIZE(tx8mn_gpio_pads));
+	tx8m_led_init();
+	return ret;
+}
+
+#ifdef CONFIG_BOARD_EARLY_INIT_R
+int board_early_init_r(void)
+{
+	if (ctrlc())
+		printf("<CTRL-C> detected; safeboot enabled\n");
+	return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+	int ret;
+	struct src *src_regs = (void *)SRC_BASE_ADDR;
+	struct watchdog_regs *wdog = (void *)WDOG1_BASE_ADDR;
+	u32 srsr = readl(&src_regs->srsr);
+	u16 wrsr = readw(&wdog->wrsr);
+	const char *fdt_file = env_get("fdt_file");
+
+	printf("%s@%d: \n", __func__, __LINE__);
+	karo_env_cleanup();
+	if (srsr & 0x10 && !(wrsr & WRSR_SFTW)) {
+		printf("Watchog reset detected; reboot required!\n");
+		env_set("wdreset", "1");
+	}
+	if (had_ctrlc()) {
+		env_set("safeboot", "1");
+		fdt_file = NULL;
+	}
+	if (fdt_file) {
+		ret = karo_load_fdt(fdt_file);
+		if (ret)
+			printf("Failed to load FDT from '%s': %d\n",
+			       fdt_file, ret);
+	}
+	clear_ctrlc();
+	return 0;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 1;
+}
+
+void board_quiesce_devices(void)
+{
+}
+
+#ifdef CONFIG_VIDEO
+static const struct sec_mipi_dsim_plat_data imx8mn_mipi_dsim_plat_data = {
+	.version	= 0x1060200,
+	.max_data_lanes = 4,
+	.max_data_rate  = 1500000000ULL,
+	.reg_base = MIPI_DSI_BASE_ADDR,
+	.gpr_base = CSI_BASE_ADDR + 0x8000,
+};
+
+#define DSI_DDR_MODE 0
+
+struct mipi_dsi_client_dev dsi83_dev = {
+	.channel = 0,
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+	.name = "DSI83",
+};
+
+#define DISPLAY_MIX_SFT_RSTN_CSR	0x00
+#define DISPLAY_MIX_CLK_EN_CSR		0x04
+
+/* 'DISP_MIX_SFT_RSTN_CSR' bit fields */
+#define BUS_RSTN_BLK_SYNC_SFT_EN	BIT(8)
+#define LCDIF_APB_CLK_RSTN		BIT(5)
+#define LCDIF_PIXEL_CLK_RSTN		BIT(4)
+
+/* 'DISP_MIX_CLK_EN_CSR' bit fields */
+#define BUS_BLK_CLK_SFT_EN		BIT(8)
+#define LCDIF_APB_CLK_SFT_EN		BIT(5)
+#define LCDIF_PIXEL_CLK_SFT_EN		BIT(4)
+
+static void disp_mix_bus_rstn_reset(ulong gpr_base, bool reset)
+{
+	if (!reset)
+		/* release reset */
+		setbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
+			     BUS_RSTN_BLK_SYNC_SFT_EN | LCDIF_APB_CLK_RSTN |
+			     LCDIF_PIXEL_CLK_RSTN);
+	else
+		/* hold reset */
+		clrbits_le32(gpr_base + DISPLAY_MIX_SFT_RSTN_CSR,
+			     BUS_RSTN_BLK_SYNC_SFT_EN | LCDIF_APB_CLK_RSTN |
+			     LCDIF_PIXEL_CLK_RSTN);
+
+}
+
+static void disp_mix_lcdif_clks_enable(ulong gpr_base, bool enable)
+{
+	if (enable)
+		/* enable lcdif clks */
+		setbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
+			     BUS_BLK_CLK_SFT_EN | LCDIF_PIXEL_CLK_SFT_EN |
+			     LCDIF_APB_CLK_SFT_EN);
+	else
+		/* disable lcdif clks */
+		clrbits_le32(gpr_base + DISPLAY_MIX_CLK_EN_CSR,
+			     BUS_BLK_CLK_SFT_EN | LCDIF_PIXEL_CLK_SFT_EN |
+			     LCDIF_APB_CLK_SFT_EN);
+}
+
+#define LINE_LENGTH	1280
+#define H_FRONT_PORCH	64
+#define H_BACK_PORCH	4
+#define HSYNC_LEN	1
+#define VERT_SIZE	800
+#define V_FRONT_PORCH	40
+#define V_BACK_PORCH	1
+#define VSYNC_LEN	1
+#define VREFRESH	60
+
+#define BPP	24
+#define SYNC_DELAY	64
+#define HTOTAL		(HSYNC_LEN + H_BACK_PORCH + LINE_LENGTH + H_FRONT_PORCH)
+#define VTOTAL		(VSYNC_LEN + V_BACK_PORCH + VERT_SIZE + V_FRONT_PORCH)
+#define PCLK		(HTOTAL * VTOTAL * VREFRESH)
+#define DSI_CLK		(PCLK * BPP / 4 / (!!DSI_DDR_MODE + 1))
+#define DSI_CLK_DIV	((DSI_CLK + PCLK - 1) / PCLK)
+#define LVDS_CLK	(DSI_CLK / DSI_CLK_DIV)
+#define LVDS_CLK_DIV	((LVDS_CLK + 12500000) / 25000000 - 1)
+
+static struct dsi83_data {
+	u8 addr;
+	u8 val;
+	u8 mask;
+} dsi83_data[] = {
+	{ 0x09, 1, },
+	{ 0x0d, 0x00, 0x01, },
+	{ 0x10, 0x00, 0x18, }, // DSI lanes 0x00: 4 lanes; 0x08: 3 lanes
+	{ 0x10, 0x00, 0x01, }, // SOT_ERR_TOL_DIS
+	{ 0x11, 0xc0, 0xc0, }, // DSI DATA equalization
+	{ 0x11, 0x0c, 0x0c, }, // DSI clock equalization
+	{ 0x12, DSI_CLK / 1000000 / 5, }, // DSI clk range 8: 40..45MHz; 9: 45..50MHz; ...
+	{ 0x0a, 0x01, 0x01, },
+	{ 0x0a, LVDS_CLK_DIV << 1, 0x0e, },
+	{ 0x0b, 0x00, 0x03, },
+	{ 0x0b, (DSI_CLK_DIV - 1) << 3, 0x7c, },
+	{ 0x18, 0x60, 0xe0, }, // DE_NEG HS_NEG VS_NEG
+	{ 0x18, 0x08, 0x9, }, // CHA_24BPP_MODE CHA24BPP_FORMAT1
+	{ 0x20, LINE_LENGTH % 256, },
+	{ 0x21, LINE_LENGTH / 256, },
+	{ 0x24, VERT_SIZE % 256, },
+	{ 0x25, VERT_SIZE / 256, },
+	{ 0x28, SYNC_DELAY % 256, },
+	{ 0x29, SYNC_DELAY / 256, },
+	{ 0x2c, HSYNC_LEN % 256, },
+	{ 0x2d, HSYNC_LEN / 256, },
+	{ 0x30, VSYNC_LEN % 256, },
+	{ 0x31, VSYNC_LEN / 256, },
+	{ 0x34, H_BACK_PORCH + HSYNC_LEN, },
+	{ 0x36, V_BACK_PORCH + VSYNC_LEN, },
+	{ 0x38, H_FRONT_PORCH, },
+	{ 0x3a, V_FRONT_PORCH, },
+	//{ 0x3c, 0x10, 0x10, }, // enable CHA_TEST_PATTERN
+	{ 0x3c, 0x00, },
+	{ 0x0d, 0x01, 0x01, }, // enable PLL
+	{ 0xe5, 0xfd, 0xfd, }, // clear error status
+};
+
+#define DSI83_SLAVE_ADDR	0x2c
+
+static int dsi83_init(void)
+{
+	int ret;
+	struct udevice *dev;
+	struct udevice *chip;
+	u8 val;
+
+	debug("DSI clock: %u.%03uMHz dsi_clk_div=%u\n",
+	      DSI_CLK / 1000000, DSI_CLK / 1000 % 1000, DSI_CLK_DIV);
+	debug("LVDS clock: %u.%03uMHz lvds_clk_range=%u\n",
+	      LVDS_CLK / 1000000, LVDS_CLK / 1000 % 1000, LVDS_CLK_DIV);
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, 1, &dev);
+	if (ret) {
+		printf("%s: Failed to find I2C bus device: %d\n",
+		       __func__, ret);
+		return ret;
+	}
+	ret = dm_i2c_probe(dev, DSI83_SLAVE_ADDR, 0x0, &chip);
+	if (ret) {
+		printf("%s: I2C probe failed for slave addr %02x: %d\n",
+		       __func__, DSI83_SLAVE_ADDR, ret);
+		return ret;
+	}
+	for (size_t i = 0; i < ARRAY_SIZE(dsi83_data); i++) {
+		struct dsi83_data *p = &dsi83_data[i];
+
+		ret = dm_i2c_read(chip, p->addr, &val, 1);
+		if (ret) {
+			printf("%s: Failed to read reg %02x\n",
+			       __func__, p->val);
+			return ret;
+		}
+		debug("%s@%d: Read %02x from reg %02x\n",
+		      __func__, __LINE__, val, p->addr);
+		val = (val & ~p->mask) | p->val;
+		debug("%s@%d: Writing %02x to reg %02x\n",
+		      __func__, __LINE__, val, p->addr);
+		ret = dm_i2c_write(chip, p->addr, &val, 1);
+		if (ret) {
+			printf("%s: Failed to write %02x to reg %02x\n",
+			       __func__, p->val, p->addr);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static const iomux_v3_cfg_t tx8mn_lcd_pads[] = {
+	IMX8MN_PAD_GPIO1_IO01__GPIO1_IO1 | GPIO_PAD_CTRL,
+	IMX8MN_PAD_GPIO1_IO04__GPIO1_IO4 | GPIO_PAD_CTRL,
+};
+
+static void tx8m_backlight_enable(void)
+{
+	int ret;
+	struct gpio_desc backlight_control;
+	struct gpio_desc lcd_enable;
+
+	ret = dm_gpio_lookup_name("gpio1_1", &backlight_control);
+	if (ret == 0) {
+		ret = dm_gpio_request(&backlight_control, "BACKLIGHT_CONTROL");
+		if (ret == 0) {
+			dm_gpio_set_dir_flags(&backlight_control, GPIOD_IS_OUT);
+			dm_gpio_set_value(&backlight_control, 1);
+		} else {
+			printf("Failed to request BACKLIGHT_CONTROL GPIO: %d\n",
+			       ret);
+		}
+	} else {
+		printf("Failed to lookup BACKLIGHT_CONTROL GPIO: %d\n", ret);
+	}
+
+	ret = dm_gpio_lookup_name("gpio1_4", &lcd_enable);
+	if (ret == 0) {
+		ret = dm_gpio_request(&lcd_enable, "LCD_ENABLE");
+		if (ret == 0) {
+			dm_gpio_set_dir_flags(&lcd_enable, GPIOD_IS_OUT);
+			dm_gpio_set_value(&lcd_enable, 1);
+		} else {
+			printf("Failed to request LCD_ENABLE GPIO: %d\n", ret);
+		}
+	} else {
+		printf("Failed to lookup LCD_ENABLE GPIO: %d\n", ret);
+	}
+
+	imx_iomux_v3_setup_multiple_pads(tx8mn_lcd_pads,
+					 ARRAY_SIZE(tx8mn_lcd_pads));
+}
+
+#define FSL_SIP_GPC			0xC2000000
+#define FSL_SIP_CONFIG_GPC_PM_DOMAIN	0x3
+#define DISPMIX				9
+#define MIPI				10
+
+static void do_enable_mipi2lvds(struct display_info_t const *disp)
+{
+	/* enable the dispmix & mipi phy power domain */
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
+		     DISPMIX, true, 0);
+	call_imx_sip(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN,
+		     MIPI, true, 0);
+
+	/* Get lcdif out of reset */
+	disp_mix_bus_rstn_reset(imx8mn_mipi_dsim_plat_data.gpr_base, false);
+	disp_mix_lcdif_clks_enable(imx8mn_mipi_dsim_plat_data.gpr_base, true);
+
+	sec_mipi_dsim_setup(&imx8mn_mipi_dsim_plat_data);
+	imx_mipi_dsi_bridge_attach(&dsi83_dev);
+	dsi83_init();
+	tx8m_backlight_enable();
+}
+
+static struct display_info_t const panel_info[] = {
+	{
+		.bus = LCDIF_BASE_ADDR,
+		.pixfmt = BPP,
+		.enable	= do_enable_mipi2lvds,
+		.mode	= {
+			.name		= "MIPI2LVDS",
+			.refresh	= VREFRESH,
+			.xres		= LINE_LENGTH,
+			.yres		= VERT_SIZE,
+			.pixclock	= KHZ2PICOS(PCLK / 1000),
+			.left_margin	= H_BACK_PORCH,
+			.hsync_len	= HSYNC_LEN,
+			.right_margin	= H_FRONT_PORCH,
+			.upper_margin	= V_BACK_PORCH,
+			.vsync_len	= VSYNC_LEN,
+			.lower_margin	= V_FRONT_PORCH,
+			.sync		= FB_SYNC_EXT,
+			.vmode		= FB_VMODE_NONINTERLACED,
+		},
+	},
+};
+
+int board_video_skip(void)
+{
+	int ret;
+	const char *baseboard = env_get("baseboard");
+	const char *panel = env_get("panel");
+	size_t i;
+
+	printf("%s@%d: baseboard='%s' panel='%s'\n", __func__, __LINE__,
+	       baseboard, panel);
+
+	if (had_ctrlc()) {
+		printf("<CTRL-C> detected; disabling display\n");
+		return 1;
+	}
+
+	if (!panel) {
+		printf("No LCD panel configured\n");
+		return 1;
+	}
+
+	if (!baseboard || strcmp(baseboard, "mipi-mb") != 0) {
+		printf("No Display support for '%s' baseboard\n",
+		       baseboard ?: "unspecified");
+		return 1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(panel_info); i++) {
+		const struct display_info_t *pi = &panel_info[i];
+
+		if (strcmp(panel, pi->mode.name) != 0)
+			continue;
+
+		ret = mxs_lcd_panel_setup(pi->mode,
+					  pi->pixfmt,
+					  pi->bus);
+		if (ret)
+			return ret;
+
+		if (pi->enable)
+			pi->enable(panel_info + i);
+
+		printf("Display: %s (%ux%u)\n", pi->mode.name,
+		       pi->mode.xres, pi->mode.yres);
+	}
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+#include <asm/setup.h>
+#include <asm/bootm.h>
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	struct tag_serialnr serno;
+	char serno_str[64 / 4 + 1];
+
+	get_board_serial(&serno);
+	snprintf(serno_str, sizeof(serno_str), "%08x%08x",
+		 serno.high, serno.low);
+
+	printf("serial-number: %s\n", serno_str);
+
+	fdt_setprop(blob, 0, "serial-number", serno_str, strlen(serno_str));
+	fsl_fdt_fixup_dr_usb(blob, bd);
+	return 0;
+}
+#endif /* OF_BOARD_SETUP */
diff --git a/configs/tx8m-1610_defconfig b/configs/tx8m-1610_defconfig
index 2255f60..ed80beb 100644
--- a/configs/tx8m-1610_defconfig
+++ b/configs/tx8m-1610_defconfig
@@ -40,7 +40,7 @@ CONFIG_SPL_USB_HOST_SUPPORT=y
 CONFIG_SPL_USB_GADGET_SUPPORT=y
 CONFIG_SPL_USB_SDP_SUPPORT=y
 CONFIG_HUSH_PARSER=y
-CONFIG_SYS_PROMPT="TX8M U-Boot > "
+CONFIG_SYS_PROMPT="TX8MM U-Boot > "
 CONFIG_CMD_MEMTEST=y
 CONFIG_CMD_CLK=y
 # CONFIG_CMD_FLASH is not set
diff --git a/configs/tx8m-1610_mfg_defconfig b/configs/tx8m-1610_mfg_defconfig
index 871a3e7..347cb2e0 100644
--- a/configs/tx8m-1610_mfg_defconfig
+++ b/configs/tx8m-1610_mfg_defconfig
@@ -6,7 +6,7 @@ CONFIG_SPL_LIBCOMMON_SUPPORT=y
 CONFIG_SPL_LIBGENERIC_SUPPORT=y
 CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TARGET_TX8M=y
-CONFIG_TX8MM_UBOOT_MFG=y
+CONFIG_TX8M_UBOOT_MFG=y
 CONFIG_SPL_MMC_SUPPORT=y
 CONFIG_SPL_SERIAL_SUPPORT=y
 CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
@@ -29,6 +29,7 @@ CONFIG_PRE_CON_BUF_ADDR=0x93F000
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 CONFIG_DEFAULT_FDT_FILE="imx8mm-tx8m-1610.dtb"
 CONFIG_VERSION_VARIABLE=y
+CONFIG_ARCH_MISC_INIT=y
 CONFIG_SPL=y
 CONFIG_SPL_BOARD_INIT=y
 CONFIG_SPL_RAW_IMAGE_SUPPORT=y
@@ -39,7 +40,7 @@ CONFIG_SPL_POWER_SUPPORT=y
 CONFIG_SPL_USB_HOST_SUPPORT=y
 CONFIG_SPL_USB_GADGET_SUPPORT=y
 CONFIG_SPL_USB_SDP_SUPPORT=y
-CONFIG_SYS_PROMPT="TX8M U-Boot > "
+CONFIG_SYS_PROMPT="TX8MM U-Boot > "
 CONFIG_FASTBOOT=y
 CONFIG_FSL_FASTBOOT=y
 CONFIG_FASTBOOT_BUF_ADDR=0x42800000
diff --git a/configs/tx8m-1610_noenv_defconfig b/configs/tx8m-1610_noenv_defconfig
index aa5fb3a..0769dc3 100644
--- a/configs/tx8m-1610_noenv_defconfig
+++ b/configs/tx8m-1610_noenv_defconfig
@@ -6,7 +6,7 @@ CONFIG_SPL_LIBCOMMON_SUPPORT=y
 CONFIG_SPL_LIBGENERIC_SUPPORT=y
 CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TARGET_TX8M=y
-CONFIG_TX8MM_UBOOT_NOENV=y
+CONFIG_TX8M_UBOOT_NOENV=y
 CONFIG_SPL_MMC_SUPPORT=y
 CONFIG_SPL_SERIAL_SUPPORT=y
 CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
@@ -39,7 +39,7 @@ CONFIG_SPL_POWER_SUPPORT=y
 CONFIG_SPL_USB_HOST_SUPPORT=y
 CONFIG_SPL_USB_GADGET_SUPPORT=y
 CONFIG_SPL_USB_SDP_SUPPORT=y
-CONFIG_SYS_PROMPT="TX8M U-Boot > "
+CONFIG_SYS_PROMPT="TX8MM U-Boot > "
 CONFIG_CMD_MEMTEST=y
 CONFIG_CMD_CLK=y
 # CONFIG_CMD_FLASH is not set
diff --git a/configs/tx8m-nd00_defconfig b/configs/tx8m-nd00_defconfig
new file mode 100644
index 0000000..d84729d
--- /dev/null
+++ b/configs/tx8m-nd00_defconfig
@@ -0,0 +1,107 @@
+CONFIG_ARM=y
+CONFIG_ARCH_IMX8M=y
+CONFIG_SYS_TEXT_BASE=0x40200000
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_TX8M=y
+CONFIG_KARO_TX8MN=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_DEFAULT_DEVICE_TREE="imx8mn-tx8m-nd00"
+CONFIG_ENV_VARS_UBOOT_CONFIG=y
+CONFIG_FIT=y
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/mach-imx/spl_sd.cfg,SPL_TEXT_BASE=0x912000"
+CONFIG_SD_BOOT=y
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTCOMMAND=y
+CONFIG_BOOTCOMMAND="run bootargs_${boot_mode} bootm_cmd"
+CONFIG_PRE_CONSOLE_BUFFER=y
+CONFIG_PRE_CON_BUF_ADDR=0x93F000
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_DEFAULT_FDT_FILE="imx8mn-tx8m-nd00.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_SPL=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_RAW_IMAGE_SUPPORT=y
+CONFIG_SPL_DISABLE_BANNER_PRINT=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x2c0
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_POWER_SUPPORT=y
+CONFIG_SPL_USB_HOST_SUPPORT=y
+CONFIG_SPL_USB_GADGET_SUPPORT=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="TX8MN U-Boot > "
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_GPT_RENAME=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_READ=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION_ENTRIES_OFF=2048
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_BOOTP_DNS=y
+CONFIG_BOOTP_GATEWAY=y
+CONFIG_BOOTP_SUBNETMASK=y
+CONFIG_DM_GPIO=y
+CONFIG_MXC_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MXC=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_MXC_OCOTP=y
+CONFIG_PHY_SMSC=y
+CONFIG_DM_ETH=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX8M=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_THERMAL=y
+CONFIG_NXP_TMU=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_VBUS_DRAW=60
+CONFIG_SDP_LOADADDR=0x40400000
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_VIDEO=y
+CONFIG_IMX_SEC_MIPI_DSI=y
+CONFIG_SYS_CONSOLE_BG_COL=0xc0
+CONFIG_SYS_CONSOLE_FG_COL=0x10
+CONFIG_FAT_WRITE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+# CONFIG_EFI_LOADER is not set
diff --git a/configs/tx8m-nd00_mfg_defconfig b/configs/tx8m-nd00_mfg_defconfig
new file mode 100644
index 0000000..f76b66c
--- /dev/null
+++ b/configs/tx8m-nd00_mfg_defconfig
@@ -0,0 +1,110 @@
+CONFIG_ARM=y
+CONFIG_ARCH_IMX8M=y
+CONFIG_SYS_TEXT_BASE=0x40200000
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_TX8M=y
+CONFIG_KARO_TX8MN=y
+CONFIG_TX8M_UBOOT_MFG=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_DEFAULT_DEVICE_TREE="imx8mn-tx8m-nd00"
+CONFIG_ENV_VARS_UBOOT_CONFIG=y
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/mach-imx/spl_sd.cfg,SPL_TEXT_BASE=0x912000"
+CONFIG_SD_BOOT=y
+CONFIG_BOOTDELAY=0
+CONFIG_USE_BOOTCOMMAND=y
+CONFIG_BOOTCOMMAND="run bootargs_${boot_mode} bootm_cmd"
+CONFIG_PRE_CONSOLE_BUFFER=y
+CONFIG_PRE_CON_BUF_ADDR=0x93F000
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_DEFAULT_FDT_FILE="imx8mn-tx8m-nd00.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_SPL=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_RAW_IMAGE_SUPPORT=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x2c0
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_POWER_SUPPORT=y
+CONFIG_SPL_USB_HOST_SUPPORT=y
+CONFIG_SPL_USB_GADGET_SUPPORT=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_SYS_PROMPT="TX8MN U-Boot > "
+CONFIG_FASTBOOT=y
+CONFIG_FSL_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x42800000
+CONFIG_FASTBOOT_BUF_SIZE=0x40000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+# CONFIG_CMD_ELF is not set
+# CONFIG_CMD_XIMG is not set
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_GPT_RENAME=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_READ=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION_ENTRIES_OFF=2048
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_BOOTP_DNS=y
+CONFIG_BOOTP_GATEWAY=y
+CONFIG_BOOTP_SUBNETMASK=y
+CONFIG_DM_GPIO=y
+CONFIG_MXC_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MXC=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_MXC_OCOTP=y
+CONFIG_PHY_SMSC=y
+CONFIG_DM_ETH=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX8M=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_THERMAL=y
+CONFIG_NXP_TMU=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_VBUS_DRAW=60
+CONFIG_SDP_LOADADDR=0x40400000
+CONFIG_FAT_WRITE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+# CONFIG_EFI_LOADER is not set
diff --git a/configs/tx8m-nd00_noenv_defconfig b/configs/tx8m-nd00_noenv_defconfig
new file mode 100644
index 0000000..5d11e80
--- /dev/null
+++ b/configs/tx8m-nd00_noenv_defconfig
@@ -0,0 +1,102 @@
+CONFIG_ARM=y
+CONFIG_ARCH_IMX8M=y
+CONFIG_SYS_TEXT_BASE=0x40200000
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_TX8M=y
+CONFIG_KARO_TX8MN=y
+CONFIG_TX8M_UBOOT_NOENV=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_DEFAULT_DEVICE_TREE="imx8mn-tx8m-nd00"
+CONFIG_ENV_VARS_UBOOT_CONFIG=y
+CONFIG_FIT=y
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/mach-imx/spl_sd.cfg,SPL_TEXT_BASE=0x912000"
+CONFIG_SD_BOOT=y
+CONFIG_BOOTDELAY=-1
+CONFIG_USE_BOOTCOMMAND=y
+CONFIG_BOOTCOMMAND="run bootargs_${boot_mode} bootm_cmd"
+CONFIG_PRE_CONSOLE_BUFFER=y
+CONFIG_PRE_CON_BUF_ADDR=0x93F000
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_DEFAULT_FDT_FILE="imx8mn-tx8m-nd00.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_SPL=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_RAW_IMAGE_SUPPORT=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x2c0
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_POWER_SUPPORT=y
+CONFIG_SPL_USB_HOST_SUPPORT=y
+CONFIG_SPL_USB_GADGET_SUPPORT=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_SYS_PROMPT="TX8MN U-Boot > "
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_GPT_RENAME=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_READ=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION_ENTRIES_OFF=2048
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_BOOTP_DNS=y
+CONFIG_BOOTP_GATEWAY=y
+CONFIG_BOOTP_SUBNETMASK=y
+CONFIG_DM_GPIO=y
+CONFIG_MXC_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MXC=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_MXC_OCOTP=y
+CONFIG_PHY_SMSC=y
+CONFIG_DM_ETH=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX8M=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_THERMAL=y
+CONFIG_NXP_TMU=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_VBUS_DRAW=60
+CONFIG_SDP_LOADADDR=0x40400000
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_FAT_WRITE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+# CONFIG_EFI_LOADER is not set
diff --git a/include/configs/tx8m.h b/include/configs/tx8m.h
index 769711c..c613759 100644
--- a/include/configs/tx8m.h
+++ b/include/configs/tx8m.h
@@ -168,7 +168,7 @@
 #if defined(CONFIG_KARO_TX8MM)
 #define PHYS_SDRAM_SIZE			SZ_1G
 #elif defined(CONFIG_KARO_TX8MN)
-#define PHYS_SDRAM_SIZE			SZ_1G
+#define PHYS_SDRAM_SIZE			SZ_512M
 #elif defined(CONFIG_KARO_QS8M)
 #define PHYS_SDRAM_SIZE			SZ_512M
 #else
-- 
2.7.4

