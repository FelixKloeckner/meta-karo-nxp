diff --git a/arch/arm64/boot/dts/freescale/imx8mm-qs8m-mq00-qsbase2-raspi-display.dts b/arch/arm64/boot/dts/freescale/imx8mm-qs8m-mq00-qsbase2-raspi-display.dts
new file mode 100644
index 00000000..a536cf9
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mm-qs8m-mq00-qsbase2-raspi-display.dts
@@ -0,0 +1,70 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2019 Markus Bauer <MB@KARO-electronics.de>
+ *
+ */
+
+/dts-v1/;
+
+#include "imx8mm-qs8m-mq00-qsbase2.dts"
+
+/ {
+	model = "Ka-Ro electronics QS8M-MQ00 (NXP i.MX8MM) Module on QSBASE2 baseboard with Raspi 7-inch Display";
+};
+
+&gpu {
+	status = "okay";
+};
+
+&i2c2 {
+	rpi_display: rpi_display@45 {
+		compatible = "rpi_display";
+		reg = <0x45>;
+	};
+
+	rpi_ft5406: rpi_ft5406@38 {
+		compatible = "rpi_ft5406";
+		reg = <0x38>;
+	};
+};
+
+&lcdif {
+        status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	panel@0 {
+		compatible = "rpi,tc358762";
+		reg = <0>;
+		dsi-lanes = <1>;
+		video-mode = <2>;
+		panel-width-mm = <154>;
+		panel-height-mm = <86>;
+
+		port {
+			panel1_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_out>;
+			};
+		};
+	};
+
+	port@1 {
+		mipi_dsi_bridge_out: endpoint {
+			remote-endpoint = <&panel1_in>;
+		};
+	};
+};
+
+&vpu_g1 {
+	status = "okay";
+};
+
+&vpu_g2 {
+	status = "okay";
+};
+
+&vpu_h1 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mm-qs8m-mq00.dts b/arch/arm64/boot/dts/freescale/imx8mm-qs8m-mq00.dts
index ca127ee..fbfafb1 100644
--- a/arch/arm64/boot/dts/freescale/imx8mm-qs8m-mq00.dts
+++ b/arch/arm64/boot/dts/freescale/imx8mm-qs8m-mq00.dts
@@ -11,7 +11,7 @@
 
 / {
 	model = "Ka-Ro electronics QS8M-MQ00 (NXP i.MX8MM) Module";
-	compatible = "karo,imx8mm-tx8m", "fsl,imx8mm";
+	compatible = "karo,imx8mm-qs8m", "fsl,imx8mm";
 
 	aliases {
 		usb-host = &usbotg2;
diff --git a/drivers/Makefile b/drivers/Makefile
index 77fbc52..42ed93f 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -61,6 +61,10 @@ obj-y				+= char/
 # iommu/ comes before gpu as gpu are using iommu controllers
 obj-$(CONFIG_IOMMU_SUPPORT)	+= iommu/
 
+# i2c and misc after media
+obj-y				+= i2c/
+obj-y				+= misc/
+
 # gpu/ comes after char for AGP vs DRM startup and after iommu
 obj-y				+= gpu/
 
@@ -72,7 +76,7 @@ obj-$(CONFIG_FB_INTEL)          += video/fbdev/intelfb/
 
 obj-$(CONFIG_PARPORT)		+= parport/
 obj-$(CONFIG_NVM)		+= lightnvm/
-obj-y				+= base/ block/ misc/ mfd/ nfc/
+obj-y				+= base/ block/ mfd/ nfc/
 obj-$(CONFIG_LIBNVDIMM)		+= nvdimm/
 obj-$(CONFIG_DAX)		+= dax/
 obj-$(CONFIG_DMA_SHARED_BUFFER) += dma-buf/
@@ -113,7 +117,7 @@ obj-$(CONFIG_SERIO)		+= input/serio/
 obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
-obj-y				+= i2c/ media/
+obj-y				+= media/
 obj-$(CONFIG_PPS)		+= pps/
 obj-y				+= ptp/
 obj-$(CONFIG_W1)		+= w1/
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index c5da7b5..be3d0c1 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -3,6 +3,7 @@
 # Makefile for the drm device driver.  This driver provides support for the
 # Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
 
+subdir-ccflags-y += -DDEBUG
 drm-y       :=	drm_auth.o drm_bufs.o drm_cache.o \
 		drm_context.o drm_dma.o \
 		drm_file.o drm_gem.o drm_ioctl.o drm_irq.o \
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 9e4a7b5..b1686dc 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -104,6 +104,15 @@ config DRM_SII902X
 	---help---
 	  Silicon Image sii902x bridge chip driver.
 
+config DRM_TOSHIBA_TC358762
+	tristate "Toshiba TC358762 DSI to parallel bridge"
+	depends on OF
+	select DRM_KMS_HELPER
+	select REGMAP_I2C
+	select DRM_PANEL
+	---help---
+	  Toshiba TC358762 bridge chip driver.
+
 config DRM_TOSHIBA_TC358767
 	tristate "Toshiba TC358767 eDP bridge"
 	depends on OF
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 053905a..8890f44 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_DRM_NXP_PTN3460) += nxp-ptn3460.o
 obj-$(CONFIG_DRM_PARADE_PS8622) += parade-ps8622.o
 obj-$(CONFIG_DRM_SIL_SII8620) += sil-sii8620.o
 obj-$(CONFIG_DRM_SII902X) += sii902x.o
+obj-$(CONFIG_DRM_TOSHIBA_TC358762) += tc358762.o
 obj-$(CONFIG_DRM_TOSHIBA_TC358767) += tc358767.o
 obj-$(CONFIG_DRM_ANALOGIX_DP) += analogix/
 obj-$(CONFIG_DRM_I2C_ADV7511) += adv7511/
diff --git a/drivers/gpu/drm/bridge/sec-dsim.c b/drivers/gpu/drm/bridge/sec-dsim.c
index 879d174..4acacfe 100644
--- a/drivers/gpu/drm/bridge/sec-dsim.c
+++ b/drivers/gpu/drm/bridge/sec-dsim.c
@@ -403,8 +403,6 @@ static const struct dsim_hblank_par *sec_mipi_dsim_get_hblank_par(const char *na
 		size   = ARRAY_SIZE(hblank_4lanes);
 		break;
 	default:
-		pr_err("No hblank data for mode %s with %d lanes\n",
-		       name, lanes);
 		return NULL;
 	}
 
@@ -423,6 +421,72 @@ static const struct dsim_hblank_par *sec_mipi_dsim_get_hblank_par(const char *na
 	return NULL;
 }
 
+static void mipi_dsim_reg_dump(struct sec_mipi_dsim *dsim)
+{
+	dev_info(dsim->dev," ***********************\n");
+	dev_info(dsim->dev, "DSIM_VERSION:  0x%08x\n",
+		 dsim_read(dsim, DSIM_VERSION));
+	dev_info(dsim->dev, "DSIM_STATUS:  0x%08x\n",
+		 dsim_read(dsim, DSIM_STATUS));
+	dev_info(dsim->dev, "DSIM_RGB_STATUS:  0x%08x\n",
+		 dsim_read(dsim, DSIM_RGB_STATUS));
+	dev_info(dsim->dev, "DSIM_SWRST:  0x%08x\n",
+		 dsim_read(dsim, DSIM_SWRST));
+	dev_info(dsim->dev, "DSIM_CLKCTRL:  0x%08x\n",
+		 dsim_read(dsim, DSIM_CLKCTRL));
+	dev_info(dsim->dev, "DSIM_TIMEOUT:  0x%08x\n",
+		 dsim_read(dsim, DSIM_TIMEOUT));
+	dev_info(dsim->dev, "DSIM_CONFIG:  0x%08x\n",
+		 dsim_read(dsim, DSIM_CONFIG));
+	dev_info(dsim->dev, "DSIM_ESCMODE:  0x%08x\n",
+		 dsim_read(dsim, DSIM_ESCMODE));
+	dev_info(dsim->dev, "DSIM_MDRESOL:  0x%08x\n",
+		 dsim_read(dsim, DSIM_MDRESOL));
+	dev_info(dsim->dev, "DSIM_MHPORCH:  0x%08x\n",
+		 dsim_read(dsim, DSIM_MVPORCH));
+	dev_info(dsim->dev, "DSIM_MHPORCH:  0x%08x\n",
+		 dsim_read(dsim, DSIM_MHPORCH));
+	dev_info(dsim->dev, "DSIM_MSYNC:  0x%08x\n",
+		 dsim_read(dsim, DSIM_MSYNC));
+	dev_info(dsim->dev, "DSIM_SDRESOL:  0x%08x\n",
+		 dsim_read(dsim, DSIM_SDRESOL));
+	dev_info(dsim->dev, "DSIM_INTSRC:  0x%08x\n",
+		 dsim_read(dsim, DSIM_INTSRC));
+	dev_info(dsim->dev, "DSIM_INTMSK:  0x%08x\n",
+		 dsim_read(dsim, DSIM_INTMSK));
+	dev_info(dsim->dev, "DSIM_PKTHDR:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PKTHDR));
+	dev_info(dsim->dev, "DSIM_PAYLOAD:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PAYLOAD));
+	dev_info(dsim->dev, "DSIM_RXFIFO:  0x%08x\n",
+		 dsim_read(dsim, DSIM_RXFIFO));
+	dev_info(dsim->dev, "DSIM_FIFOTHLD:  0x%08x\n",
+		 dsim_read(dsim, DSIM_FIFOTHLD));
+	dev_info(dsim->dev, "DSIM_FIFOCTRL:  0x%08x\n",
+		 dsim_read(dsim, DSIM_FIFOCTRL));
+	dev_info(dsim->dev, "DSIM_MEMACCHR:  0x%08x\n",
+		 dsim_read(dsim, DSIM_MEMACCHR));
+	dev_info(dsim->dev, "DSIM_MULTI_PKT:  0x%08x\n",
+		 dsim_read(dsim, DSIM_MULTI_PKT));
+	dev_info(dsim->dev, "DSIM_PLLCTRL_1G:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PLLCTRL_1G));
+	dev_info(dsim->dev, "DSIM_PLLCTRL:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PLLCTRL));
+	dev_info(dsim->dev, "DSIM_PLLCTRL1:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PLLCTRL1));
+	dev_info(dsim->dev, "DSIM_PLLCTRL2:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PLLCTRL2));
+	dev_info(dsim->dev, "DSIM_PLLTMR:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PLLTMR));
+	dev_info(dsim->dev, "DSIM_PHYTIMING:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PHYTIMING));
+	dev_info(dsim->dev, "DSIM_PHYTIMING1:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PHYTIMING1));
+	dev_info(dsim->dev, "DSIM_PHYTIMING2:  0x%08x\n",
+		 dsim_read(dsim, DSIM_PHYTIMING2));
+	dev_info(dsim->dev, "***********************\n");
+}
+
 static int sec_mipi_dsim_set_pref_rate(struct sec_mipi_dsim *dsim)
 {
 	int ret;
@@ -437,7 +501,7 @@ static int sec_mipi_dsim_set_pref_rate(struct sec_mipi_dsim *dsim)
 		dev_dbg(dev, "no valid rate assigned for pref clock\n");
 		dsim->pref_clk = PHY_REF_CLK;
 	} else {
-		if (unlikely(rate < fin_range->min || rate > fin_range->max)) {
+		if (rate < fin_range->min || rate > fin_range->max) {
 			dev_warn(dev, "pref-rate get is invalid: %uKHz\n",
 				 rate);
 			dsim->pref_clk = PHY_REF_CLK;
@@ -454,13 +518,13 @@ static int sec_mipi_dsim_set_pref_rate(struct sec_mipi_dsim *dsim)
 	}
 
 	rate = clk_get_rate(dsim->clk_pllref) / 1000;
-	if (unlikely(!rate)) {
+	if (!rate) {
 		dev_err(dev, "failed to get pll ref clock rate\n");
 		return -EINVAL;
 	}
 
 	if (rate != dsim->pref_clk) {
-		if (unlikely(dsim->pref_clk == PHY_REF_CLK)) {
+		if (dsim->pref_clk == PHY_REF_CLK) {
 			/* set default rate failed */
 			dev_err(dev, "no valid pll ref clock rate\n");
 			return -EINVAL;
@@ -581,6 +645,12 @@ static void sec_mipi_dsim_config_cmd_lpm(struct sec_mipi_dsim *dsim,
 	else
 		escmode &= ~ESCMODE_CMDLPDT;
 
+	// /* force BTA at the end of packet transfer
+	//  * to receive the acknowledgment from dsi
+	//  * peripheral for this transfer
+	//  */
+	// escmode |= ESCMODE_FORCEBTA;
+
 	dsim_write(dsim, escmode, DSIM_ESCMODE);
 }
 
@@ -604,8 +674,10 @@ static void sec_mipi_dsim_write_pl_to_sfr_fifo(struct sec_mipi_dsim *dsim,
 	switch (length) {
 	case 3:
 		pl_data |= ((u8 *)payload)[2] << 16;
+		/* fall through */
 	case 2:
 		pl_data |= ((u8 *)payload)[1] << 8;
+		/* fall through */
 	case 1:
 		pl_data |= ((u8 *)payload)[0];
 		dsim_write(dsim, pl_data, DSIM_PAYLOAD);
@@ -685,8 +757,10 @@ static int sec_mipi_dsim_read_pl_from_sfr_fifo(struct sec_mipi_dsim *dsim,
 			switch (word_count) {
 			case 3:
 				((u8 *)payload)[2] = (pl >> 16) & 0xff;
+				/* fall through */
 			case 2:
 				((u8 *)payload)[1] = (pl >> 8) & 0xff;
+				/* fall through */
 			case 1:
 				((u8 *)payload)[0] = pl & 0xff;
 				break;
@@ -727,7 +801,7 @@ static ssize_t sec_mipi_dsim_host_transfer(struct mipi_dsi_host *host,
 	sec_mipi_dsim_config_cmd_lpm(dsim, use_lpm);
 
 	if (packet.payload_length) {		/* Long Packet case */
-		reinit_completion(&dsim->pl_tx_done);
+		reinit_completion(&dsim->ph_tx_done);
 
 		/* write packet payload */
 		sec_mipi_dsim_write_pl_to_sfr_fifo(dsim,
@@ -808,7 +882,7 @@ static int sec_mipi_dsim_bridge_attach(struct drm_bridge *bridge)
 	if (!endpoint)
 		return -ENODEV;
 
-	while(endpoint && !next) {
+	while (endpoint && !next) {
 		remote = of_graph_get_remote_port_parent(endpoint);
 
 		if (!remote || !of_device_is_available(remote)) {
@@ -827,9 +901,13 @@ static int sec_mipi_dsim_bridge_attach(struct drm_bridge *bridge)
 		endpoint = of_graph_get_next_endpoint(np, endpoint);
 	}
 
-	/* No valid dsi device attached */
+	/* For the panel driver loading is after dsim bridge,
+	 * defer bridge binding to wait for panel driver ready.
+	 * The disadvantage of probe defer is endless probing
+	 * in some cases.
+	 */
 	if (!next)
-		return -ENODEV;
+		return -EPROBE_DEFER;
 
 	/* duplicate bridges or next bridge exists */
 	WARN_ON(bridge == next || bridge->next || dsim->next);
@@ -1161,7 +1239,7 @@ struct dsim_pll_pms *sec_mipi_dsim_calc_pmsk(struct sec_mipi_dsim *dsim)
 	struct sec_mipi_dsim_range pr_new = *prange;
 	struct sec_mipi_dsim_range sr_new = *srange;
 
-	pll_pms = devm_kzalloc(dev, sizeof(*pll_pms), GFP_KERNEL);
+	pll_pms = kzalloc(sizeof(*pll_pms), GFP_KERNEL);
 	if (!pll_pms) {
 		dev_err(dev, "Unable to allocate 'pll_pms'\n");
 		return ERR_PTR(-ENOMEM);
@@ -1194,9 +1272,7 @@ struct dsim_pll_pms *sec_mipi_dsim_calc_pmsk(struct sec_mipi_dsim *dsim)
 	mrange->max = min_t(uint32_t, mrange->max,
 			    DIV_ROUND_UP_ULL(pfvco, fin));
 
-	dev_dbg(dev, "p: min = %u, max = %u, "
-		     "m: min = %u, max = %u, "
-		     "s: min = %u, max = %u\n",
+	dev_dbg(dev, "p: min = %u, max = %u, m: min = %u, max = %u, s: min = %u, max = %u\n",
 		prange->min, prange->max, mrange->min,
 		mrange->max, srange->min, srange->max);
 
@@ -1207,7 +1283,7 @@ struct dsim_pll_pms *sec_mipi_dsim_calc_pmsk(struct sec_mipi_dsim *dsim)
 		pr_new.min = max_t(uint32_t, prange->min,
 				   DIV_ROUND_UP_ULL(mfin, fvco_range->max));
 		pr_new.max = min_t(uint32_t, prange->max,
-				   (mfin / fvco_range->min));
+				   (DIV_ROUND_DOWN_ULL(mfin, fvco_range->min)));
 
 		if (pr_new.max < pr_new.min || pr_new.min < prange->min)
 			continue;
@@ -1243,7 +1319,7 @@ struct dsim_pll_pms *sec_mipi_dsim_calc_pmsk(struct sec_mipi_dsim *dsim)
 	}
 
 	if (best_delta == ~0U) {
-		devm_kfree(dev, pll_pms);
+		kfree(pll_pms);
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -1251,8 +1327,7 @@ struct dsim_pll_pms *sec_mipi_dsim_calc_pmsk(struct sec_mipi_dsim *dsim)
 	pll_pms->m = best_m;
 	pll_pms->s = best_s;
 
-	dev_dbg(dev, "fout = %u, fin = %u, m = %u, "
-		     "p = %u, s = %u, best_delta = %u\n",
+	dev_dbg(dev, "fout = %u, fin = %u, m = %u, p = %u, s = %u, best_delta = %u\n",
 		fout, fin, pll_pms->m, pll_pms->p, pll_pms->s, best_delta);
 
 	return pll_pms;
@@ -1300,7 +1375,7 @@ int sec_mipi_dsim_check_pll_out(void *driver_private,
 	/* free 'dsim_pll_pms' structure data which is
 	 * allocated in 'sec_mipi_dsim_calc_pmsk()'.
 	 */
-	devm_kfree(dsim->dev, (void *)pmsk);
+	kfree(pmsk);
 
 	if (dsim->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) {
 		hpar = sec_mipi_dsim_get_hblank_par(mode->name,
@@ -1346,7 +1421,7 @@ static void sec_mipi_dsim_bridge_enable(struct drm_bridge *bridge)
 	/* prepare panel if exists */
 	if (dsim->panel) {
 		ret = drm_panel_prepare(dsim->panel);
-		if (unlikely(ret)) {
+		if (ret) {
 			dev_err(dsim->dev, "panel prepare failed: %d\n", ret);
 			return;
 		}
@@ -1358,7 +1433,7 @@ static void sec_mipi_dsim_bridge_enable(struct drm_bridge *bridge)
 	/* enable panel if exists */
 	if (dsim->panel) {
 		ret = drm_panel_enable(dsim->panel);
-		if (unlikely(ret)) {
+		if (ret) {
 			dev_err(dsim->dev, "panel enable failed: %d\n", ret);
 			goto panel_unprepare;
 		}
@@ -1367,11 +1442,13 @@ static void sec_mipi_dsim_bridge_enable(struct drm_bridge *bridge)
 	/* enable data transfer of dsim */
 	sec_mipi_dsim_set_standby(dsim, true);
 
+	mipi_dsim_reg_dump(dsim);
 	return;
 
 panel_unprepare:
 	ret = drm_panel_unprepare(dsim->panel);
-	if (unlikely(ret))
+	mipi_dsim_reg_dump(dsim);
+	if (ret)
 		dev_err(dsim->dev, "panel unprepare failed: %d\n", ret);
 }
 
@@ -1409,7 +1486,7 @@ static void sec_mipi_dsim_bridge_disable(struct drm_bridge *bridge)
 	/* disable panel if exists */
 	if (dsim->panel) {
 		ret = drm_panel_disable(dsim->panel);
-		if (unlikely(ret))
+		if (ret)
 			dev_err(dsim->dev, "panel disable failed: %d\n", ret);
 	}
 
@@ -1425,7 +1502,7 @@ static void sec_mipi_dsim_bridge_disable(struct drm_bridge *bridge)
 	/* unprepare panel if exists */
 	if (dsim->panel) {
 		ret = drm_panel_unprepare(dsim->panel);
-		if (unlikely(ret))
+		if (ret)
 			dev_err(dsim->dev, "panel unprepare failed: %d\n", ret);
 	}
 }
@@ -1906,7 +1983,6 @@ int sec_mipi_dsim_bind(struct device *dev, struct device *master, void *data,
 	bridge->funcs = &sec_mipi_dsim_bridge_funcs;
 	bridge->of_node = dev->of_node;
 	bridge->encoder = encoder;
-	encoder->bridge = bridge;
 
 	/* attach sec dsim bridge and its next bridge if exists */
 	ret = drm_bridge_attach(encoder, bridge, NULL);
@@ -1952,7 +2028,8 @@ int sec_mipi_dsim_bind(struct device *dev, struct device *master, void *data,
 }
 EXPORT_SYMBOL(sec_mipi_dsim_bind);
 
-void sec_mipi_dsim_unbind(struct device *dev, struct device *master, void *data)
+void sec_mipi_dsim_unbind(struct device *dev, struct device *master,
+			  void *data)
 {
 	struct sec_mipi_dsim *dsim = dev_get_drvdata(dev);
 
diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 453100d..4fc97e8 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -245,7 +245,7 @@ static void add_dpu_bliteng_components(struct device *dev,
 			found = false;
 		} else {
 			if (num_dpu >= ARRAY_SIZE(dpu)) {
-				dev_err(dev, "The number of found dpu is greater than max [%ld].\n",
+				dev_err(dev, "The number of found dpu is greater than max [%zd].\n",
 					ARRAY_SIZE(dpu));
 				of_node_put(parent);
 				of_node_put(port);
diff --git a/drivers/gpu/drm/imx/sec_mipi_dsim-imx.c b/drivers/gpu/drm/imx/sec_mipi_dsim-imx.c
index e806341..5dd10b2 100644
--- a/drivers/gpu/drm/imx/sec_mipi_dsim-imx.c
+++ b/drivers/gpu/drm/imx/sec_mipi_dsim-imx.c
@@ -51,7 +51,7 @@ struct imx_sec_dsim_device {
 
 static struct imx_sec_dsim_device *dsim_dev;
 
-#if CONFIG_PM
+#ifdef CONFIG_PM
 static int imx_sec_dsim_runtime_suspend(struct device *dev);
 static int imx_sec_dsim_runtime_resume(struct device *dev);
 #else
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index eb2a746..ee6acc4 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -135,4 +135,14 @@ config DRM_PANEL_RAYDIUM_RM67191
 	  Say Y here if you want to enable support for Raydium RM67191 FHD
 	  (1080x1920) DSI panel.
 
+config DRM_PANEL_RPI_7INCH
+	tristate "RaspberryPi 7inch display panel driver"
+	depends on OF && I2C
+	depends on DRM_MIPI_DSI
+	select RPI_DISPLAY
+	select TOUCHSCREEN_RPI_FT5406
+	select VIDEOMODE_HELPERS
+	help
+	  Say Y here if you want to enable support for the official RaspberryPi 7inch panel.
+
 endmenu
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 68a80b1..bbbb4cf 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -13,3 +13,4 @@ obj-$(CONFIG_DRM_PANEL_SHARP_LQ101R1SX01) += panel-sharp-lq101r1sx01.o
 obj-$(CONFIG_DRM_PANEL_SHARP_LS043T1LE01) += panel-sharp-ls043t1le01.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7789V) += panel-sitronix-st7789v.o
 obj-$(CONFIG_DRM_PANEL_RAYDIUM_RM67191) += panel-raydium-rm67191.o
+obj-$(CONFIG_DRM_PANEL_RPI_7INCH) += panel-rpi-7inch.o
\ No newline at end of file
diff --git a/drivers/gpu/drm/panel/panel-rpi-7inch.c b/drivers/gpu/drm/panel/panel-rpi-7inch.c
new file mode 100644
index 00000000..4421a3d
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-rpi-7inch.c
@@ -0,0 +1,650 @@
+/*
+ * Copyright (C) 2013, NVIDIA Corporation.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/backlight.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/rpi_display.h>
+
+#include <video/display_timing.h>
+#include <video/of_display_timing.h>
+#include <video/videomode.h>
+
+/* DSI PPI Layer Registers */
+#define PPI_STARTPPI		0x0104
+#define PPI_LPTXTIMECNT		0x0114
+#define PPI_D0S_ATMR		0x0144
+#define PPI_D1S_ATMR		0x0148
+#define PPI_D0S_CLRSIPOCOUNT	0x0164
+#define PPI_D1S_CLRSIPOCOUNT	0x0168
+
+/* DSI Protocol Layer Registers */
+#define DSI_STARTDSI		0x0204
+#define DSI_BUSYDSI		0x0208
+#define DSI_LANEENABLE		0x0210
+#define DSI_LANEENABLE_CLOCK	BIT(0)
+#define DSI_LANEENABLE_D0	BIT(1)
+#define DSI_LANEENABLE_D1	BIT(2)
+
+/* LCDC/DPI Host Registers */
+#define LCDCTRL			0x0420
+
+/* SPI Master Registers */
+#define SPICMR			0x0450
+
+/* System Controller Registers */
+#define SYSCTRL			0x0464
+
+static int trigger_bridge = 1;
+
+struct panel_desc {
+	const struct drm_display_mode *modes;
+	unsigned int num_modes;
+	const struct display_timing *timings;
+	unsigned int num_timings;
+
+	unsigned int bpc;
+
+	struct {
+		unsigned int width;
+		unsigned int height;
+	} size;
+
+	/**
+	 * @prepare: the time (in milliseconds) that it takes for the panel to
+	 *		become ready and start receiving video data
+	 * @enable: the time (in milliseconds) that it takes for the panel to
+	 *		display the first valid frame after starting to receive
+	 *		video data
+	 * @disable: the time (in milliseconds) that it takes for the panel to
+	 *		turn the display off (no content is visible)
+	 * @unprepare: the time (in milliseconds) that it takes for the panel
+	 *		to power itself down completely
+	 */
+	struct {
+		unsigned int prepare;
+		unsigned int enable;
+		unsigned int disable;
+		unsigned int unprepare;
+	} delay;
+
+	u32 bus_format;
+};
+
+struct tc358762 {
+	struct drm_panel base;
+	bool prepared;
+	bool enabled;
+
+	struct device *dev;
+	struct mipi_dsi_device *dsi;
+	const struct panel_desc *desc;
+
+	struct backlight_device *backlight;
+	struct regulator *supply;
+	struct i2c_adapter *ddc;
+
+	struct gpio_desc *enable_gpio;
+};
+
+static inline struct tc358762 *to_tc358762(struct drm_panel *panel)
+{
+	return container_of(panel, struct tc358762, base);
+}
+
+static int tc358762_get_fixed_modes(struct tc358762 *panel)
+{
+	struct drm_connector *connector = panel->base.connector;
+	struct drm_device *drm = panel->base.drm;
+	struct drm_display_mode *mode;
+	unsigned int i, num = 0;
+
+	if (!panel->desc)
+		return 0;
+
+	for (i = 0; i < panel->desc->num_timings; i++) {
+		const struct display_timing *dt = &panel->desc->timings[i];
+		struct videomode vm;
+
+		videomode_from_timing(dt, &vm);
+		mode = drm_mode_create(drm);
+		if (!mode) {
+			dev_err(drm->dev, "failed to add mode %ux%u\n",
+				dt->hactive.typ, dt->vactive.typ);
+			continue;
+		}
+
+		drm_display_mode_from_videomode(&vm, mode);
+		drm_mode_set_name(mode);
+
+		drm_mode_probed_add(connector, mode);
+		num++;
+	}
+
+	for (i = 0; i < panel->desc->num_modes; i++) {
+		const struct drm_display_mode *m = &panel->desc->modes[i];
+
+		mode = drm_mode_duplicate(drm, m);
+		if (!mode) {
+			dev_err(drm->dev, "failed to add mode %ux%u@%u\n",
+				m->hdisplay, m->vdisplay, m->vrefresh);
+			continue;
+		}
+
+		drm_mode_set_name(mode);
+
+		drm_mode_probed_add(connector, mode);
+		num++;
+	}
+
+	connector->display_info.bpc = panel->desc->bpc;
+	connector->display_info.width_mm = panel->desc->size.width;
+	connector->display_info.height_mm = panel->desc->size.height;
+	if (panel->desc->bus_format)
+		drm_display_info_set_bus_formats(&connector->display_info,
+						 &panel->desc->bus_format, 1);
+
+	return num;
+}
+
+static int tc358762_of_get_native_mode(struct tc358762 *panel)
+{
+	struct drm_connector *connector = panel->base.connector;
+	struct drm_device *drm = panel->base.drm;
+	struct drm_display_mode *mode;
+	struct device_node *timings_np;
+	int ret;
+
+	timings_np = of_get_child_by_name(panel->dev->of_node,
+					  "display-timings");
+	if (!timings_np) {
+		dev_dbg(panel->dev, "failed to find display-timings node\n");
+		return 0;
+	}
+
+	of_node_put(timings_np);
+	mode = drm_mode_create(drm);
+	if (!mode)
+		return 0;
+
+	ret = of_get_drm_display_mode(panel->dev->of_node, mode, NULL,
+				      OF_USE_NATIVE_MODE);
+	if (ret) {
+		dev_dbg(panel->dev, "failed to find dts display timings\n");
+		drm_mode_destroy(drm, mode);
+		return 0;
+	}
+
+	drm_mode_set_name(mode);
+	mode->type |= DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static int tc358762_disable(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+
+	if (!p->enabled)
+		return 0;
+
+	printk("panel disable\n");
+
+	rpi_display_set_bright(0x00);
+
+	if (p->backlight) {
+		p->backlight->props.power = FB_BLANK_POWERDOWN;
+		backlight_update_status(p->backlight);
+	}
+
+	if (p->desc && p->desc->delay.disable)
+		msleep(p->desc->delay.disable);
+
+	p->enabled = false;
+
+	return 0;
+}
+
+static int tc358762_unprepare(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+
+	if (!p->prepared)
+		return 0;
+
+	if (p->enable_gpio)
+		gpiod_direction_output(p->enable_gpio, 0);
+
+	regulator_disable(p->supply);
+
+	if (p->desc && p->desc->delay.unprepare)
+		msleep(p->desc->delay.unprepare);
+
+	p->prepared = false;
+
+	return 0;
+}
+
+static int rpi_touchscreen_write(struct mipi_dsi_device *dsi, u16 reg, u32 val)
+{
+	u8 msg[] = {
+		reg,
+		reg >> 8,
+		val,
+		val >> 8,
+		val >> 16,
+		val >> 24,
+	};
+
+	mipi_dsi_generic_write(dsi, msg, sizeof(msg));
+
+	return 0;
+}
+
+static int tc358762_dsi_init(struct tc358762 *p)
+{
+	struct mipi_dsi_device *dsi = p->dsi;
+
+	rpi_touchscreen_write(dsi, DSI_LANEENABLE,
+			      DSI_LANEENABLE_CLOCK |
+			      DSI_LANEENABLE_D0);
+
+	rpi_touchscreen_write(dsi, PPI_D0S_CLRSIPOCOUNT, 0x05);
+	rpi_touchscreen_write(dsi, PPI_D1S_CLRSIPOCOUNT, 0x05);
+	rpi_touchscreen_write(dsi, PPI_D0S_ATMR, 0x00);
+	rpi_touchscreen_write(dsi, PPI_D1S_ATMR, 0x00);
+	rpi_touchscreen_write(dsi, PPI_LPTXTIMECNT, 0x03);
+
+	rpi_touchscreen_write(dsi, SPICMR, 0x00);
+	rpi_touchscreen_write(dsi, LCDCTRL, 0x00100150);
+	rpi_touchscreen_write(dsi, SYSCTRL, 0x040f);
+	msleep(100);
+
+	rpi_touchscreen_write(dsi, PPI_STARTPPI, 0x01);
+	rpi_touchscreen_write(dsi, DSI_STARTDSI, 0x01);
+	msleep(100);
+
+	return 0;
+}
+
+static int tc358762_prepare(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+	int err;
+
+	if (p->prepared)
+		return 0;
+
+	err = regulator_enable(p->supply);
+	if (err < 0) {
+		dev_err(panel->dev, "failed to enable supply: %d\n", err);
+		return err;
+	}
+
+	if (p->enable_gpio)
+		gpiod_direction_output(p->enable_gpio, 1);
+
+	if (p->desc && p->desc->delay.prepare)
+		msleep(p->desc->delay.prepare);
+
+	p->prepared = true;
+
+	return 0;
+}
+
+static int tc358762_enable(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+
+	if (p->enabled)
+		return 0;
+
+	printk("panel enable\n");
+
+	if (trigger_bridge) {
+		pr_info("rpi_display_power_up");
+		rpi_display_screen_power_up();
+		trigger_bridge = 0;
+		msleep(100);
+		pr_info("rpi_ft5406_start_polling");
+		rpi_ft5406_start_polling();
+	}
+
+	tc358762_dsi_init(p);
+
+	if (p->desc && p->desc->delay.enable)
+		msleep(p->desc->delay.enable);
+
+	if (p->backlight) {
+		p->backlight->props.power = FB_BLANK_UNBLANK;
+		backlight_update_status(p->backlight);
+	}
+
+	rpi_display_set_bright(0xFF);
+
+	p->enabled = true;
+
+	return 0;
+}
+
+static int tc358762_get_modes(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+	int num = 0;
+
+	/* probe EDID if a DDC bus is available */
+	if (p->ddc) {
+		struct edid *edid = drm_get_edid(panel->connector, p->ddc);
+		drm_mode_connector_update_edid_property(panel->connector, edid);
+		if (edid) {
+			num += drm_add_edid_modes(panel->connector, edid);
+			kfree(edid);
+		}
+	}
+
+	/* add hard-coded panel modes */
+	num += tc358762_get_fixed_modes(p);
+
+	/* add device node plane modes */
+	num += tc358762_of_get_native_mode(p);
+
+	return num;
+}
+
+static int tc358762_get_timings(struct drm_panel *panel,
+					unsigned int num_timings,
+					struct display_timing *timings)
+{
+	struct tc358762 *p = to_tc358762(panel);
+	unsigned int i;
+
+	if (!p->desc)
+		return 0;
+
+	if (p->desc->num_timings < num_timings)
+		num_timings = p->desc->num_timings;
+
+	if (timings)
+		for (i = 0; i < num_timings; i++)
+			timings[i] = p->desc->timings[i];
+
+	return p->desc->num_timings;
+}
+
+static const struct drm_panel_funcs tc358762_funcs = {
+	.disable = tc358762_disable,
+	.unprepare = tc358762_unprepare,
+	.prepare = tc358762_prepare,
+	.enable = tc358762_enable,
+	.get_modes = tc358762_get_modes,
+	.get_timings = tc358762_get_timings,
+};
+
+static int tc358762_mipi_probe(struct mipi_dsi_device *dsi, const struct panel_desc *desc)
+{
+	struct device_node *backlight, *ddc;
+	struct tc358762 *panel;
+	struct device *dev = &dsi->dev;
+	int err;
+
+	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
+	if (!panel)
+		return -ENOMEM;
+
+	panel->enabled = false;
+	panel->prepared = false;
+	panel->desc = desc;
+	panel->dev = dev;
+	panel->dsi = dsi;
+
+	panel->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(panel->supply))
+		return PTR_ERR(panel->supply);
+
+	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable",
+							 GPIOD_OUT_LOW);
+	if (IS_ERR(panel->enable_gpio)) {
+		err = PTR_ERR(panel->enable_gpio);
+		dev_err(dev, "failed to request GPIO: %d\n", err);
+		return err;
+	}
+
+	backlight = of_parse_phandle(dev->of_node, "backlight", 0);
+	if (backlight) {
+		panel->backlight = of_find_backlight_by_node(backlight);
+		of_node_put(backlight);
+
+		if (!panel->backlight)
+			return -EPROBE_DEFER;
+	}
+
+	ddc = of_parse_phandle(dev->of_node, "ddc-i2c-bus", 0);
+	if (ddc) {
+		panel->ddc = of_find_i2c_adapter_by_node(ddc);
+		of_node_put(ddc);
+
+		if (!panel->ddc) {
+			err = -EPROBE_DEFER;
+			goto free_backlight;
+		}
+	}
+
+	drm_panel_init(&panel->base);
+	panel->base.dev = dev;
+	panel->base.funcs = &tc358762_funcs;
+
+	err = drm_panel_add(&panel->base);
+	if (err < 0)
+		goto free_ddc;
+
+	dev_set_drvdata(dev, panel);
+
+	return 0;
+
+free_ddc:
+	if (panel->ddc)
+		put_device(&panel->ddc->dev);
+free_backlight:
+	if (panel->backlight)
+		put_device(&panel->backlight->dev);
+
+	return err;
+}
+
+static int tc358762_remove(struct device *dev)
+{
+	struct tc358762 *panel = dev_get_drvdata(dev);
+
+	drm_panel_detach(&panel->base);
+	drm_panel_remove(&panel->base);
+
+	tc358762_disable(&panel->base);
+
+	if (panel->ddc)
+		put_device(&panel->ddc->dev);
+
+	if (panel->backlight)
+		put_device(&panel->backlight->dev);
+
+	return 0;
+}
+
+static void tc358762_shutdown(struct device *dev)
+{
+	struct tc358762 *panel = dev_get_drvdata(dev);
+
+	tc358762_disable(&panel->base);
+}
+
+struct bridge_desc {
+	struct panel_desc desc;
+
+	unsigned long flags;
+	enum mipi_dsi_pixel_format format;
+	unsigned int lanes;
+};
+
+static const struct drm_display_mode tc358762_mode = {
+	.clock = 27448,
+	.hdisplay = 800,
+	.hsync_start = 800 + 70,
+	.hsync_end = 800 + 70 + 20,
+	.htotal = 800 + 70 + 20 + 23,
+	.vdisplay = 480,
+	.vsync_start = 480 + 7,
+	.vsync_end = 480 + 7 + 2,
+	.vtotal = 480 + 7 + 2 + 21,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct bridge_desc tc358762_bridge = {
+	.desc = {
+		.modes = &tc358762_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 154,
+			.height = 86,
+		},
+		.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO |
+		 MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+		 MIPI_DSI_MODE_LPM |
+		 MIPI_DSI_MODE_VIDEO_HSE,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 1,
+};
+
+static const struct of_device_id dsi_of_match[] = {
+	{
+		.compatible = "rpi,tc358762",
+		.data = &tc358762_bridge
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, dsi_of_match);
+
+static int tc358762_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	const struct bridge_desc *desc;
+	const struct of_device_id *id;
+	const struct panel_desc *pdesc;
+	u32 val;
+	int err;
+
+	id = of_match_node(dsi_of_match, dsi->dev.of_node);
+	if (!id)
+		return -ENODEV;
+
+	desc = id->data;
+
+	printk("find panel: %s\n", id->compatible);
+
+	if (desc) {
+		dsi->mode_flags = desc->flags;
+		dsi->format = desc->format;
+		dsi->lanes = desc->lanes;
+		pdesc = &desc->desc;
+	} else {
+		pdesc = NULL;
+	}
+
+	err = tc358762_mipi_probe(dsi, pdesc);
+
+	if (err < 0)
+		return err;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,flags", &val))
+		dsi->mode_flags = val;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,format", &val))
+		dsi->format = val;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,lanes", &val))
+		dsi->lanes = val;
+
+	return mipi_dsi_attach(dsi);
+}
+
+static int tc358762_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	int err;
+
+	err = mipi_dsi_detach(dsi);
+	if (err < 0)
+		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", err);
+
+	return tc358762_remove(&dsi->dev);
+}
+
+static void tc358762_dsi_shutdown(struct mipi_dsi_device *dsi)
+{
+	tc358762_shutdown(&dsi->dev);
+}
+
+static struct mipi_dsi_driver tc358762_dsi_driver = {
+	.driver = {
+		.name = "bridge-tc358762-dsi",
+		.of_match_table = dsi_of_match,
+	},
+	.probe = tc358762_dsi_probe,
+	.remove = tc358762_dsi_remove,
+	.shutdown = tc358762_dsi_shutdown,
+};
+
+static int __init tc358762_init(void)
+{
+	int err;
+
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {
+		err = mipi_dsi_driver_register(&tc358762_dsi_driver);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+module_init(tc358762_init);
+
+static void __exit tc358762_exit(void)
+{
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+		mipi_dsi_driver_unregister(&tc358762_dsi_driver);
+}
+module_exit(tc358762_exit);
+
+MODULE_AUTHOR("Jerry <xbl@rock-chips.com>");
+MODULE_DESCRIPTION("DRM Driver for toshiba tc358762 Bridge");
+MODULE_LICENSE("GPL and additional rights");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 538a0fc..4d62e9a 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1210,6 +1210,13 @@ config TOUCHSCREEN_SX8654
 	  To compile this driver as a module, choose M here: the
 	  module will be called sx8654.
 
+config TOUCHSCREEN_RPI_FT5406
+	tristate "RaspberryPi 7inch touchscreen ft5406"
+	default y
+	depends on I2C
+	help
+	  Controls the official RaspberryPi 7inch ft5406 touch ic.
+
 config TOUCHSCREEN_TPS6507X
 	tristate "TPS6507x based touchscreens"
 	depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 63a95eb..234f017 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -103,6 +103,7 @@ obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_SX8654)	+= sx8654.o
+obj-$(CONFIG_TOUCHSCREEN_RPI_FT5406)	+= rpi_ft5406.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ZET6223)	+= zet6223.o
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
diff --git a/drivers/input/touchscreen/rpi_ft5406.c b/drivers/input/touchscreen/rpi_ft5406.c
new file mode 100644
index 00000000..80323f6
--- /dev/null
+++ b/drivers/input/touchscreen/rpi_ft5406.c
@@ -0,0 +1,365 @@
+/*
+ *
+ * RPI Display FT5406 touch driver.
+ *
+ * Copyright (c) 2016 ASUSTek Computer Inc.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <drm/rpi_display.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include "rpi_ft5406.h"
+
+static struct rpi_ft5406_data g_ts_data;
+
+static int fts_i2c_read(struct i2c_client *client, char *writebuf,
+			   int writelen, char *readbuf, int readlen)
+{
+	int ret;
+
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = 0,
+				 .len = writelen,
+				 .buf = writebuf,
+			 },
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret < 0)
+			LOG_ERR("i2c read error, %d\n", ret);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 1);
+		if (ret < 0)
+			LOG_ERR("i2c read error, %d\n", ret);
+	}
+
+	return ret;
+}
+
+static int fts_read_reg(struct i2c_client *client, u8 addr, u8 *val)
+{
+	return fts_i2c_read(client, &addr, 1, val, 1);
+}
+
+static int fts_check_fw_ver(struct i2c_client *client)
+{
+	u8 reg_addr, fw_ver[3];
+	int ret;
+
+	reg_addr = FT_REG_FW_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[0], 1);
+	if (ret < 0)
+		goto error;
+
+	reg_addr = FT_REG_FW_MIN_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[1], 1);
+	if (ret < 0)
+		goto error;
+
+	reg_addr = FT_REG_FW_SUB_MIN_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[2], 1);
+	if (ret < 0)
+		goto error;
+
+	LOG_INFO("Firmware version = %d.%d.%d\n", fw_ver[0], fw_ver[1], fw_ver[2]);
+	return 0;
+
+error:
+	return ret;
+}
+
+static int fts_read_td_status(struct rpi_ft5406_data *ts_data)
+{
+	u8 td_status;
+	int ret;
+
+	ret = fts_read_reg(ts_data->client, FT_TD_STATUS_REG, &td_status);
+	if (ret < 0) {
+		LOG_ERR("get reg td_status failed, %d\n", ret);
+		return ret;
+	}
+	return td_status;
+}
+
+static int fts_read_touchdata(struct rpi_ft5406_data *ts_data)
+{
+	struct ts_event *event = &ts_data->event;
+	int ret, i;
+	u8 buf[FT_ONE_TCH_LEN-2] = { 0 };
+	u8 reg_addr, pointid = FT_MAX_ID;
+
+	for (i = 0; i < event->touch_point && i < MAX_TOUCH_POINTS; i++) {
+		reg_addr = FT_TOUCH_X_H_REG + (i * FT_ONE_TCH_LEN);
+		ret = fts_i2c_read(ts_data->client, &reg_addr, 1, buf,
+				   FT_ONE_TCH_LEN - 2);
+		if (ret < 0) {
+			LOG_ERR("read touchdata failed.\n");
+			return ret;
+		}
+
+		pointid = (buf[FT_TOUCH_ID]) >> 4;
+		if (pointid >= MAX_TOUCH_POINTS)
+			break;
+		event->au8_finger_id[i] = pointid;
+		event->au16_x[i] = (s16)(buf[FT_TOUCH_X_H] & 0x0F) << 8 |
+			(s16)buf[FT_TOUCH_X_L];
+		event->au16_y[i] = (s16)(buf[FT_TOUCH_Y_H] & 0x0F) << 8 |
+			(s16)buf[FT_TOUCH_Y_L];
+		event->au8_touch_event[i] = buf[FT_TOUCH_EVENT] >> 6;
+
+#if XY_REVERSE
+		event->au16_x[i] = SCREEN_WIDTH - event->au16_x[i] - 1;
+		event->au16_y[i] = SCREEN_HEIGHT - event->au16_y[i] - 1;
+#endif
+	}
+	event->pressure = FT_PRESS;
+
+	return 0;
+}
+
+static void fts_report_value(struct rpi_ft5406_data *ts_data)
+{
+	struct ts_event *event = &ts_data->event;
+	int i, modified_ids = 0, released_ids;
+
+	for (i = 0; i < event->touch_point && i < MAX_TOUCH_POINTS; i++) {
+		if (event->au8_touch_event[i]== FT_TOUCH_DOWN ||
+		    event->au8_touch_event[i] == FT_TOUCH_CONTACT) {
+			modified_ids |= 1 << event->au8_finger_id[i];
+			input_mt_slot(ts_data->input_dev,
+				      event->au8_finger_id[i]);
+			input_mt_report_slot_state(ts_data->input_dev,
+						   MT_TOOL_FINGER,
+				true);
+			input_report_abs(ts_data->input_dev,
+					 ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(ts_data->input_dev, ABS_MT_POSITION_X,
+					 event->au16_x[i]);
+			input_report_abs(ts_data->input_dev, ABS_MT_POSITION_Y,
+					 event->au16_y[i]);
+
+			if (!((1 << event->au8_finger_id[i]) &
+			      ts_data->known_ids))
+				LOG_DBG("Touch id-%d: x = %d, y = %d\n",
+					event->au8_finger_id[i],
+					event->au16_x[i], event->au16_y[i]);
+		}
+	}
+
+	released_ids = ts_data->known_ids & ~modified_ids;
+	for (i = 0; released_ids && i < MAX_TOUCH_POINTS; i++) {
+		if (released_ids & (1 << i)) {
+			LOG_DBG("Release id-%d, known = %x modified = %x\n",
+				i, ts_data->known_ids, modified_ids);
+			input_mt_slot(ts_data->input_dev, i);
+			input_mt_report_slot_state(ts_data->input_dev,
+						   MT_TOOL_FINGER, false);
+			modified_ids &= ~(1 << i);
+		}
+	}
+	ts_data->known_ids = modified_ids;
+	input_mt_report_pointer_emulation(ts_data->input_dev, true);
+	input_sync(ts_data->input_dev);
+}
+
+static void fts_retry_clear(struct rpi_ft5406_data *ts_data)
+{
+	if (ts_data->retry_count != 0)
+		ts_data->retry_count = 0;
+}
+
+static int fts_retry_wait(struct rpi_ft5406_data *ts_data)
+{
+	if (ts_data->retry_count < RETRY_COUNT) {
+		LOG_INFO("wait and retry, count = %d\n", ts_data->retry_count)
+		ts_data->retry_count++;
+		msleep_interruptible(1000);
+		return 1;
+	}
+	LOG_ERR("attach retry count\n");
+	return 0;
+}
+
+static void rpi_ft5406_work(struct work_struct *work)
+{
+	struct ts_event *event = &g_ts_data.event;
+	int ret = 0, count = 5, td_status;
+
+	while (count > 0) {
+		ret = fts_check_fw_ver(g_ts_data.client);
+		if (ret == 0)
+			break;
+		LOG_INFO("checking touch ic, countdown: %d\n", count);
+		msleep_interruptible(1000);
+		count--;
+	}
+	if (!count) {
+		LOG_ERR("checking touch ic timeout, %d\n", ret);
+		g_ts_data.is_polling = 0;
+		return;
+	}
+
+	/* polling 60fps */
+	while (1) {
+		td_status = fts_read_td_status(&g_ts_data);
+		if (td_status < 0) {
+			ret = fts_retry_wait(&g_ts_data);
+			if (ret == 0) {
+				LOG_ERR("stop touch polling\n");
+				g_ts_data.is_polling = 0;
+				break;
+			}
+		} else if (td_status < VALID_TD_STATUS_VAL + 1 &&
+			   (td_status > 0 || g_ts_data.known_ids != 0)) {
+			fts_retry_clear(&g_ts_data);
+			memset(event, -1, sizeof(struct ts_event));
+			event->touch_point = td_status;
+			ret = fts_read_touchdata(&g_ts_data);
+			if (ret == 0)
+				fts_report_value(&g_ts_data);
+		}
+		msleep_interruptible(17);
+	}
+}
+
+void rpi_ft5406_start_polling(void)
+{
+	if (g_ts_data.polling_enabled && g_ts_data.is_polling != 1) {
+		g_ts_data.is_polling = 1;
+		schedule_work(&g_ts_data.ft5406_work);
+	} else {
+		g_ts_data.is_polling = 1;
+	}
+}
+EXPORT_SYMBOL_GPL(rpi_ft5406_start_polling);
+
+static int rpi_ft5406_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct input_dev *input_dev;
+	struct device_node *np = client->dev.of_node;
+	int ret, timeout = 10;
+
+	LOG_INFO("address = 0x%x\n", client->addr);
+
+	g_ts_data.client = client;
+	i2c_set_clientdata(client, &g_ts_data);
+
+	while (!rpi_display_is_connected() && timeout > 0) {
+		msleep(50);
+		timeout--;
+	}
+
+	if (!rpi_display_is_connected() && timeout == 0) {
+		LOG_ERR("wait connected timeout\n");
+		ret = -ENODEV;
+		goto timeout_failed;
+	}
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		LOG_ERR("failed to allocate input device\n");
+		ret = -ENOMEM;
+		goto input_allocate_failed;
+	}
+	input_dev->name = "fts_ts";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &g_ts_data.client->dev;
+
+	g_ts_data.input_dev = input_dev;
+	input_set_drvdata(input_dev, &g_ts_data);
+
+	__set_bit(EV_SYN, input_dev->evbit);
+	__set_bit(EV_KEY, input_dev->evbit);
+	__set_bit(EV_ABS, input_dev->evbit);
+	__set_bit(BTN_TOUCH, input_dev->keybit);
+
+	input_mt_init_slots(input_dev, MAX_TOUCH_POINTS, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+			     SCREEN_WIDTH, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+			     SCREEN_HEIGHT, 0, 0);
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		LOG_ERR("Input device registration failed\n");
+		goto input_register_failed;
+	}
+
+	INIT_WORK(&g_ts_data.ft5406_work, rpi_ft5406_work);
+	g_ts_data.polling_enabled = 1;
+
+	if (g_ts_data.is_polling)
+		schedule_work(&g_ts_data.ft5406_work);
+
+	return 0;
+
+input_register_failed:
+	input_free_device(input_dev);
+input_allocate_failed:
+timeout_failed:
+	return ret;
+}
+
+static int rpi_ft5406_remove(struct i2c_client *client)
+{
+	struct rpi_ft5406_data *ts_data = i2c_get_clientdata(client);
+
+	cancel_work_sync(&ts_data->ft5406_work);
+	if (ts_data->input_dev) {
+		input_unregister_device(ts_data->input_dev);
+		input_free_device(ts_data->input_dev);
+	}
+	return 0;
+}
+
+static const struct i2c_device_id rpi_ft5406_id[] = {
+	{"rpi_ft5406", 0},
+	{}
+};
+
+static struct i2c_driver rpi_ft5406_driver = {
+	.driver = {
+		.name = "rpi_ft5406",
+	},
+	.probe = rpi_ft5406_probe,
+	.remove = rpi_ft5406_remove,
+	.id_table = rpi_ft5406_id,
+};
+module_i2c_driver(rpi_ft5406_driver);
+
+MODULE_DESCRIPTION("RPI Display FT5406 Touch driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/rpi_ft5406.h b/drivers/input/touchscreen/rpi_ft5406.h
new file mode 100644
index 00000000..e9e80da
--- /dev/null
+++ b/drivers/input/touchscreen/rpi_ft5406.h
@@ -0,0 +1,67 @@
+#ifndef _RPI_FT5406_H_
+#define _RPI_FT5406_H_
+
+#define LOG_DBG(fmt,arg...) pr_debug("rpi-ft5406: %s: "fmt, __func__, ##arg);
+#define LOG_INFO(fmt,arg...) pr_info("rpi-ft5406: %s: "fmt, __func__, ##arg);
+#define LOG_ERR(fmt,arg...) pr_err("rpi-ft5406: %s: "fmt, __func__, ##arg);
+
+#define RETRY_COUNT		10
+#define XY_REVERSE		1
+
+#define SCREEN_WIDTH		800
+#define SCREEN_HEIGHT		480
+
+#define FT_ONE_TCH_LEN		6
+
+#define FT_REG_FW_VER		0xA6
+#define FT_REG_FW_MIN_VER	0xB2
+#define FT_REG_FW_SUB_MIN_VER	0xB3
+
+#define VALID_TD_STATUS_VAL	10
+#define MAX_TOUCH_POINTS	1
+
+#define FT_PRESS		0x7F
+#define FT_MAX_ID		0x0F
+
+#define FT_TOUCH_X_H		0
+#define FT_TOUCH_X_L		1
+#define FT_TOUCH_Y_H		2
+#define FT_TOUCH_Y_L		3
+#define FT_TOUCH_EVENT		0
+#define FT_TOUCH_ID		2
+
+#define FT_TOUCH_X_H_REG	3
+#define FT_TOUCH_X_L_REG	4
+#define FT_TOUCH_Y_H_REG	5
+#define FT_TOUCH_Y_L_REG	6
+#define FT_TD_STATUS_REG	2
+#define FT_TOUCH_EVENT_REG	3
+#define FT_TOUCH_ID_REG		5
+
+#define FT_TOUCH_DOWN		0
+#define FT_TOUCH_CONTACT	2
+
+struct ts_event {
+	u16 au16_x[MAX_TOUCH_POINTS]; /* x coordinate */
+	u16 au16_y[MAX_TOUCH_POINTS]; /* y coordinate */
+	u8 au8_touch_event[MAX_TOUCH_POINTS]; /* touch event: 0:down; 1:up; 2:contact */
+	u8 au8_finger_id[MAX_TOUCH_POINTS]; /* touch ID */
+	u16 pressure;
+	u8 touch_point;
+	u8 point_num;
+};
+
+struct rpi_ft5406_data {
+	struct device *dev;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct ts_event event;
+	struct work_struct ft5406_work;
+
+	int is_polling;
+	int polling_enabled;
+	int known_ids;
+	int retry_count;
+};
+
+#endif
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index db105a0..91efcb8 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -526,6 +526,14 @@ config PCI_ENDPOINT_TEST
            Enable this configuration option to enable the host side test driver
            for PCI Endpoint.
 
+config RPI_DISPLAY
+	tristate "RaspberryPi 7inch Display Power Controller"
+	default y
+	depends on I2C
+	help
+	  Attiny88 controlling the power of toshiba tc358762xbg chip
+	  and backlight of RaspberryPi 7inch display.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 8515fd8..1c954a1 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -58,6 +58,7 @@ obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_ASPEED_LPC_CTRL)	+= aspeed-lpc-ctrl.o
 obj-$(CONFIG_ASPEED_LPC_SNOOP)	+= aspeed-lpc-snoop.o
 obj-$(CONFIG_PCI_ENDPOINT_TEST)	+= pci_endpoint_test.o
+obj-$(CONFIG_RPI_DISPLAY)	+= rpi_display.o
 
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_core.o
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_bugs.o
diff --git a/drivers/misc/rpi_display.c b/drivers/misc/rpi_display.c
new file mode 100644
index 00000000..3956324
--- /dev/null
+++ b/drivers/misc/rpi_display.c
@@ -0,0 +1,233 @@
+/*
+ *
+ * Raspberrypi 7inch i2c driver.
+ *
+ * Copyright (c) 2016 ASUSTek Computer Inc.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <drm/rpi_display.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include "rpi_display.h"
+
+static struct rpi_display_data *g_mcu_data;
+static int connected = 0;
+
+static int is_hex(char num)
+{
+	//0-9, a-f, A-F
+	if ((47 < num && num < 58) || (64 < num && num < 71) || (96 < num && num < 103))
+		return 1;
+	return 0;
+}
+
+static int string_to_byte(const char *source, unsigned char *destination, int size)
+{
+	int i = 0, counter = 0;
+	char c[3] = {0};
+	unsigned char bytes;
+
+	if (size%2 == 1)
+		return -EINVAL;
+
+	for(i = 0; i < size; i++){
+		if(!is_hex(source[i])) {
+			return -EINVAL;
+		}
+		if(0 == i%2){
+			c[0] = source[i];
+			c[1] = source[i+1];
+			sscanf(c, "%hhx", &bytes);
+			destination[counter] = bytes;
+			counter++;
+		}
+	}
+	return 0;
+}
+
+static int send_cmds(struct i2c_client *client, const char *buf)
+{
+	int ret, size = strlen(buf);
+	unsigned char byte_cmd[size/2];
+
+	if ((size%2) != 0) {
+		LOG_ERR("size should be even\n");
+		return -EINVAL;
+	}
+
+	LOG_INFO("%s\n", buf);
+
+	string_to_byte(buf, byte_cmd, size);
+
+	ret = i2c_master_send(client, byte_cmd, size/2);
+	if (ret <= 0) {
+		LOG_ERR("send command failed, ret = %d\n", ret);
+		return ret!=0 ? ret : -ECOMM;
+	}
+	msleep(20);
+	return 0;
+}
+
+static int recv_cmds(struct i2c_client *client, char *buf, int size)
+{
+	int ret;
+
+	ret = i2c_master_recv(client, buf, size);
+	if (ret <= 0) {
+		LOG_ERR("receive commands failed, %d\n", ret);
+		return ret!=0 ? ret : -ECOMM;
+	}
+	msleep(20);
+	return 0;
+}
+
+static int init_cmd_check(struct rpi_display_data *mcu_data)
+{
+	int ret;
+	char recv_buf[1] = {0};
+
+	ret = send_cmds(mcu_data->client, "80");
+	if (ret < 0)
+		goto error;
+
+	recv_cmds(mcu_data->client, recv_buf, 1);
+	if (ret < 0)
+		goto error;
+
+	LOG_INFO("recv_cmds: 0x%02X\n", recv_buf[0]);
+	if (recv_buf[0] != 0xC3) {
+		LOG_ERR("read wrong info\n");
+		ret = -EINVAL;
+		goto error;
+
+	}
+	return 0;
+
+error:
+	return ret;
+}
+
+int rpi_display_screen_power_up(void)
+{
+	if (!connected)
+		return -ENODEV;
+
+	LOG_INFO("\n");
+	send_cmds(g_mcu_data->client, "8500");
+	msleep(800);
+	send_cmds(g_mcu_data->client, "8501");
+	send_cmds(g_mcu_data->client, "8104");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rpi_display_screen_power_up);
+
+int rpi_display_set_bright(int bright)
+{
+	unsigned char cmd[2];
+	int ret;
+
+	if (!connected)
+		return -ENODEV;
+
+	if (bright > 0xff || bright < 0)
+		return -EINVAL;
+
+	LOG_INFO("bright = 0x%x\n", bright);
+
+	cmd[0] = 0x86;
+	cmd[1] = bright;
+
+	ret = i2c_master_send(g_mcu_data->client, cmd, 2);
+	if (ret <= 0) {
+		LOG_ERR("send command failed, ret = %d\n", ret);
+		return ret != 0 ? ret : -ECOMM;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rpi_display_set_bright);
+
+int rpi_display_is_connected(void)
+{
+	return connected;
+}
+EXPORT_SYMBOL_GPL(rpi_display_is_connected);
+
+static int rpi_display_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct rpi_display_data *mcu_data;
+	int ret;
+
+	LOG_INFO("address = 0x%02x\n", client->addr);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		LOG_ERR("I2C check functionality failed\n");
+		return -ENODEV;
+	}
+
+	mcu_data = kzalloc(sizeof(struct rpi_display_data), GFP_KERNEL);
+	if (mcu_data == NULL) {
+		LOG_ERR("no memory for device\n");
+		return -ENOMEM;
+	}
+
+	mcu_data->client = client;
+	i2c_set_clientdata(client, mcu_data);
+	g_mcu_data = mcu_data;
+
+	ret = init_cmd_check(mcu_data);
+	if (ret < 0) {
+		LOG_ERR("init_cmd_check failed, %d\n", ret);
+		goto error;
+	}
+	connected = 1;
+
+	return 0;
+
+error:
+	kfree(mcu_data);
+	return ret;
+}
+
+static int rpi_display_remove(struct i2c_client *client)
+{
+	struct rpi_display_data *mcu_data = i2c_get_clientdata(client);
+	connected = 0;
+	kfree(mcu_data);
+	return 0;
+}
+
+static const struct i2c_device_id rpi_display_id[] = {
+	{"rpi_display", 0},
+	{},
+};
+
+static struct i2c_driver rpi_display_driver = {
+	.driver = {
+		.name = "rpi_display",
+	},
+	.probe = rpi_display_probe,
+	.remove = rpi_display_remove,
+	.id_table = rpi_display_id,
+};
+module_i2c_driver(rpi_display_driver);
+
+MODULE_DESCRIPTION("Tinker Board TouchScreen MCU driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/rpi_display.h b/drivers/misc/rpi_display.h
new file mode 100644
index 00000000..83d4ba4
--- /dev/null
+++ b/drivers/misc/rpi_display.h
@@ -0,0 +1,14 @@
+#ifndef _RPI_DISPLAY_H_
+#define _RPI_DISPLAY_H_
+
+#define LOG_INFO(fmt,arg...) pr_info("raspi-display: %s: "fmt, __func__, ##arg);
+#define LOG_ERR(fmt,arg...) pr_err("raspi-display: %s: "fmt, __func__, ##arg);
+
+#define MAX_I2C_LEN 255
+
+struct rpi_display_data {
+	struct device *dev;
+	struct i2c_client *client;
+};
+
+#endif
\ No newline at end of file
diff --git a/drivers/phy/phy-mixel-mipi-dsi.c b/drivers/phy/phy-mixel-mipi-dsi.c
index 4936126..0050c10 100644
--- a/drivers/phy/phy-mixel-mipi-dsi.c
+++ b/drivers/phy/phy-mixel-mipi-dsi.c
@@ -121,6 +121,8 @@ int mixel_phy_mipi_set_phy_speed(struct phy *phy,
 	if (bit_clk > DATA_RATE_MAX_SPEED || bit_clk < DATA_RATE_MIN_SPEED)
 		return -EINVAL;
 
+	best_match = 1;
+	
 	/* simulated fixed point with 3 decimals */
 	div_rate = (bit_clk * 1000) / ref_clk;
 
diff --git a/include/drm/rpi_display.h b/include/drm/rpi_display.h
new file mode 100644
index 00000000..29eea7c
--- /dev/null
+++ b/include/drm/rpi_display.h
@@ -0,0 +1,4 @@
+int rpi_display_screen_power_up(void);
+void rpi_ft5406_start_polling(void);
+int rpi_display_set_bright(int bright);
+int rpi_display_is_connected(void);
\ No newline at end of file
